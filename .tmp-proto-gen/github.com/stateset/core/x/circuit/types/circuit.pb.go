// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: stateset/circuit/circuit.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// CircuitStatus represents the state of a circuit breaker.
type CircuitStatus int32

const (
	// CIRCUIT_CLOSED means the circuit is functioning normally.
	CircuitStatus_CIRCUIT_CLOSED CircuitStatus = 0
	// CIRCUIT_OPEN means the circuit is tripped and operations are blocked.
	CircuitStatus_CIRCUIT_OPEN CircuitStatus = 1
	// CIRCUIT_HALF_OPEN means the circuit is in recovery mode.
	CircuitStatus_CIRCUIT_HALF_OPEN CircuitStatus = 2
)

var CircuitStatus_name = map[int32]string{
	0: "CIRCUIT_CLOSED",
	1: "CIRCUIT_OPEN",
	2: "CIRCUIT_HALF_OPEN",
}

var CircuitStatus_value = map[string]int32{
	"CIRCUIT_CLOSED":    0,
	"CIRCUIT_OPEN":      1,
	"CIRCUIT_HALF_OPEN": 2,
}

func (x CircuitStatus) String() string {
	return proto.EnumName(CircuitStatus_name, int32(x))
}

func (CircuitStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4035fe7ef9c5c60e, []int{0}
}

// CircuitState represents the global circuit breaker state.
type CircuitState struct {
	GlobalPaused bool      `protobuf:"varint,1,opt,name=global_paused,json=globalPaused,proto3" json:"global_paused,omitempty"`
	PausedAt     time.Time `protobuf:"bytes,2,opt,name=paused_at,json=pausedAt,proto3,stdtime" json:"paused_at"`
	PausedBy     string    `protobuf:"bytes,3,opt,name=paused_by,json=pausedBy,proto3" json:"paused_by,omitempty"`
	Reason       string    `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	AutoResumeAt time.Time `protobuf:"bytes,5,opt,name=auto_resume_at,json=autoResumeAt,proto3,stdtime" json:"auto_resume_at"`
}

func (m *CircuitState) Reset()         { *m = CircuitState{} }
func (m *CircuitState) String() string { return proto.CompactTextString(m) }
func (*CircuitState) ProtoMessage()    {}
func (*CircuitState) Descriptor() ([]byte, []int) {
	return fileDescriptor_4035fe7ef9c5c60e, []int{0}
}
func (m *CircuitState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CircuitState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CircuitState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CircuitState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CircuitState.Merge(m, src)
}
func (m *CircuitState) XXX_Size() int {
	return m.Size()
}
func (m *CircuitState) XXX_DiscardUnknown() {
	xxx_messageInfo_CircuitState.DiscardUnknown(m)
}

var xxx_messageInfo_CircuitState proto.InternalMessageInfo

func (m *CircuitState) GetGlobalPaused() bool {
	if m != nil {
		return m.GlobalPaused
	}
	return false
}

func (m *CircuitState) GetPausedAt() time.Time {
	if m != nil {
		return m.PausedAt
	}
	return time.Time{}
}

func (m *CircuitState) GetPausedBy() string {
	if m != nil {
		return m.PausedBy
	}
	return ""
}

func (m *CircuitState) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *CircuitState) GetAutoResumeAt() time.Time {
	if m != nil {
		return m.AutoResumeAt
	}
	return time.Time{}
}

// ModuleCircuitState represents circuit breaker state for a specific module.
type ModuleCircuitState struct {
	ModuleName       string        `protobuf:"bytes,1,opt,name=module_name,json=moduleName,proto3" json:"module_name,omitempty"`
	Status           CircuitStatus `protobuf:"varint,2,opt,name=status,proto3,enum=stateset.circuit.CircuitStatus" json:"status,omitempty"`
	TrippedAt        time.Time     `protobuf:"bytes,3,opt,name=tripped_at,json=trippedAt,proto3,stdtime" json:"tripped_at"`
	TrippedBy        string        `protobuf:"bytes,4,opt,name=tripped_by,json=trippedBy,proto3" json:"tripped_by,omitempty"`
	Reason           string        `protobuf:"bytes,5,opt,name=reason,proto3" json:"reason,omitempty"`
	FailureCount     uint64        `protobuf:"varint,6,opt,name=failure_count,json=failureCount,proto3" json:"failure_count,omitempty"`
	FailureThreshold uint64        `protobuf:"varint,7,opt,name=failure_threshold,json=failureThreshold,proto3" json:"failure_threshold,omitempty"`
	RecoveryTime     time.Time     `protobuf:"bytes,8,opt,name=recovery_time,json=recoveryTime,proto3,stdtime" json:"recovery_time"`
	DisabledMessages []string      `protobuf:"bytes,9,rep,name=disabled_messages,json=disabledMessages,proto3" json:"disabled_messages,omitempty"`
}

func (m *ModuleCircuitState) Reset()         { *m = ModuleCircuitState{} }
func (m *ModuleCircuitState) String() string { return proto.CompactTextString(m) }
func (*ModuleCircuitState) ProtoMessage()    {}
func (*ModuleCircuitState) Descriptor() ([]byte, []int) {
	return fileDescriptor_4035fe7ef9c5c60e, []int{1}
}
func (m *ModuleCircuitState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleCircuitState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleCircuitState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModuleCircuitState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleCircuitState.Merge(m, src)
}
func (m *ModuleCircuitState) XXX_Size() int {
	return m.Size()
}
func (m *ModuleCircuitState) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleCircuitState.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleCircuitState proto.InternalMessageInfo

func (m *ModuleCircuitState) GetModuleName() string {
	if m != nil {
		return m.ModuleName
	}
	return ""
}

func (m *ModuleCircuitState) GetStatus() CircuitStatus {
	if m != nil {
		return m.Status
	}
	return CircuitStatus_CIRCUIT_CLOSED
}

func (m *ModuleCircuitState) GetTrippedAt() time.Time {
	if m != nil {
		return m.TrippedAt
	}
	return time.Time{}
}

func (m *ModuleCircuitState) GetTrippedBy() string {
	if m != nil {
		return m.TrippedBy
	}
	return ""
}

func (m *ModuleCircuitState) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *ModuleCircuitState) GetFailureCount() uint64 {
	if m != nil {
		return m.FailureCount
	}
	return 0
}

func (m *ModuleCircuitState) GetFailureThreshold() uint64 {
	if m != nil {
		return m.FailureThreshold
	}
	return 0
}

func (m *ModuleCircuitState) GetRecoveryTime() time.Time {
	if m != nil {
		return m.RecoveryTime
	}
	return time.Time{}
}

func (m *ModuleCircuitState) GetDisabledMessages() []string {
	if m != nil {
		return m.DisabledMessages
	}
	return nil
}

// RateLimitConfig defines rate limiting configuration.
type RateLimitConfig struct {
	Name          string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	MaxRequests   uint64   `protobuf:"varint,2,opt,name=max_requests,json=maxRequests,proto3" json:"max_requests,omitempty"`
	WindowSeconds int64    `protobuf:"varint,3,opt,name=window_seconds,json=windowSeconds,proto3" json:"window_seconds,omitempty"`
	PerAddress    bool     `protobuf:"varint,4,opt,name=per_address,json=perAddress,proto3" json:"per_address,omitempty"`
	Enabled       bool     `protobuf:"varint,5,opt,name=enabled,proto3" json:"enabled,omitempty"`
	MessageTypes  []string `protobuf:"bytes,6,rep,name=message_types,json=messageTypes,proto3" json:"message_types,omitempty"`
}

func (m *RateLimitConfig) Reset()         { *m = RateLimitConfig{} }
func (m *RateLimitConfig) String() string { return proto.CompactTextString(m) }
func (*RateLimitConfig) ProtoMessage()    {}
func (*RateLimitConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4035fe7ef9c5c60e, []int{2}
}
func (m *RateLimitConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimitConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimitConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimitConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimitConfig.Merge(m, src)
}
func (m *RateLimitConfig) XXX_Size() int {
	return m.Size()
}
func (m *RateLimitConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimitConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimitConfig proto.InternalMessageInfo

func (m *RateLimitConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RateLimitConfig) GetMaxRequests() uint64 {
	if m != nil {
		return m.MaxRequests
	}
	return 0
}

func (m *RateLimitConfig) GetWindowSeconds() int64 {
	if m != nil {
		return m.WindowSeconds
	}
	return 0
}

func (m *RateLimitConfig) GetPerAddress() bool {
	if m != nil {
		return m.PerAddress
	}
	return false
}

func (m *RateLimitConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *RateLimitConfig) GetMessageTypes() []string {
	if m != nil {
		return m.MessageTypes
	}
	return nil
}

// RateLimitState tracks current rate limit usage.
type RateLimitState struct {
	ConfigName   string    `protobuf:"bytes,1,opt,name=config_name,json=configName,proto3" json:"config_name,omitempty"`
	Address      string    `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	RequestCount uint64    `protobuf:"varint,3,opt,name=request_count,json=requestCount,proto3" json:"request_count,omitempty"`
	WindowStart  time.Time `protobuf:"bytes,4,opt,name=window_start,json=windowStart,proto3,stdtime" json:"window_start"`
}

func (m *RateLimitState) Reset()         { *m = RateLimitState{} }
func (m *RateLimitState) String() string { return proto.CompactTextString(m) }
func (*RateLimitState) ProtoMessage()    {}
func (*RateLimitState) Descriptor() ([]byte, []int) {
	return fileDescriptor_4035fe7ef9c5c60e, []int{3}
}
func (m *RateLimitState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimitState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimitState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimitState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimitState.Merge(m, src)
}
func (m *RateLimitState) XXX_Size() int {
	return m.Size()
}
func (m *RateLimitState) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimitState.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimitState proto.InternalMessageInfo

func (m *RateLimitState) GetConfigName() string {
	if m != nil {
		return m.ConfigName
	}
	return ""
}

func (m *RateLimitState) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RateLimitState) GetRequestCount() uint64 {
	if m != nil {
		return m.RequestCount
	}
	return 0
}

func (m *RateLimitState) GetWindowStart() time.Time {
	if m != nil {
		return m.WindowStart
	}
	return time.Time{}
}

// Params defines the circuit breaker module parameters.
type Params struct {
	Authorities             []string          `protobuf:"bytes,1,rep,name=authorities,proto3" json:"authorities,omitempty"`
	DefaultFailureThreshold uint64            `protobuf:"varint,2,opt,name=default_failure_threshold,json=defaultFailureThreshold,proto3" json:"default_failure_threshold,omitempty"`
	DefaultRecoveryPeriod   int64             `protobuf:"varint,3,opt,name=default_recovery_period,json=defaultRecoveryPeriod,proto3" json:"default_recovery_period,omitempty"`
	MaxPauseDuration        int64             `protobuf:"varint,4,opt,name=max_pause_duration,json=maxPauseDuration,proto3" json:"max_pause_duration,omitempty"`
	RateLimits              []RateLimitConfig `protobuf:"bytes,5,rep,name=rate_limits,json=rateLimits,proto3" json:"rate_limits"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_4035fe7ef9c5c60e, []int{4}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetAuthorities() []string {
	if m != nil {
		return m.Authorities
	}
	return nil
}

func (m *Params) GetDefaultFailureThreshold() uint64 {
	if m != nil {
		return m.DefaultFailureThreshold
	}
	return 0
}

func (m *Params) GetDefaultRecoveryPeriod() int64 {
	if m != nil {
		return m.DefaultRecoveryPeriod
	}
	return 0
}

func (m *Params) GetMaxPauseDuration() int64 {
	if m != nil {
		return m.MaxPauseDuration
	}
	return 0
}

func (m *Params) GetRateLimits() []RateLimitConfig {
	if m != nil {
		return m.RateLimits
	}
	return nil
}

// OracleDeviationConfig defines price deviation thresholds.
type OracleDeviationConfig struct {
	Denom                string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	MaxDeviationBps      uint64 `protobuf:"varint,2,opt,name=max_deviation_bps,json=maxDeviationBps,proto3" json:"max_deviation_bps,omitempty"`
	MaxDailyDeviationBps uint64 `protobuf:"varint,3,opt,name=max_daily_deviation_bps,json=maxDailyDeviationBps,proto3" json:"max_daily_deviation_bps,omitempty"`
	StalenessThreshold   int64  `protobuf:"varint,4,opt,name=staleness_threshold,json=stalenessThreshold,proto3" json:"staleness_threshold,omitempty"`
	MinUpdateInterval    int64  `protobuf:"varint,5,opt,name=min_update_interval,json=minUpdateInterval,proto3" json:"min_update_interval,omitempty"`
}

func (m *OracleDeviationConfig) Reset()         { *m = OracleDeviationConfig{} }
func (m *OracleDeviationConfig) String() string { return proto.CompactTextString(m) }
func (*OracleDeviationConfig) ProtoMessage()    {}
func (*OracleDeviationConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4035fe7ef9c5c60e, []int{5}
}
func (m *OracleDeviationConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleDeviationConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleDeviationConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleDeviationConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleDeviationConfig.Merge(m, src)
}
func (m *OracleDeviationConfig) XXX_Size() int {
	return m.Size()
}
func (m *OracleDeviationConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleDeviationConfig.DiscardUnknown(m)
}

var xxx_messageInfo_OracleDeviationConfig proto.InternalMessageInfo

func (m *OracleDeviationConfig) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *OracleDeviationConfig) GetMaxDeviationBps() uint64 {
	if m != nil {
		return m.MaxDeviationBps
	}
	return 0
}

func (m *OracleDeviationConfig) GetMaxDailyDeviationBps() uint64 {
	if m != nil {
		return m.MaxDailyDeviationBps
	}
	return 0
}

func (m *OracleDeviationConfig) GetStalenessThreshold() int64 {
	if m != nil {
		return m.StalenessThreshold
	}
	return 0
}

func (m *OracleDeviationConfig) GetMinUpdateInterval() int64 {
	if m != nil {
		return m.MinUpdateInterval
	}
	return 0
}

// LiquidationSurgeProtection defines protection against liquidation cascades.
type LiquidationSurgeProtection struct {
	MaxLiquidationsPerBlock  uint64                `protobuf:"varint,1,opt,name=max_liquidations_per_block,json=maxLiquidationsPerBlock,proto3" json:"max_liquidations_per_block,omitempty"`
	MaxLiquidationValue      cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=max_liquidation_value,json=maxLiquidationValue,proto3,customtype=cosmossdk.io/math.Int" json:"max_liquidation_value"`
	CooldownBlocks           uint64                `protobuf:"varint,3,opt,name=cooldown_blocks,json=cooldownBlocks,proto3" json:"cooldown_blocks,omitempty"`
	CurrentBlockLiquidations uint64                `protobuf:"varint,4,opt,name=current_block_liquidations,json=currentBlockLiquidations,proto3" json:"current_block_liquidations,omitempty"`
	CurrentBlockValue        cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=current_block_value,json=currentBlockValue,proto3,customtype=cosmossdk.io/math.Int" json:"current_block_value"`
	LastResetHeight          int64                 `protobuf:"varint,6,opt,name=last_reset_height,json=lastResetHeight,proto3" json:"last_reset_height,omitempty"`
}

func (m *LiquidationSurgeProtection) Reset()         { *m = LiquidationSurgeProtection{} }
func (m *LiquidationSurgeProtection) String() string { return proto.CompactTextString(m) }
func (*LiquidationSurgeProtection) ProtoMessage()    {}
func (*LiquidationSurgeProtection) Descriptor() ([]byte, []int) {
	return fileDescriptor_4035fe7ef9c5c60e, []int{6}
}
func (m *LiquidationSurgeProtection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidationSurgeProtection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidationSurgeProtection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidationSurgeProtection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidationSurgeProtection.Merge(m, src)
}
func (m *LiquidationSurgeProtection) XXX_Size() int {
	return m.Size()
}
func (m *LiquidationSurgeProtection) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidationSurgeProtection.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidationSurgeProtection proto.InternalMessageInfo

func (m *LiquidationSurgeProtection) GetMaxLiquidationsPerBlock() uint64 {
	if m != nil {
		return m.MaxLiquidationsPerBlock
	}
	return 0
}

func (m *LiquidationSurgeProtection) GetCooldownBlocks() uint64 {
	if m != nil {
		return m.CooldownBlocks
	}
	return 0
}

func (m *LiquidationSurgeProtection) GetCurrentBlockLiquidations() uint64 {
	if m != nil {
		return m.CurrentBlockLiquidations
	}
	return 0
}

func (m *LiquidationSurgeProtection) GetLastResetHeight() int64 {
	if m != nil {
		return m.LastResetHeight
	}
	return 0
}

// GenesisState defines the circuit module's genesis state.
type GenesisState struct {
	Params                 Params                     `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
	CircuitState           CircuitState               `protobuf:"bytes,2,opt,name=circuit_state,json=circuitState,proto3" json:"circuit_state"`
	ModuleCircuits         []ModuleCircuitState       `protobuf:"bytes,3,rep,name=module_circuits,json=moduleCircuits,proto3" json:"module_circuits"`
	RateLimitStates        []RateLimitState           `protobuf:"bytes,4,rep,name=rate_limit_states,json=rateLimitStates,proto3" json:"rate_limit_states"`
	OracleDeviationConfigs []OracleDeviationConfig    `protobuf:"bytes,5,rep,name=oracle_deviation_configs,json=oracleDeviationConfigs,proto3" json:"oracle_deviation_configs"`
	LiquidationProtection  LiquidationSurgeProtection `protobuf:"bytes,6,opt,name=liquidation_protection,json=liquidationProtection,proto3" json:"liquidation_protection"`
}

func (m *GenesisState) Reset()         { *m = GenesisState{} }
func (m *GenesisState) String() string { return proto.CompactTextString(m) }
func (*GenesisState) ProtoMessage()    {}
func (*GenesisState) Descriptor() ([]byte, []int) {
	return fileDescriptor_4035fe7ef9c5c60e, []int{7}
}
func (m *GenesisState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisState.Merge(m, src)
}
func (m *GenesisState) XXX_Size() int {
	return m.Size()
}
func (m *GenesisState) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisState.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisState proto.InternalMessageInfo

func (m *GenesisState) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

func (m *GenesisState) GetCircuitState() CircuitState {
	if m != nil {
		return m.CircuitState
	}
	return CircuitState{}
}

func (m *GenesisState) GetModuleCircuits() []ModuleCircuitState {
	if m != nil {
		return m.ModuleCircuits
	}
	return nil
}

func (m *GenesisState) GetRateLimitStates() []RateLimitState {
	if m != nil {
		return m.RateLimitStates
	}
	return nil
}

func (m *GenesisState) GetOracleDeviationConfigs() []OracleDeviationConfig {
	if m != nil {
		return m.OracleDeviationConfigs
	}
	return nil
}

func (m *GenesisState) GetLiquidationProtection() LiquidationSurgeProtection {
	if m != nil {
		return m.LiquidationProtection
	}
	return LiquidationSurgeProtection{}
}

func init() {
	proto.RegisterEnum("stateset.circuit.CircuitStatus", CircuitStatus_name, CircuitStatus_value)
	proto.RegisterType((*CircuitState)(nil), "stateset.circuit.CircuitState")
	proto.RegisterType((*ModuleCircuitState)(nil), "stateset.circuit.ModuleCircuitState")
	proto.RegisterType((*RateLimitConfig)(nil), "stateset.circuit.RateLimitConfig")
	proto.RegisterType((*RateLimitState)(nil), "stateset.circuit.RateLimitState")
	proto.RegisterType((*Params)(nil), "stateset.circuit.Params")
	proto.RegisterType((*OracleDeviationConfig)(nil), "stateset.circuit.OracleDeviationConfig")
	proto.RegisterType((*LiquidationSurgeProtection)(nil), "stateset.circuit.LiquidationSurgeProtection")
	proto.RegisterType((*GenesisState)(nil), "stateset.circuit.GenesisState")
}

func init() { proto.RegisterFile("stateset/circuit/circuit.proto", fileDescriptor_4035fe7ef9c5c60e) }

var fileDescriptor_4035fe7ef9c5c60e = []byte{
	// 1273 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0x4d, 0x6f, 0x1b, 0x45,
	0x18, 0xce, 0xc6, 0x4e, 0x9a, 0xbc, 0x76, 0x1c, 0x7b, 0xd2, 0xb4, 0xdb, 0x20, 0x1c, 0xd7, 0x05,
	0xd5, 0x6a, 0x8b, 0x2d, 0x05, 0x51, 0x24, 0xe0, 0x12, 0xbb, 0x5f, 0x41, 0x69, 0x1b, 0x6d, 0x52,
	0x0e, 0x70, 0x58, 0x8d, 0x77, 0x27, 0xf6, 0xa8, 0xbb, 0x3b, 0xdb, 0x99, 0xd9, 0x34, 0xf9, 0x13,
	0xa8, 0x27, 0x7e, 0x04, 0xe7, 0x5e, 0xf8, 0x07, 0xbd, 0x51, 0x71, 0x42, 0x1c, 0x0a, 0x6a, 0x7f,
	0x01, 0x27, 0xae, 0x68, 0x3e, 0xd6, 0x59, 0xc7, 0xa5, 0x22, 0x27, 0x7b, 0x9e, 0xe7, 0xfd, 0x98,
	0xf7, 0x7d, 0xde, 0x99, 0x59, 0x68, 0x0a, 0x89, 0x25, 0x11, 0x44, 0xf6, 0x02, 0xca, 0x83, 0x8c,
	0x4e, 0x7e, 0xbb, 0x29, 0x67, 0x92, 0xa1, 0x7a, 0xce, 0x77, 0x2d, 0xbe, 0x71, 0x71, 0xc4, 0x46,
	0x4c, 0x93, 0x3d, 0xf5, 0xcf, 0xd8, 0x6d, 0x5c, 0x09, 0x98, 0x88, 0x99, 0xf0, 0x0d, 0x61, 0x16,
	0x96, 0xda, 0x1c, 0x31, 0x36, 0x8a, 0x48, 0x4f, 0xaf, 0x86, 0xd9, 0x61, 0x4f, 0xd2, 0x98, 0x08,
	0x89, 0xe3, 0xd4, 0x18, 0xb4, 0xff, 0x71, 0xa0, 0x3a, 0x30, 0xd1, 0xf7, 0x55, 0x36, 0x74, 0x0d,
	0x56, 0x46, 0x11, 0x1b, 0xe2, 0xc8, 0x4f, 0x71, 0x26, 0x48, 0xe8, 0x3a, 0x2d, 0xa7, 0xb3, 0xe4,
	0x55, 0x0d, 0xb8, 0xa7, 0x31, 0xb4, 0x0d, 0xcb, 0x86, 0xf5, 0xb1, 0x74, 0xe7, 0x5b, 0x4e, 0xa7,
	0xb2, 0xb5, 0xd1, 0x35, 0xa9, 0xba, 0x79, 0xaa, 0xee, 0x41, 0x9e, 0xaa, 0xbf, 0xf4, 0xea, 0xcd,
	0xe6, 0xdc, 0x8b, 0x3f, 0x37, 0x1d, 0x6f, 0xc9, 0xb8, 0x6d, 0x4b, 0xf4, 0xd1, 0x24, 0xc4, 0xf0,
	0xc4, 0x2d, 0xb5, 0x9c, 0xce, 0x72, 0x4e, 0xf6, 0x4f, 0xd0, 0x25, 0x58, 0xe4, 0x04, 0x0b, 0x96,
	0xb8, 0x65, 0xcd, 0xd8, 0x15, 0xfa, 0x16, 0x6a, 0x38, 0x93, 0xcc, 0xe7, 0x44, 0x64, 0x31, 0x51,
	0xc9, 0x17, 0xce, 0x91, 0xbc, 0xaa, 0x7c, 0x3d, 0xed, 0xba, 0x2d, 0xdb, 0x2f, 0x4b, 0x80, 0x1e,
	0xb2, 0x30, 0x8b, 0xc8, 0x54, 0xfd, 0x9b, 0x50, 0x89, 0x35, 0xea, 0x27, 0x38, 0x26, 0xba, 0xfa,
	0x65, 0x0f, 0x0c, 0xf4, 0x08, 0xc7, 0x04, 0x7d, 0x09, 0x8b, 0x4a, 0x97, 0x4c, 0xe8, 0xc2, 0x6b,
	0x5b, 0x9b, 0xdd, 0xb3, 0x32, 0x75, 0x0b, 0x01, 0x33, 0xe1, 0x59, 0x73, 0x34, 0x00, 0x90, 0x9c,
	0xa6, 0xa9, 0xe9, 0x5a, 0xe9, 0x1c, 0x1b, 0x5f, 0xb6, 0x7e, 0xdb, 0x12, 0x7d, 0x7c, 0x1a, 0x64,
	0x78, 0x62, 0xbb, 0x93, 0xd3, 0x53, 0x8d, 0x5b, 0x98, 0x6a, 0xdc, 0x35, 0x58, 0x39, 0xc4, 0x34,
	0xca, 0x38, 0xf1, 0x03, 0x96, 0x25, 0xd2, 0x5d, 0x6c, 0x39, 0x9d, 0xb2, 0x57, 0xb5, 0xe0, 0x40,
	0x61, 0xe8, 0x26, 0x34, 0x72, 0x23, 0x39, 0xe6, 0x44, 0x8c, 0x59, 0x14, 0xba, 0x17, 0xb4, 0x61,
	0xdd, 0x12, 0x07, 0x39, 0x8e, 0x76, 0x60, 0x85, 0x93, 0x80, 0x1d, 0x11, 0x7e, 0xe2, 0xab, 0xa1,
	0x72, 0x97, 0xce, 0xa3, 0x44, 0xee, 0xaa, 0x48, 0x95, 0x37, 0xa4, 0x02, 0x0f, 0x23, 0x12, 0xfa,
	0x31, 0x11, 0x02, 0x8f, 0x88, 0x70, 0x97, 0x5b, 0xa5, 0xce, 0xb2, 0x57, 0xcf, 0x89, 0x87, 0x16,
	0x6f, 0xff, 0xea, 0xc0, 0xaa, 0x87, 0x25, 0xd9, 0xa5, 0x31, 0x95, 0x03, 0x96, 0x1c, 0xd2, 0x11,
	0x42, 0x50, 0x2e, 0x88, 0xa5, 0xff, 0xa3, 0xab, 0x50, 0x8d, 0xf1, 0xb1, 0xcf, 0xc9, 0xb3, 0x8c,
	0x08, 0x69, 0xc4, 0x2a, 0x7b, 0x95, 0x18, 0x1f, 0x7b, 0x16, 0x42, 0x9f, 0x42, 0xed, 0x39, 0x4d,
	0x42, 0xf6, 0xdc, 0x17, 0x24, 0x60, 0x49, 0x28, 0xb4, 0x28, 0x25, 0x6f, 0xc5, 0xa0, 0xfb, 0x06,
	0x54, 0x13, 0x91, 0x12, 0xee, 0xe3, 0x30, 0xe4, 0x44, 0x08, 0xdd, 0xf3, 0x25, 0x0f, 0x52, 0xc2,
	0xb7, 0x0d, 0x82, 0x5c, 0xb8, 0x40, 0x12, 0xbd, 0x4b, 0xdd, 0xf5, 0x25, 0x2f, 0x5f, 0xaa, 0xb6,
	0xdb, 0x82, 0x7c, 0x79, 0x92, 0x12, 0xe1, 0x2e, 0xea, 0xaa, 0xaa, 0x16, 0x3c, 0x50, 0x58, 0xfb,
	0x17, 0x07, 0x6a, 0x93, 0x8a, 0x26, 0x43, 0x18, 0xe8, 0xd2, 0xa6, 0x86, 0xd0, 0x40, 0x7a, 0x08,
	0x5d, 0xb8, 0x90, 0xef, 0x67, 0x5e, 0x93, 0xf9, 0x52, 0xa5, 0xb4, 0x35, 0x5b, 0xa5, 0x4b, 0x46,
	0x69, 0x0b, 0x1a, 0xa5, 0xef, 0x43, 0x35, 0xaf, 0x5c, 0x62, 0x2e, 0x75, 0x4d, 0xff, 0x57, 0xbb,
	0x8a, 0xed, 0x8e, 0x72, 0x6c, 0xff, 0x34, 0x0f, 0x8b, 0x7b, 0x98, 0xe3, 0x58, 0xa0, 0x16, 0x54,
	0x70, 0x26, 0xc7, 0x8c, 0x53, 0x49, 0x89, 0x70, 0x1d, 0x5d, 0x69, 0x11, 0x42, 0x5f, 0xc1, 0x95,
	0x90, 0x1c, 0xe2, 0x2c, 0x92, 0xfe, 0xec, 0x9c, 0x19, 0x7d, 0x2e, 0x5b, 0x83, 0x7b, 0x67, 0xc7,
	0xed, 0x36, 0xe4, 0x94, 0x3f, 0x19, 0xbb, 0x94, 0x70, 0xca, 0x42, 0x2b, 0xda, 0xba, 0xa5, 0x3d,
	0xcb, 0xee, 0x69, 0x12, 0xdd, 0x02, 0xa4, 0xc6, 0x40, 0xdf, 0x2c, 0x7e, 0x98, 0x71, 0x2c, 0xa9,
	0xbd, 0x55, 0x4a, 0x5e, 0x3d, 0xc6, 0xc7, 0xfa, 0x42, 0xbb, 0x63, 0x71, 0xf4, 0x00, 0x2a, 0x1c,
	0x4b, 0xe2, 0x47, 0x4a, 0x0a, 0xe1, 0x2e, 0xb4, 0x4a, 0x9d, 0xca, 0xd6, 0xd5, 0xd9, 0x03, 0x7e,
	0x66, 0x00, 0xfb, 0x65, 0xd5, 0x1d, 0x0f, 0x78, 0x0e, 0x8b, 0xf6, 0xdf, 0x0e, 0xac, 0x3f, 0xe6,
	0x38, 0x88, 0xc8, 0x1d, 0x72, 0x44, 0x75, 0x74, 0x3b, 0xac, 0x17, 0x61, 0x21, 0x24, 0x09, 0x8b,
	0xad, 0xaa, 0x66, 0x81, 0x6e, 0x40, 0x43, 0xed, 0x33, 0xcc, 0x8d, 0xfd, 0x61, 0x9a, 0xcf, 0xec,
	0x6a, 0x8c, 0x8f, 0x27, 0x41, 0xfa, 0xa9, 0x40, 0x5f, 0xc0, 0x65, 0x6d, 0x8b, 0x69, 0x74, 0x72,
	0xc6, 0xc3, 0x88, 0x7d, 0x51, 0x79, 0x28, 0x76, 0xca, 0xad, 0x07, 0x6b, 0x42, 0xe2, 0x88, 0x24,
	0x44, 0x88, 0x42, 0xe3, 0x4d, 0x2f, 0xd0, 0x84, 0x3a, 0xed, 0x79, 0x17, 0xd6, 0x62, 0x9a, 0xf8,
	0x59, 0x1a, 0xaa, 0x9e, 0xd0, 0x44, 0x12, 0x7e, 0x84, 0x23, 0x3d, 0xe3, 0x25, 0xaf, 0x11, 0xd3,
	0xe4, 0x89, 0x66, 0x76, 0x2c, 0xd1, 0xfe, 0xb9, 0x04, 0x1b, 0xbb, 0xf4, 0x59, 0x46, 0x43, 0x9d,
	0x73, 0x3f, 0xe3, 0x23, 0xb2, 0xc7, 0x99, 0x24, 0x81, 0x6e, 0xee, 0xd7, 0xb0, 0xa1, 0xb6, 0x1d,
	0x9d, 0x5a, 0x08, 0x25, 0xa1, 0x3f, 0x8c, 0x58, 0xf0, 0x54, 0x77, 0xa3, 0xec, 0xa9, 0xc2, 0x0a,
	0x21, 0xc4, 0x1e, 0xe1, 0x7d, 0x45, 0x23, 0x1f, 0xd6, 0xcf, 0x38, 0xfb, 0x47, 0x38, 0xca, 0x88,
	0x19, 0xff, 0xfe, 0x4d, 0x25, 0xc0, 0x1f, 0x6f, 0x36, 0xd7, 0xcd, 0xeb, 0x27, 0xc2, 0xa7, 0x5d,
	0xca, 0x7a, 0x31, 0x96, 0xe3, 0xee, 0x4e, 0x22, 0x7f, 0x7b, 0xf9, 0x19, 0xd8, 0x67, 0x71, 0x27,
	0x91, 0xde, 0xda, 0x74, 0x92, 0xef, 0x54, 0x1c, 0x74, 0x1d, 0x56, 0x03, 0xc6, 0xa2, 0x90, 0x3d,
	0x4f, 0xcc, 0x8e, 0xf2, 0x66, 0xd6, 0x72, 0x58, 0x6f, 0x44, 0xa0, 0x6f, 0x60, 0x23, 0xc8, 0x38,
	0x27, 0x89, 0x34, 0x76, 0x53, 0x05, 0xe9, 0x6e, 0x96, 0x3d, 0xd7, 0x5a, 0x68, 0x97, 0x62, 0x3d,
	0xe8, 0x07, 0x58, 0x9b, 0xf6, 0x36, 0x55, 0x2c, 0x9c, 0xbf, 0x8a, 0x46, 0x31, 0x87, 0xa9, 0xe1,
	0x06, 0x34, 0x22, 0x2c, 0xd4, 0x09, 0x11, 0x44, 0xfa, 0x63, 0x42, 0x47, 0x63, 0x73, 0xd3, 0x97,
	0xbc, 0x55, 0x45, 0x78, 0x0a, 0x7f, 0xa0, 0xe1, 0xf6, 0x8f, 0x65, 0xa8, 0xde, 0x57, 0x82, 0x53,
	0x61, 0xee, 0x9c, 0xdb, 0xb0, 0x98, 0xea, 0x93, 0xac, 0xa5, 0xa8, 0x6c, 0xb9, 0xb3, 0x63, 0x6f,
	0x4e, 0xba, 0x9d, 0x76, 0x6b, 0xad, 0x1e, 0x02, 0xcb, 0xfb, 0xda, 0xc1, 0x7e, 0x0f, 0x34, 0x3f,
	0xf8, 0x2c, 0x12, 0x1b, 0xa4, 0x1a, 0x14, 0xdf, 0xde, 0x7d, 0x58, 0xb5, 0x6f, 0xaf, 0x85, 0x95,
	0x06, 0xea, 0x08, 0x7e, 0x32, 0x1b, 0x6c, 0xf6, 0xe9, 0xb6, 0x21, 0x6b, 0x71, 0x91, 0x11, 0xc8,
	0x83, 0xc6, 0xe9, 0x99, 0x36, 0x5b, 0x54, 0x32, 0xa9, 0xb0, 0xad, 0x0f, 0x9c, 0xec, 0x62, 0xc8,
	0x55, 0x3e, 0x85, 0x0a, 0x34, 0x02, 0x97, 0xe9, 0xc3, 0x5d, 0x38, 0x7e, 0xe6, 0x76, 0xce, 0x2f,
	0x8d, 0xeb, 0xb3, 0xa1, 0xdf, 0x7b, 0x1d, 0xd8, 0x0c, 0x97, 0xd8, 0xfb, 0x48, 0x81, 0x28, 0x5c,
	0x2a, 0x8e, 0x7c, 0x3a, 0x39, 0x4d, 0x5a, 0xd6, 0xca, 0xd6, 0xad, 0xd9, 0x34, 0xff, 0x7d, 0x02,
	0x6d, 0xae, 0xf5, 0x42, 0xc4, 0x53, 0xf2, 0xc6, 0x2e, 0xac, 0x4c, 0x7d, 0xb7, 0x20, 0x04, 0xb5,
	0xc1, 0x8e, 0x37, 0x78, 0xb2, 0x73, 0xe0, 0x0f, 0x76, 0x1f, 0xef, 0xdf, 0xbd, 0x53, 0x9f, 0x43,
	0x75, 0xa8, 0xe6, 0xd8, 0xe3, 0xbd, 0xbb, 0x8f, 0xea, 0x0e, 0x5a, 0x87, 0x46, 0x8e, 0x3c, 0xd8,
	0xde, 0xbd, 0x67, 0xe0, 0xf9, 0x7e, 0xff, 0xd5, 0xdb, 0xa6, 0xf3, 0xfa, 0x6d, 0xd3, 0xf9, 0xeb,
	0x6d, 0xd3, 0x79, 0xf1, 0xae, 0x39, 0xf7, 0xfa, 0x5d, 0x73, 0xee, 0xf7, 0x77, 0xcd, 0xb9, 0xef,
	0x3b, 0x23, 0x2a, 0xc7, 0xd9, 0xb0, 0x1b, 0xb0, 0xb8, 0x77, 0xfa, 0x01, 0xcc, 0x38, 0xe9, 0x1d,
	0x4f, 0xbe, 0x83, 0xf5, 0x63, 0x39, 0x5c, 0xd4, 0xef, 0xd0, 0xe7, 0xff, 0x06, 0x00, 0x00, 0xff,
	0xff, 0x94, 0xec, 0x24, 0x12, 0x28, 0x0b, 0x00, 0x00,
}

func (m *CircuitState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CircuitState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CircuitState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.AutoResumeAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.AutoResumeAt):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintCircuit(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x2a
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintCircuit(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PausedBy) > 0 {
		i -= len(m.PausedBy)
		copy(dAtA[i:], m.PausedBy)
		i = encodeVarintCircuit(dAtA, i, uint64(len(m.PausedBy)))
		i--
		dAtA[i] = 0x1a
	}
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.PausedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.PausedAt):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintCircuit(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x12
	if m.GlobalPaused {
		i--
		if m.GlobalPaused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ModuleCircuitState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleCircuitState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModuleCircuitState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DisabledMessages) > 0 {
		for iNdEx := len(m.DisabledMessages) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DisabledMessages[iNdEx])
			copy(dAtA[i:], m.DisabledMessages[iNdEx])
			i = encodeVarintCircuit(dAtA, i, uint64(len(m.DisabledMessages[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.RecoveryTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.RecoveryTime):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintCircuit(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x42
	if m.FailureThreshold != 0 {
		i = encodeVarintCircuit(dAtA, i, uint64(m.FailureThreshold))
		i--
		dAtA[i] = 0x38
	}
	if m.FailureCount != 0 {
		i = encodeVarintCircuit(dAtA, i, uint64(m.FailureCount))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintCircuit(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TrippedBy) > 0 {
		i -= len(m.TrippedBy)
		copy(dAtA[i:], m.TrippedBy)
		i = encodeVarintCircuit(dAtA, i, uint64(len(m.TrippedBy)))
		i--
		dAtA[i] = 0x22
	}
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.TrippedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.TrippedAt):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintCircuit(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x1a
	if m.Status != 0 {
		i = encodeVarintCircuit(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ModuleName) > 0 {
		i -= len(m.ModuleName)
		copy(dAtA[i:], m.ModuleName)
		i = encodeVarintCircuit(dAtA, i, uint64(len(m.ModuleName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RateLimitConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimitConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimitConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MessageTypes) > 0 {
		for iNdEx := len(m.MessageTypes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MessageTypes[iNdEx])
			copy(dAtA[i:], m.MessageTypes[iNdEx])
			i = encodeVarintCircuit(dAtA, i, uint64(len(m.MessageTypes[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.PerAddress {
		i--
		if m.PerAddress {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.WindowSeconds != 0 {
		i = encodeVarintCircuit(dAtA, i, uint64(m.WindowSeconds))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxRequests != 0 {
		i = encodeVarintCircuit(dAtA, i, uint64(m.MaxRequests))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCircuit(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RateLimitState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimitState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimitState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.WindowStart, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.WindowStart):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintCircuit(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x22
	if m.RequestCount != 0 {
		i = encodeVarintCircuit(dAtA, i, uint64(m.RequestCount))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintCircuit(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ConfigName) > 0 {
		i -= len(m.ConfigName)
		copy(dAtA[i:], m.ConfigName)
		i = encodeVarintCircuit(dAtA, i, uint64(len(m.ConfigName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RateLimits) > 0 {
		for iNdEx := len(m.RateLimits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RateLimits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCircuit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MaxPauseDuration != 0 {
		i = encodeVarintCircuit(dAtA, i, uint64(m.MaxPauseDuration))
		i--
		dAtA[i] = 0x20
	}
	if m.DefaultRecoveryPeriod != 0 {
		i = encodeVarintCircuit(dAtA, i, uint64(m.DefaultRecoveryPeriod))
		i--
		dAtA[i] = 0x18
	}
	if m.DefaultFailureThreshold != 0 {
		i = encodeVarintCircuit(dAtA, i, uint64(m.DefaultFailureThreshold))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authorities) > 0 {
		for iNdEx := len(m.Authorities) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Authorities[iNdEx])
			copy(dAtA[i:], m.Authorities[iNdEx])
			i = encodeVarintCircuit(dAtA, i, uint64(len(m.Authorities[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OracleDeviationConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleDeviationConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleDeviationConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MinUpdateInterval != 0 {
		i = encodeVarintCircuit(dAtA, i, uint64(m.MinUpdateInterval))
		i--
		dAtA[i] = 0x28
	}
	if m.StalenessThreshold != 0 {
		i = encodeVarintCircuit(dAtA, i, uint64(m.StalenessThreshold))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxDailyDeviationBps != 0 {
		i = encodeVarintCircuit(dAtA, i, uint64(m.MaxDailyDeviationBps))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxDeviationBps != 0 {
		i = encodeVarintCircuit(dAtA, i, uint64(m.MaxDeviationBps))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintCircuit(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LiquidationSurgeProtection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidationSurgeProtection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidationSurgeProtection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastResetHeight != 0 {
		i = encodeVarintCircuit(dAtA, i, uint64(m.LastResetHeight))
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.CurrentBlockValue.Size()
		i -= size
		if _, err := m.CurrentBlockValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCircuit(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.CurrentBlockLiquidations != 0 {
		i = encodeVarintCircuit(dAtA, i, uint64(m.CurrentBlockLiquidations))
		i--
		dAtA[i] = 0x20
	}
	if m.CooldownBlocks != 0 {
		i = encodeVarintCircuit(dAtA, i, uint64(m.CooldownBlocks))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.MaxLiquidationValue.Size()
		i -= size
		if _, err := m.MaxLiquidationValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCircuit(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.MaxLiquidationsPerBlock != 0 {
		i = encodeVarintCircuit(dAtA, i, uint64(m.MaxLiquidationsPerBlock))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GenesisState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.LiquidationProtection.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCircuit(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.OracleDeviationConfigs) > 0 {
		for iNdEx := len(m.OracleDeviationConfigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OracleDeviationConfigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCircuit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.RateLimitStates) > 0 {
		for iNdEx := len(m.RateLimitStates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RateLimitStates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCircuit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ModuleCircuits) > 0 {
		for iNdEx := len(m.ModuleCircuits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ModuleCircuits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCircuit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.CircuitState.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCircuit(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCircuit(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintCircuit(dAtA []byte, offset int, v uint64) int {
	offset -= sovCircuit(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CircuitState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GlobalPaused {
		n += 2
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.PausedAt)
	n += 1 + l + sovCircuit(uint64(l))
	l = len(m.PausedBy)
	if l > 0 {
		n += 1 + l + sovCircuit(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCircuit(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.AutoResumeAt)
	n += 1 + l + sovCircuit(uint64(l))
	return n
}

func (m *ModuleCircuitState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ModuleName)
	if l > 0 {
		n += 1 + l + sovCircuit(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovCircuit(uint64(m.Status))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.TrippedAt)
	n += 1 + l + sovCircuit(uint64(l))
	l = len(m.TrippedBy)
	if l > 0 {
		n += 1 + l + sovCircuit(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCircuit(uint64(l))
	}
	if m.FailureCount != 0 {
		n += 1 + sovCircuit(uint64(m.FailureCount))
	}
	if m.FailureThreshold != 0 {
		n += 1 + sovCircuit(uint64(m.FailureThreshold))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.RecoveryTime)
	n += 1 + l + sovCircuit(uint64(l))
	if len(m.DisabledMessages) > 0 {
		for _, s := range m.DisabledMessages {
			l = len(s)
			n += 1 + l + sovCircuit(uint64(l))
		}
	}
	return n
}

func (m *RateLimitConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCircuit(uint64(l))
	}
	if m.MaxRequests != 0 {
		n += 1 + sovCircuit(uint64(m.MaxRequests))
	}
	if m.WindowSeconds != 0 {
		n += 1 + sovCircuit(uint64(m.WindowSeconds))
	}
	if m.PerAddress {
		n += 2
	}
	if m.Enabled {
		n += 2
	}
	if len(m.MessageTypes) > 0 {
		for _, s := range m.MessageTypes {
			l = len(s)
			n += 1 + l + sovCircuit(uint64(l))
		}
	}
	return n
}

func (m *RateLimitState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConfigName)
	if l > 0 {
		n += 1 + l + sovCircuit(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCircuit(uint64(l))
	}
	if m.RequestCount != 0 {
		n += 1 + sovCircuit(uint64(m.RequestCount))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.WindowStart)
	n += 1 + l + sovCircuit(uint64(l))
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Authorities) > 0 {
		for _, s := range m.Authorities {
			l = len(s)
			n += 1 + l + sovCircuit(uint64(l))
		}
	}
	if m.DefaultFailureThreshold != 0 {
		n += 1 + sovCircuit(uint64(m.DefaultFailureThreshold))
	}
	if m.DefaultRecoveryPeriod != 0 {
		n += 1 + sovCircuit(uint64(m.DefaultRecoveryPeriod))
	}
	if m.MaxPauseDuration != 0 {
		n += 1 + sovCircuit(uint64(m.MaxPauseDuration))
	}
	if len(m.RateLimits) > 0 {
		for _, e := range m.RateLimits {
			l = e.Size()
			n += 1 + l + sovCircuit(uint64(l))
		}
	}
	return n
}

func (m *OracleDeviationConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovCircuit(uint64(l))
	}
	if m.MaxDeviationBps != 0 {
		n += 1 + sovCircuit(uint64(m.MaxDeviationBps))
	}
	if m.MaxDailyDeviationBps != 0 {
		n += 1 + sovCircuit(uint64(m.MaxDailyDeviationBps))
	}
	if m.StalenessThreshold != 0 {
		n += 1 + sovCircuit(uint64(m.StalenessThreshold))
	}
	if m.MinUpdateInterval != 0 {
		n += 1 + sovCircuit(uint64(m.MinUpdateInterval))
	}
	return n
}

func (m *LiquidationSurgeProtection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxLiquidationsPerBlock != 0 {
		n += 1 + sovCircuit(uint64(m.MaxLiquidationsPerBlock))
	}
	l = m.MaxLiquidationValue.Size()
	n += 1 + l + sovCircuit(uint64(l))
	if m.CooldownBlocks != 0 {
		n += 1 + sovCircuit(uint64(m.CooldownBlocks))
	}
	if m.CurrentBlockLiquidations != 0 {
		n += 1 + sovCircuit(uint64(m.CurrentBlockLiquidations))
	}
	l = m.CurrentBlockValue.Size()
	n += 1 + l + sovCircuit(uint64(l))
	if m.LastResetHeight != 0 {
		n += 1 + sovCircuit(uint64(m.LastResetHeight))
	}
	return n
}

func (m *GenesisState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Params.Size()
	n += 1 + l + sovCircuit(uint64(l))
	l = m.CircuitState.Size()
	n += 1 + l + sovCircuit(uint64(l))
	if len(m.ModuleCircuits) > 0 {
		for _, e := range m.ModuleCircuits {
			l = e.Size()
			n += 1 + l + sovCircuit(uint64(l))
		}
	}
	if len(m.RateLimitStates) > 0 {
		for _, e := range m.RateLimitStates {
			l = e.Size()
			n += 1 + l + sovCircuit(uint64(l))
		}
	}
	if len(m.OracleDeviationConfigs) > 0 {
		for _, e := range m.OracleDeviationConfigs {
			l = e.Size()
			n += 1 + l + sovCircuit(uint64(l))
		}
	}
	l = m.LiquidationProtection.Size()
	n += 1 + l + sovCircuit(uint64(l))
	return n
}

func sovCircuit(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCircuit(x uint64) (n int) {
	return sovCircuit(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CircuitState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCircuit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CircuitState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CircuitState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalPaused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GlobalPaused = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PausedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.PausedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PausedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PausedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoResumeAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.AutoResumeAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCircuit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCircuit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleCircuitState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCircuit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleCircuitState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleCircuitState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= CircuitStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrippedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.TrippedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrippedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrippedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureCount", wireType)
			}
			m.FailureCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FailureCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureThreshold", wireType)
			}
			m.FailureThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FailureThreshold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.RecoveryTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisabledMessages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisabledMessages = append(m.DisabledMessages, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCircuit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCircuit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimitConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCircuit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RateLimitConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RateLimitConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequests", wireType)
			}
			m.MaxRequests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRequests |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowSeconds", wireType)
			}
			m.WindowSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerAddress", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PerAddress = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageTypes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageTypes = append(m.MessageTypes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCircuit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCircuit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimitState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCircuit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RateLimitState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RateLimitState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestCount", wireType)
			}
			m.RequestCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.WindowStart, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCircuit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCircuit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCircuit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authorities", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authorities = append(m.Authorities, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFailureThreshold", wireType)
			}
			m.DefaultFailureThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultFailureThreshold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultRecoveryPeriod", wireType)
			}
			m.DefaultRecoveryPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultRecoveryPeriod |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPauseDuration", wireType)
			}
			m.MaxPauseDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPauseDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimits = append(m.RateLimits, RateLimitConfig{})
			if err := m.RateLimits[len(m.RateLimits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCircuit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCircuit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleDeviationConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCircuit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleDeviationConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleDeviationConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDeviationBps", wireType)
			}
			m.MaxDeviationBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDeviationBps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDailyDeviationBps", wireType)
			}
			m.MaxDailyDeviationBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDailyDeviationBps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StalenessThreshold", wireType)
			}
			m.StalenessThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StalenessThreshold |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinUpdateInterval", wireType)
			}
			m.MinUpdateInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinUpdateInterval |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCircuit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCircuit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidationSurgeProtection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCircuit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidationSurgeProtection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidationSurgeProtection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLiquidationsPerBlock", wireType)
			}
			m.MaxLiquidationsPerBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLiquidationsPerBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLiquidationValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxLiquidationValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CooldownBlocks", wireType)
			}
			m.CooldownBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CooldownBlocks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentBlockLiquidations", wireType)
			}
			m.CurrentBlockLiquidations = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentBlockLiquidations |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentBlockValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CurrentBlockValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastResetHeight", wireType)
			}
			m.LastResetHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastResetHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCircuit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCircuit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenesisState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCircuit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CircuitState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CircuitState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleCircuits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleCircuits = append(m.ModuleCircuits, ModuleCircuitState{})
			if err := m.ModuleCircuits[len(m.ModuleCircuits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimitStates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimitStates = append(m.RateLimitStates, RateLimitState{})
			if err := m.RateLimitStates[len(m.RateLimitStates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleDeviationConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleDeviationConfigs = append(m.OracleDeviationConfigs, OracleDeviationConfig{})
			if err := m.OracleDeviationConfigs[len(m.OracleDeviationConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidationProtection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCircuit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCircuit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LiquidationProtection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCircuit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCircuit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCircuit(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCircuit
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCircuit
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCircuit
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCircuit
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCircuit
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCircuit        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCircuit          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCircuit = fmt.Errorf("proto: unexpected end of group")
)
