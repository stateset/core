// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: stateset/settlement/settlement.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/types"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "github.com/golang/protobuf/ptypes/duration"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Settlement represents a stablecoin settlement between parties.
type Settlement struct {
	Id            uint64                                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type          SettlementType                          `protobuf:"bytes,2,opt,name=type,proto3,casttype=SettlementType" json:"type,omitempty"`
	Sender        string                                  `protobuf:"bytes,3,opt,name=sender,proto3" json:"sender,omitempty"`
	Recipient     string                                  `protobuf:"bytes,4,opt,name=recipient,proto3" json:"recipient,omitempty"`
	Amount        github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,5,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"amount"`
	Fee           github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,6,opt,name=fee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"fee"`
	NetAmount     github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,7,opt,name=net_amount,json=netAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"net_amount"`
	Status        SettlementStatus                        `protobuf:"bytes,8,opt,name=status,proto3,casttype=SettlementStatus" json:"status,omitempty"`
	Reference     string                                  `protobuf:"bytes,9,opt,name=reference,proto3" json:"reference,omitempty"`
	Metadata      string                                  `protobuf:"bytes,10,opt,name=metadata,proto3" json:"metadata,omitempty"`
	CreatedHeight int64                                   `protobuf:"varint,11,opt,name=created_height,json=createdHeight,proto3" json:"created_height,omitempty"`
	CreatedTime   time.Time                               `protobuf:"bytes,12,opt,name=created_time,json=createdTime,proto3,stdtime" json:"created_time"`
	SettledHeight int64                                   `protobuf:"varint,13,opt,name=settled_height,json=settledHeight,proto3" json:"settled_height,omitempty"`
	SettledTime   time.Time                               `protobuf:"bytes,14,opt,name=settled_time,json=settledTime,proto3,stdtime" json:"settled_time"`
	ExpiresAt     time.Time                               `protobuf:"bytes,15,opt,name=expires_at,json=expiresAt,proto3,stdtime" json:"expires_at"`
	BatchId       uint64                                  `protobuf:"varint,16,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
}

func (m *Settlement) Reset()         { *m = Settlement{} }
func (m *Settlement) String() string { return proto.CompactTextString(m) }
func (*Settlement) ProtoMessage()    {}
func (*Settlement) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6475673dc68b2fe, []int{0}
}
func (m *Settlement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Settlement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Settlement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Settlement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Settlement.Merge(m, src)
}
func (m *Settlement) XXX_Size() int {
	return m.Size()
}
func (m *Settlement) XXX_DiscardUnknown() {
	xxx_messageInfo_Settlement.DiscardUnknown(m)
}

var xxx_messageInfo_Settlement proto.InternalMessageInfo

func (m *Settlement) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Settlement) GetType() SettlementType {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Settlement) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *Settlement) GetRecipient() string {
	if m != nil {
		return m.Recipient
	}
	return ""
}

func (m *Settlement) GetStatus() SettlementStatus {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Settlement) GetReference() string {
	if m != nil {
		return m.Reference
	}
	return ""
}

func (m *Settlement) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Settlement) GetCreatedHeight() int64 {
	if m != nil {
		return m.CreatedHeight
	}
	return 0
}

func (m *Settlement) GetCreatedTime() time.Time {
	if m != nil {
		return m.CreatedTime
	}
	return time.Time{}
}

func (m *Settlement) GetSettledHeight() int64 {
	if m != nil {
		return m.SettledHeight
	}
	return 0
}

func (m *Settlement) GetSettledTime() time.Time {
	if m != nil {
		return m.SettledTime
	}
	return time.Time{}
}

func (m *Settlement) GetExpiresAt() time.Time {
	if m != nil {
		return m.ExpiresAt
	}
	return time.Time{}
}

func (m *Settlement) GetBatchId() uint64 {
	if m != nil {
		return m.BatchId
	}
	return 0
}

// BatchSettlement represents a batch of settlements processed together.
type BatchSettlement struct {
	Id            uint64                                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Merchant      string                                  `protobuf:"bytes,2,opt,name=merchant,proto3" json:"merchant,omitempty"`
	SettlementIds []uint64                                `protobuf:"varint,3,rep,packed,name=settlement_ids,json=settlementIds,proto3" json:"settlement_ids,omitempty"`
	TotalAmount   github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,4,opt,name=total_amount,json=totalAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"total_amount"`
	TotalFees     github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,5,opt,name=total_fees,json=totalFees,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"total_fees"`
	NetAmount     github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,6,opt,name=net_amount,json=netAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"net_amount"`
	Count         uint64                                  `protobuf:"varint,7,opt,name=count,proto3" json:"count,omitempty"`
	Status        SettlementStatus                        `protobuf:"bytes,8,opt,name=status,proto3,casttype=SettlementStatus" json:"status,omitempty"`
	CreatedHeight int64                                   `protobuf:"varint,9,opt,name=created_height,json=createdHeight,proto3" json:"created_height,omitempty"`
	CreatedTime   time.Time                               `protobuf:"bytes,10,opt,name=created_time,json=createdTime,proto3,stdtime" json:"created_time"`
	SettledHeight int64                                   `protobuf:"varint,11,opt,name=settled_height,json=settledHeight,proto3" json:"settled_height,omitempty"`
	SettledTime   time.Time                               `protobuf:"bytes,12,opt,name=settled_time,json=settledTime,proto3,stdtime" json:"settled_time"`
}

func (m *BatchSettlement) Reset()         { *m = BatchSettlement{} }
func (m *BatchSettlement) String() string { return proto.CompactTextString(m) }
func (*BatchSettlement) ProtoMessage()    {}
func (*BatchSettlement) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6475673dc68b2fe, []int{1}
}
func (m *BatchSettlement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSettlement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSettlement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSettlement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSettlement.Merge(m, src)
}
func (m *BatchSettlement) XXX_Size() int {
	return m.Size()
}
func (m *BatchSettlement) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSettlement.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSettlement proto.InternalMessageInfo

func (m *BatchSettlement) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BatchSettlement) GetMerchant() string {
	if m != nil {
		return m.Merchant
	}
	return ""
}

func (m *BatchSettlement) GetSettlementIds() []uint64 {
	if m != nil {
		return m.SettlementIds
	}
	return nil
}

func (m *BatchSettlement) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *BatchSettlement) GetStatus() SettlementStatus {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *BatchSettlement) GetCreatedHeight() int64 {
	if m != nil {
		return m.CreatedHeight
	}
	return 0
}

func (m *BatchSettlement) GetCreatedTime() time.Time {
	if m != nil {
		return m.CreatedTime
	}
	return time.Time{}
}

func (m *BatchSettlement) GetSettledHeight() int64 {
	if m != nil {
		return m.SettledHeight
	}
	return 0
}

func (m *BatchSettlement) GetSettledTime() time.Time {
	if m != nil {
		return m.SettledTime
	}
	return time.Time{}
}

// PaymentChannel represents a payment channel for streaming payments.
type PaymentChannel struct {
	Id              uint64                                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Sender          string                                  `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty"`
	Recipient       string                                  `protobuf:"bytes,3,opt,name=recipient,proto3" json:"recipient,omitempty"`
	Deposit         github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,4,opt,name=deposit,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"deposit"`
	Spent           github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,5,opt,name=spent,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"spent"`
	Balance         github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,6,opt,name=balance,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"balance"`
	IsOpen          bool                                    `protobuf:"varint,7,opt,name=is_open,json=isOpen,proto3" json:"is_open,omitempty"`
	OpenedHeight    int64                                   `protobuf:"varint,8,opt,name=opened_height,json=openedHeight,proto3" json:"opened_height,omitempty"`
	OpenedTime      time.Time                               `protobuf:"bytes,9,opt,name=opened_time,json=openedTime,proto3,stdtime" json:"opened_time"`
	ClosedHeight    int64                                   `protobuf:"varint,10,opt,name=closed_height,json=closedHeight,proto3" json:"closed_height,omitempty"`
	ClosedTime      time.Time                               `protobuf:"bytes,11,opt,name=closed_time,json=closedTime,proto3,stdtime" json:"closed_time"`
	ExpiresAtHeight int64                                   `protobuf:"varint,12,opt,name=expires_at_height,json=expiresAtHeight,proto3" json:"expires_at_height,omitempty"`
	Nonce           uint64                                  `protobuf:"varint,13,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *PaymentChannel) Reset()         { *m = PaymentChannel{} }
func (m *PaymentChannel) String() string { return proto.CompactTextString(m) }
func (*PaymentChannel) ProtoMessage()    {}
func (*PaymentChannel) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6475673dc68b2fe, []int{2}
}
func (m *PaymentChannel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PaymentChannel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PaymentChannel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PaymentChannel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaymentChannel.Merge(m, src)
}
func (m *PaymentChannel) XXX_Size() int {
	return m.Size()
}
func (m *PaymentChannel) XXX_DiscardUnknown() {
	xxx_messageInfo_PaymentChannel.DiscardUnknown(m)
}

var xxx_messageInfo_PaymentChannel proto.InternalMessageInfo

func (m *PaymentChannel) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *PaymentChannel) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *PaymentChannel) GetRecipient() string {
	if m != nil {
		return m.Recipient
	}
	return ""
}

func (m *PaymentChannel) GetIsOpen() bool {
	if m != nil {
		return m.IsOpen
	}
	return false
}

func (m *PaymentChannel) GetOpenedHeight() int64 {
	if m != nil {
		return m.OpenedHeight
	}
	return 0
}

func (m *PaymentChannel) GetOpenedTime() time.Time {
	if m != nil {
		return m.OpenedTime
	}
	return time.Time{}
}

func (m *PaymentChannel) GetClosedHeight() int64 {
	if m != nil {
		return m.ClosedHeight
	}
	return 0
}

func (m *PaymentChannel) GetClosedTime() time.Time {
	if m != nil {
		return m.ClosedTime
	}
	return time.Time{}
}

func (m *PaymentChannel) GetExpiresAtHeight() int64 {
	if m != nil {
		return m.ExpiresAtHeight
	}
	return 0
}

func (m *PaymentChannel) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

// MerchantConfig represents merchant-specific configuration.
type MerchantConfig struct {
	Address         string                                  `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Name            string                                  `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	FeeRateBps      uint32                                  `protobuf:"varint,3,opt,name=fee_rate_bps,json=feeRateBps,proto3" json:"fee_rate_bps,omitempty"`
	MinSettlement   github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,4,opt,name=min_settlement,json=minSettlement,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"min_settlement"`
	MaxSettlement   github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,5,opt,name=max_settlement,json=maxSettlement,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"max_settlement"`
	BatchEnabled    bool                                    `protobuf:"varint,6,opt,name=batch_enabled,json=batchEnabled,proto3" json:"batch_enabled,omitempty"`
	BatchThreshold  github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,7,opt,name=batch_threshold,json=batchThreshold,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"batch_threshold"`
	SettlementDelay time.Duration                           `protobuf:"bytes,8,opt,name=settlement_delay,json=settlementDelay,proto3,stdduration" json:"settlement_delay"`
	IsActive        bool                                    `protobuf:"varint,9,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
	WebhookUrl      string                                  `protobuf:"bytes,10,opt,name=webhook_url,json=webhookUrl,proto3" json:"webhook_url,omitempty"`
	RegisteredAt    time.Time                               `protobuf:"bytes,11,opt,name=registered_at,json=registeredAt,proto3,stdtime" json:"registered_at"`
}

func (m *MerchantConfig) Reset()         { *m = MerchantConfig{} }
func (m *MerchantConfig) String() string { return proto.CompactTextString(m) }
func (*MerchantConfig) ProtoMessage()    {}
func (*MerchantConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6475673dc68b2fe, []int{3}
}
func (m *MerchantConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MerchantConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MerchantConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MerchantConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MerchantConfig.Merge(m, src)
}
func (m *MerchantConfig) XXX_Size() int {
	return m.Size()
}
func (m *MerchantConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MerchantConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MerchantConfig proto.InternalMessageInfo

func (m *MerchantConfig) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *MerchantConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MerchantConfig) GetFeeRateBps() uint32 {
	if m != nil {
		return m.FeeRateBps
	}
	return 0
}

func (m *MerchantConfig) GetBatchEnabled() bool {
	if m != nil {
		return m.BatchEnabled
	}
	return false
}

func (m *MerchantConfig) GetSettlementDelay() time.Duration {
	if m != nil {
		return m.SettlementDelay
	}
	return 0
}

func (m *MerchantConfig) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

func (m *MerchantConfig) GetWebhookUrl() string {
	if m != nil {
		return m.WebhookUrl
	}
	return ""
}

func (m *MerchantConfig) GetRegisteredAt() time.Time {
	if m != nil {
		return m.RegisteredAt
	}
	return time.Time{}
}

// CheckoutItem represents an item in a checkout.
type CheckoutItem struct {
	ProductId   string                                  `protobuf:"bytes,1,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	Quantity    uint64                                  `protobuf:"varint,2,opt,name=quantity,proto3" json:"quantity,omitempty"`
	UnitPrice   github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,3,opt,name=unit_price,json=unitPrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"unit_price"`
	Description string                                  `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *CheckoutItem) Reset()         { *m = CheckoutItem{} }
func (m *CheckoutItem) String() string { return proto.CompactTextString(m) }
func (*CheckoutItem) ProtoMessage()    {}
func (*CheckoutItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6475673dc68b2fe, []int{4}
}
func (m *CheckoutItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckoutItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckoutItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckoutItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckoutItem.Merge(m, src)
}
func (m *CheckoutItem) XXX_Size() int {
	return m.Size()
}
func (m *CheckoutItem) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckoutItem.DiscardUnknown(m)
}

var xxx_messageInfo_CheckoutItem proto.InternalMessageInfo

func (m *CheckoutItem) GetProductId() string {
	if m != nil {
		return m.ProductId
	}
	return ""
}

func (m *CheckoutItem) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *CheckoutItem) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// TransferReceipt represents the receipt of a transfer.
type TransferReceipt struct {
	SettlementId uint64                                  `protobuf:"varint,1,opt,name=settlement_id,json=settlementId,proto3" json:"settlement_id,omitempty"`
	TxHash       string                                  `protobuf:"bytes,2,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	BlockHeight  int64                                   `protobuf:"varint,3,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	Timestamp    time.Time                               `protobuf:"bytes,4,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	Sender       string                                  `protobuf:"bytes,5,opt,name=sender,proto3" json:"sender,omitempty"`
	Recipient    string                                  `protobuf:"bytes,6,opt,name=recipient,proto3" json:"recipient,omitempty"`
	Amount       github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,7,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"amount"`
	Fee          github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,8,opt,name=fee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"fee"`
	Reference    string                                  `protobuf:"bytes,9,opt,name=reference,proto3" json:"reference,omitempty"`
}

func (m *TransferReceipt) Reset()         { *m = TransferReceipt{} }
func (m *TransferReceipt) String() string { return proto.CompactTextString(m) }
func (*TransferReceipt) ProtoMessage()    {}
func (*TransferReceipt) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6475673dc68b2fe, []int{5}
}
func (m *TransferReceipt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferReceipt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferReceipt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferReceipt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferReceipt.Merge(m, src)
}
func (m *TransferReceipt) XXX_Size() int {
	return m.Size()
}
func (m *TransferReceipt) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferReceipt.DiscardUnknown(m)
}

var xxx_messageInfo_TransferReceipt proto.InternalMessageInfo

func (m *TransferReceipt) GetSettlementId() uint64 {
	if m != nil {
		return m.SettlementId
	}
	return 0
}

func (m *TransferReceipt) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *TransferReceipt) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *TransferReceipt) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *TransferReceipt) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *TransferReceipt) GetRecipient() string {
	if m != nil {
		return m.Recipient
	}
	return ""
}

func (m *TransferReceipt) GetReference() string {
	if m != nil {
		return m.Reference
	}
	return ""
}

// Params defines the parameters for the settlement module.
type Params struct {
	DefaultFeeRateBps       uint32                                  `protobuf:"varint,1,opt,name=default_fee_rate_bps,json=defaultFeeRateBps,proto3" json:"default_fee_rate_bps,omitempty"`
	FeeCollector            string                                  `protobuf:"bytes,2,opt,name=fee_collector,json=feeCollector,proto3" json:"fee_collector,omitempty"`
	MinSettlementAmount     github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,3,opt,name=min_settlement_amount,json=minSettlementAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"min_settlement_amount"`
	MaxSettlementAmount     github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,4,opt,name=max_settlement_amount,json=maxSettlementAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"max_settlement_amount"`
	DefaultEscrowExpiration int64                                   `protobuf:"varint,5,opt,name=default_escrow_expiration,json=defaultEscrowExpiration,proto3" json:"default_escrow_expiration,omitempty"`
	MaxEscrowExpiration     int64                                   `protobuf:"varint,6,opt,name=max_escrow_expiration,json=maxEscrowExpiration,proto3" json:"max_escrow_expiration,omitempty"`
	MinChannelExpiration    int64                                   `protobuf:"varint,7,opt,name=min_channel_expiration,json=minChannelExpiration,proto3" json:"min_channel_expiration,omitempty"`
	MaxChannelExpiration    int64                                   `protobuf:"varint,8,opt,name=max_channel_expiration,json=maxChannelExpiration,proto3" json:"max_channel_expiration,omitempty"`
	MaxBatchSize            uint32                                  `protobuf:"varint,9,opt,name=max_batch_size,json=maxBatchSize,proto3" json:"max_batch_size,omitempty"`
	MaxQueryLimit           uint32                                  `protobuf:"varint,10,opt,name=max_query_limit,json=maxQueryLimit,proto3" json:"max_query_limit,omitempty"`
	InstantTransfersEnabled bool                                    `protobuf:"varint,11,opt,name=instant_transfers_enabled,json=instantTransfersEnabled,proto3" json:"instant_transfers_enabled,omitempty"`
	EscrowEnabled           bool                                    `protobuf:"varint,12,opt,name=escrow_enabled,json=escrowEnabled,proto3" json:"escrow_enabled,omitempty"`
	ChannelsEnabled         bool                                    `protobuf:"varint,13,opt,name=channels_enabled,json=channelsEnabled,proto3" json:"channels_enabled,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6475673dc68b2fe, []int{6}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetDefaultFeeRateBps() uint32 {
	if m != nil {
		return m.DefaultFeeRateBps
	}
	return 0
}

func (m *Params) GetFeeCollector() string {
	if m != nil {
		return m.FeeCollector
	}
	return ""
}

func (m *Params) GetDefaultEscrowExpiration() int64 {
	if m != nil {
		return m.DefaultEscrowExpiration
	}
	return 0
}

func (m *Params) GetMaxEscrowExpiration() int64 {
	if m != nil {
		return m.MaxEscrowExpiration
	}
	return 0
}

func (m *Params) GetMinChannelExpiration() int64 {
	if m != nil {
		return m.MinChannelExpiration
	}
	return 0
}

func (m *Params) GetMaxChannelExpiration() int64 {
	if m != nil {
		return m.MaxChannelExpiration
	}
	return 0
}

func (m *Params) GetMaxBatchSize() uint32 {
	if m != nil {
		return m.MaxBatchSize
	}
	return 0
}

func (m *Params) GetMaxQueryLimit() uint32 {
	if m != nil {
		return m.MaxQueryLimit
	}
	return 0
}

func (m *Params) GetInstantTransfersEnabled() bool {
	if m != nil {
		return m.InstantTransfersEnabled
	}
	return false
}

func (m *Params) GetEscrowEnabled() bool {
	if m != nil {
		return m.EscrowEnabled
	}
	return false
}

func (m *Params) GetChannelsEnabled() bool {
	if m != nil {
		return m.ChannelsEnabled
	}
	return false
}

// GenesisState defines the settlement module's genesis state.
type GenesisState struct {
	Params           Params            `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
	Settlements      []Settlement      `protobuf:"bytes,2,rep,name=settlements,proto3" json:"settlements"`
	Batches          []BatchSettlement `protobuf:"bytes,3,rep,name=batches,proto3" json:"batches"`
	Channels         []PaymentChannel  `protobuf:"bytes,4,rep,name=channels,proto3" json:"channels"`
	Merchants        []MerchantConfig  `protobuf:"bytes,5,rep,name=merchants,proto3" json:"merchants"`
	NextSettlementId uint64            `protobuf:"varint,6,opt,name=next_settlement_id,json=nextSettlementId,proto3" json:"next_settlement_id,omitempty"`
	NextBatchId      uint64            `protobuf:"varint,7,opt,name=next_batch_id,json=nextBatchId,proto3" json:"next_batch_id,omitempty"`
	NextChannelId    uint64            `protobuf:"varint,8,opt,name=next_channel_id,json=nextChannelId,proto3" json:"next_channel_id,omitempty"`
}

func (m *GenesisState) Reset()         { *m = GenesisState{} }
func (m *GenesisState) String() string { return proto.CompactTextString(m) }
func (*GenesisState) ProtoMessage()    {}
func (*GenesisState) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6475673dc68b2fe, []int{7}
}
func (m *GenesisState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisState.Merge(m, src)
}
func (m *GenesisState) XXX_Size() int {
	return m.Size()
}
func (m *GenesisState) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisState.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisState proto.InternalMessageInfo

func (m *GenesisState) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

func (m *GenesisState) GetSettlements() []Settlement {
	if m != nil {
		return m.Settlements
	}
	return nil
}

func (m *GenesisState) GetBatches() []BatchSettlement {
	if m != nil {
		return m.Batches
	}
	return nil
}

func (m *GenesisState) GetChannels() []PaymentChannel {
	if m != nil {
		return m.Channels
	}
	return nil
}

func (m *GenesisState) GetMerchants() []MerchantConfig {
	if m != nil {
		return m.Merchants
	}
	return nil
}

func (m *GenesisState) GetNextSettlementId() uint64 {
	if m != nil {
		return m.NextSettlementId
	}
	return 0
}

func (m *GenesisState) GetNextBatchId() uint64 {
	if m != nil {
		return m.NextBatchId
	}
	return 0
}

func (m *GenesisState) GetNextChannelId() uint64 {
	if m != nil {
		return m.NextChannelId
	}
	return 0
}

func init() {
	proto.RegisterType((*Settlement)(nil), "stateset.settlement.Settlement")
	proto.RegisterType((*BatchSettlement)(nil), "stateset.settlement.BatchSettlement")
	proto.RegisterType((*PaymentChannel)(nil), "stateset.settlement.PaymentChannel")
	proto.RegisterType((*MerchantConfig)(nil), "stateset.settlement.MerchantConfig")
	proto.RegisterType((*CheckoutItem)(nil), "stateset.settlement.CheckoutItem")
	proto.RegisterType((*TransferReceipt)(nil), "stateset.settlement.TransferReceipt")
	proto.RegisterType((*Params)(nil), "stateset.settlement.Params")
	proto.RegisterType((*GenesisState)(nil), "stateset.settlement.GenesisState")
}

func init() {
	proto.RegisterFile("stateset/settlement/settlement.proto", fileDescriptor_d6475673dc68b2fe)
}

var fileDescriptor_d6475673dc68b2fe = []byte{
	// 1606 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xcb, 0x72, 0x1b, 0x59,
	0x19, 0xb6, 0xac, 0x8b, 0xa5, 0xbf, 0x75, 0xf1, 0x9c, 0x98, 0x49, 0xc7, 0x03, 0x96, 0x90, 0x33,
	0x83, 0x81, 0x41, 0xaa, 0x31, 0x6c, 0x60, 0x67, 0x39, 0x1e, 0x8f, 0xab, 0xb8, 0x84, 0x8e, 0xd9,
	0x50, 0x54, 0x35, 0x47, 0xdd, 0xbf, 0xa4, 0x53, 0xee, 0x5b, 0xfa, 0x1c, 0x25, 0x72, 0x16, 0x3c,
	0x43, 0x56, 0x14, 0x6f, 0x42, 0xf1, 0x06, 0x59, 0x40, 0x91, 0x15, 0x45, 0xb1, 0x30, 0x94, 0xf3,
	0x16, 0x59, 0x51, 0xe7, 0xd2, 0x6a, 0xc9, 0x97, 0x54, 0x3c, 0x65, 0xad, 0xac, 0xf3, 0xdf, 0x3e,
	0x9f, 0xa3, 0xef, 0xbf, 0x09, 0x1e, 0x73, 0x41, 0x05, 0x72, 0x14, 0x7d, 0x8e, 0x42, 0x04, 0x18,
	0x62, 0xb4, 0xf8, 0xb1, 0x97, 0xa4, 0xb1, 0x88, 0xc9, 0x83, 0xcc, 0xaa, 0x97, 0xab, 0xb6, 0xb7,
	0xc6, 0xf1, 0x38, 0x56, 0xfa, 0xbe, 0xfc, 0xa4, 0x4d, 0xb7, 0x77, 0xbc, 0x98, 0x87, 0x31, 0xef,
	0x0f, 0x29, 0xc7, 0xfe, 0x8b, 0xaf, 0x86, 0x28, 0xe8, 0x57, 0x7d, 0x2f, 0x66, 0x51, 0xa6, 0x1f,
	0xc7, 0xf1, 0x38, 0xc0, 0xbe, 0x3a, 0x0d, 0xa7, 0xa3, 0xbe, 0x3f, 0x4d, 0xa9, 0x60, 0x71, 0xa6,
	0x6f, 0x5f, 0xd5, 0x0b, 0x16, 0x22, 0x17, 0x34, 0x4c, 0xb4, 0x41, 0xf7, 0x9f, 0x15, 0x80, 0x67,
	0xf3, 0xff, 0x82, 0x34, 0x61, 0x9d, 0xf9, 0x76, 0xa1, 0x53, 0xd8, 0x2b, 0x39, 0xeb, 0xcc, 0x27,
	0x5f, 0x40, 0x49, 0x9c, 0x27, 0x68, 0xaf, 0x77, 0x0a, 0x7b, 0xb5, 0x01, 0x79, 0x7f, 0xd1, 0x6e,
	0xe6, 0xd6, 0xa7, 0xe7, 0x09, 0x3a, 0x4a, 0x4f, 0x3e, 0x85, 0x0a, 0xc7, 0xc8, 0xc7, 0xd4, 0x2e,
	0x4a, 0x4b, 0xc7, 0x9c, 0xc8, 0x77, 0xa1, 0x96, 0xa2, 0xc7, 0x12, 0x86, 0x91, 0xb0, 0x4b, 0x4a,
	0x95, 0x0b, 0xc8, 0x10, 0x2a, 0x34, 0x8c, 0xa7, 0x91, 0xb0, 0xcb, 0x9d, 0xc2, 0x9e, 0xb5, 0xff,
	0xa8, 0xa7, 0xaf, 0xdb, 0x93, 0xd7, 0xed, 0x99, 0xeb, 0xf6, 0x0e, 0x63, 0x16, 0x0d, 0xfa, 0x6f,
	0x2e, 0xda, 0x6b, 0xff, 0xb9, 0x68, 0xff, 0x60, 0xcc, 0xc4, 0x64, 0x3a, 0xec, 0x79, 0x71, 0xd8,
	0x37, 0x6f, 0xa3, 0xff, 0xfc, 0x84, 0xfb, 0x67, 0x7d, 0xf9, 0xbf, 0x70, 0xe5, 0xe0, 0x98, 0xc8,
	0xe4, 0x0f, 0x50, 0x1c, 0x21, 0xda, 0x95, 0x7b, 0x07, 0x90, 0x61, 0x09, 0x03, 0x88, 0x50, 0xb8,
	0xe6, 0x16, 0x1b, 0xf7, 0x0e, 0x52, 0x8b, 0x50, 0x1c, 0xe8, 0x8b, 0x7c, 0x09, 0x15, 0xc9, 0x9b,
	0x29, 0xb7, 0xab, 0xea, 0xcb, 0xd8, 0x7a, 0x7f, 0xd1, 0xde, 0xcc, 0xbf, 0x8c, 0x67, 0x4a, 0xe7,
	0x18, 0x1b, 0xfd, 0xf0, 0x23, 0x4c, 0x31, 0xf2, 0xd0, 0xae, 0x65, 0x0f, 0x6f, 0x04, 0x64, 0x1b,
	0xaa, 0x21, 0x0a, 0xea, 0x53, 0x41, 0x6d, 0x50, 0xca, 0xf9, 0x99, 0x7c, 0x0e, 0x4d, 0x2f, 0x45,
	0x2a, 0xd0, 0x77, 0x27, 0xc8, 0xc6, 0x13, 0x61, 0x5b, 0x9d, 0xc2, 0x5e, 0xd1, 0x69, 0x18, 0xe9,
	0x37, 0x4a, 0x48, 0x8e, 0xa1, 0x9e, 0x99, 0x49, 0x4e, 0xd9, 0x75, 0x75, 0xf7, 0xed, 0x9e, 0x26,
	0x5c, 0x2f, 0x23, 0x5c, 0xef, 0x34, 0x23, 0xdc, 0xa0, 0x2a, 0x2f, 0xff, 0xfa, 0xbf, 0xed, 0x82,
	0x63, 0x19, 0x4f, 0xa9, 0x93, 0x78, 0x3a, 0x0d, 0xe6, 0x78, 0x0d, 0x8d, 0x67, 0xa4, 0x39, 0x5e,
	0x66, 0xa6, 0xf0, 0x9a, 0x77, 0xc1, 0x33, 0x9e, 0x0a, 0xef, 0x10, 0x00, 0x67, 0x09, 0x4b, 0x91,
	0xbb, 0x54, 0xd8, 0xad, 0x3b, 0x84, 0xa9, 0x19, 0xbf, 0x03, 0x41, 0x1e, 0x41, 0x75, 0x48, 0x85,
	0x37, 0x71, 0x99, 0x6f, 0x6f, 0xaa, 0x6c, 0xd9, 0x50, 0xe7, 0x13, 0xbf, 0xfb, 0x8f, 0x32, 0xb4,
	0x06, 0xf2, 0xf3, 0x07, 0xd2, 0x4a, 0xbd, 0x7f, 0xea, 0x4d, 0x68, 0x24, 0x74, 0x6a, 0x39, 0xf3,
	0x73, 0xfe, 0x1e, 0xd2, 0xd3, 0x65, 0x3e, 0xb7, 0x8b, 0x9d, 0xe2, 0x5e, 0x29, 0x7b, 0x0f, 0x29,
	0x3d, 0xf1, 0x39, 0x09, 0xa1, 0x2e, 0x62, 0x41, 0x83, 0x8c, 0x7b, 0xa5, 0x7b, 0xe7, 0x9e, 0xa5,
	0xe2, 0x1b, 0xf6, 0x31, 0x00, 0x0d, 0x37, 0x42, 0xe4, 0x2b, 0x48, 0xd7, 0x9a, 0x8a, 0xfe, 0x35,
	0x22, 0xbf, 0x92, 0x53, 0x95, 0x55, 0xe6, 0xd4, 0x16, 0x94, 0xbd, 0x79, 0xe6, 0x96, 0x1c, 0x7d,
	0xb8, 0x63, 0xa6, 0x5d, 0xcf, 0x97, 0xda, 0xc7, 0xe4, 0x0b, 0xdc, 0x5f, 0xbe, 0x58, 0x1f, 0x93,
	0x2f, 0xf5, 0x6f, 0x99, 0x2f, 0xdd, 0xbf, 0x96, 0xa1, 0xf9, 0x94, 0x9e, 0xcb, 0x9b, 0x1f, 0x4e,
	0x68, 0x14, 0x61, 0x70, 0x8d, 0xce, 0x79, 0xf5, 0x5f, 0xbf, 0xbd, 0xfa, 0x17, 0xaf, 0x56, 0x7f,
	0x1f, 0x36, 0x7c, 0x4c, 0x62, 0xce, 0x56, 0x41, 0xde, 0x2c, 0x34, 0xf9, 0x23, 0x94, 0x79, 0x82,
	0x2b, 0x69, 0x31, 0x3a, 0xb0, 0xbc, 0xc7, 0x90, 0x06, 0x54, 0x16, 0xda, 0xfb, 0x27, 0x6b, 0x16,
	0x9a, 0x3c, 0x84, 0x0d, 0xc6, 0xdd, 0x38, 0xc1, 0x48, 0x91, 0xb5, 0xea, 0x54, 0x18, 0xff, 0x4d,
	0x82, 0x11, 0xd9, 0x85, 0x86, 0x94, 0xe6, 0x74, 0xa8, 0x2a, 0x3a, 0xd4, 0xb5, 0xd0, 0xb0, 0xe1,
	0x08, 0x2c, 0x63, 0xa4, 0xc8, 0x50, 0xbb, 0x03, 0x19, 0x40, 0x3b, 0x2a, 0xee, 0xed, 0x42, 0xc3,
	0x0b, 0x62, 0x9e, 0x63, 0x81, 0xc6, 0xd2, 0xc2, 0x1c, 0xcb, 0x18, 0x29, 0x2c, 0xeb, 0x2e, 0x58,
	0xda, 0x51, 0x61, 0xfd, 0x08, 0x3e, 0xc9, 0xeb, 0x74, 0x86, 0x57, 0x57, 0x78, 0xad, 0x79, 0x21,
	0x36, 0x90, 0x5b, 0x50, 0x8e, 0x62, 0xf9, 0x05, 0x34, 0x74, 0x1e, 0xab, 0x43, 0xf7, 0x6f, 0x65,
	0x68, 0xfe, 0xca, 0x94, 0xd5, 0xc3, 0x38, 0x1a, 0xb1, 0x31, 0xb1, 0x61, 0x83, 0xfa, 0x7e, 0x8a,
	0x9c, 0x2b, 0xfa, 0xd6, 0x9c, 0xec, 0x48, 0x08, 0x94, 0x22, 0x1a, 0x9a, 0x49, 0xc7, 0x51, 0x9f,
	0x49, 0x07, 0xea, 0x23, 0x44, 0x37, 0xa5, 0x02, 0xdd, 0x61, 0xc2, 0x15, 0x85, 0x1b, 0x0e, 0x8c,
	0x10, 0x1d, 0x2a, 0x70, 0x90, 0x70, 0xf2, 0x1c, 0x9a, 0x21, 0x8b, 0xdc, 0xbc, 0x34, 0xaf, 0x80,
	0xca, 0x8d, 0x90, 0x45, 0x0b, 0xbd, 0x44, 0x42, 0xd2, 0xd9, 0x22, 0x64, 0x79, 0x05, 0x90, 0x74,
	0xb6, 0x00, 0xb9, 0x0b, 0x0d, 0xdd, 0xed, 0x30, 0xa2, 0xc3, 0x00, 0x7d, 0xc5, 0xf3, 0xaa, 0x53,
	0x57, 0xc2, 0x23, 0x2d, 0x23, 0x1c, 0x5a, 0xda, 0x48, 0x4c, 0x52, 0xe4, 0x93, 0x38, 0xf0, 0x57,
	0x30, 0x0f, 0x35, 0x15, 0xc4, 0x69, 0x86, 0x40, 0x7e, 0x0d, 0x9b, 0x0b, 0xcd, 0xd2, 0xc7, 0x80,
	0x9e, 0x2b, 0xfe, 0x4b, 0xd4, 0xab, 0x84, 0x7b, 0x62, 0x46, 0x63, 0xcd, 0xb7, 0xbf, 0x48, 0xbe,
	0xb5, 0x72, 0xe7, 0x27, 0xd2, 0x97, 0x7c, 0x06, 0x35, 0xc6, 0x5d, 0xea, 0x09, 0xf6, 0x42, 0x67,
	0x49, 0xd5, 0xa9, 0x32, 0x7e, 0xa0, 0xce, 0xa4, 0x0d, 0xd6, 0x4b, 0x1c, 0x4e, 0xe2, 0xf8, 0xcc,
	0x9d, 0xa6, 0x81, 0x19, 0x9c, 0xc0, 0x88, 0x7e, 0x97, 0x06, 0xe4, 0x04, 0x1a, 0x29, 0x8e, 0x19,
	0x17, 0x98, 0xa2, 0x2f, 0xa7, 0x8b, 0xbb, 0x70, 0xbf, 0x9e, 0xbb, 0x1e, 0x88, 0xee, 0xbf, 0x0a,
	0x50, 0x3f, 0x9c, 0xa0, 0x77, 0x16, 0x4f, 0xc5, 0x89, 0xc0, 0x90, 0x7c, 0x0f, 0x20, 0x49, 0x63,
	0x7f, 0xea, 0xc9, 0x99, 0xc0, 0x90, 0xb7, 0x66, 0x24, 0x27, 0x6a, 0xa2, 0x78, 0x3e, 0xa5, 0x91,
	0x60, 0xe2, 0x5c, 0x51, 0xb8, 0xe4, 0xcc, 0xcf, 0xb2, 0xa1, 0x4e, 0x23, 0x26, 0xdc, 0x24, 0x65,
	0x1e, 0x2a, 0x12, 0xdf, 0x73, 0x43, 0x95, 0xd1, 0x9f, 0xca, 0xe0, 0xa4, 0x03, 0x96, 0x8f, 0xdc,
	0x4b, 0x59, 0x22, 0x5f, 0xda, 0x4c, 0xfc, 0x8b, 0xa2, 0xee, 0xdf, 0x8b, 0xd0, 0x3a, 0x4d, 0x69,
	0xc4, 0x47, 0x98, 0x3a, 0xe8, 0x21, 0x4b, 0x14, 0xbf, 0x96, 0x46, 0x1e, 0xd3, 0x5a, 0xea, 0x8b,
	0x13, 0x8f, 0x2c, 0x80, 0x62, 0xe6, 0x4e, 0x28, 0x9f, 0x64, 0x5d, 0x46, 0xcc, 0xbe, 0xa1, 0x7c,
	0x42, 0xbe, 0x0f, 0xf5, 0x61, 0x10, 0x7b, 0x67, 0x59, 0x8d, 0x28, 0xaa, 0x1a, 0x61, 0x29, 0x99,
	0xa9, 0x0f, 0x03, 0xa8, 0xcd, 0x17, 0x1f, 0x93, 0xa1, 0x1f, 0x39, 0xf2, 0xcd, 0xdd, 0x16, 0x9a,
	0x5c, 0xf9, 0xf6, 0x26, 0x57, 0xb9, 0x7d, 0xc5, 0xd9, 0x58, 0xf5, 0x8a, 0x53, 0x5d, 0xcd, 0x8a,
	0xf3, 0xc1, 0x4d, 0xa2, 0xfb, 0xe7, 0x0a, 0x54, 0x9e, 0xd2, 0x94, 0x86, 0x9c, 0xf4, 0x61, 0xcb,
	0xc7, 0x11, 0x9d, 0x06, 0xc2, 0x5d, 0xaa, 0x9a, 0x05, 0x55, 0x35, 0x3f, 0x31, 0xba, 0xaf, 0xf3,
	0xe2, 0xb9, 0x0b, 0x0d, 0x69, 0xe8, 0xc5, 0x41, 0x80, 0x9e, 0x88, 0xb3, 0xe9, 0x41, 0xd6, 0xdc,
	0xc3, 0x4c, 0x46, 0xfe, 0x04, 0xdf, 0x59, 0xae, 0xb0, 0xd9, 0x60, 0x78, 0xff, 0x3c, 0x7e, 0xb0,
	0x54, 0x68, 0xcd, 0x88, 0x28, 0xf1, 0x97, 0xca, 0xed, 0xea, 0x06, 0xee, 0x07, 0x4b, 0x55, 0xd7,
	0xe0, 0xff, 0x02, 0x1e, 0x65, 0xaf, 0x2a, 0xb3, 0x28, 0x7e, 0xe9, 0xaa, 0xe6, 0xa7, 0x2a, 0x99,
	0x62, 0x62, 0xd1, 0x79, 0x68, 0x0c, 0x8e, 0x94, 0xfe, 0x68, 0xae, 0x26, 0xfb, 0xfa, 0x7f, 0xbf,
	0xee, 0x57, 0x51, 0x7e, 0x12, 0xef, 0x9a, 0xcf, 0xcf, 0xe0, 0x53, 0xf9, 0xde, 0x9e, 0x1e, 0xf5,
	0x16, 0x9d, 0x36, 0x94, 0xd3, 0x56, 0xc8, 0x22, 0x33, 0x07, 0x5e, 0xf1, 0xa2, 0xb3, 0x9b, 0xbc,
	0xaa, 0xc6, 0x8b, 0xce, 0xae, 0x7b, 0x3d, 0xd6, 0xad, 0x4c, 0xb7, 0x0d, 0xce, 0x5e, 0x69, 0x7e,
	0x35, 0x9c, 0x7a, 0x48, 0x67, 0x7a, 0x85, 0x62, 0xaf, 0x90, 0x7c, 0x01, 0x2d, 0x69, 0xf5, 0x7c,
	0x8a, 0xe9, 0xb9, 0x1b, 0xb0, 0x90, 0xe9, 0xb1, 0xa3, 0xa1, 0xba, 0xd4, 0x6f, 0xa5, 0xf4, 0x97,
	0x52, 0x28, 0x5f, 0x8a, 0x45, 0x5c, 0xd0, 0x48, 0xb8, 0xc2, 0x14, 0x18, 0x3e, 0xef, 0x58, 0x96,
	0xaa, 0xe5, 0x0f, 0x8d, 0x41, 0x56, 0x80, 0x78, 0xd6, 0xbc, 0x3e, 0x87, 0x66, 0xf6, 0x4a, 0xc6,
	0xa1, 0xae, 0x1c, 0x1a, 0x5a, 0x9a, 0x99, 0xfd, 0x10, 0x36, 0xcd, 0x15, 0xf3, 0xc8, 0x0d, 0x65,
	0xd8, 0xca, 0xe4, 0xc6, 0xb4, 0x7b, 0x59, 0x84, 0xfa, 0x31, 0x46, 0xc8, 0x19, 0x97, 0x0b, 0x03,
	0x92, 0x9f, 0x43, 0x25, 0x51, 0x89, 0xa2, 0x12, 0xc2, 0xda, 0xff, 0xac, 0x77, 0xc3, 0xcf, 0x40,
	0x3d, 0x9d, 0x4b, 0x83, 0x92, 0xe4, 0x8e, 0x63, 0x1c, 0xc8, 0x31, 0x58, 0xb9, 0x09, 0xb7, 0xd7,
	0x3b, 0xc5, 0x3d, 0x6b, 0xbf, 0x7d, 0xa3, 0x7f, 0xce, 0x1f, 0x13, 0x63, 0xd1, 0x93, 0x3c, 0x01,
	0xbd, 0xa6, 0xa2, 0x5e, 0x2a, 0xad, 0xfd, 0xc7, 0x37, 0x06, 0xb9, 0xb2, 0xbe, 0x9a, 0x48, 0x99,
	0x2b, 0x39, 0x82, 0x6a, 0x76, 0x5b, 0xbb, 0xa4, 0xc2, 0xec, 0xde, 0x72, 0x97, 0xc5, 0xad, 0xc1,
	0x44, 0x99, 0xbb, 0x92, 0x63, 0xa8, 0x65, 0x4b, 0xaf, 0xdc, 0x28, 0x6f, 0x8f, 0xb3, 0x3c, 0xc3,
	0x99, 0x38, 0xb9, 0x2f, 0xf9, 0x12, 0x48, 0x84, 0x33, 0xe1, 0x2e, 0xf7, 0x90, 0x8a, 0xea, 0x21,
	0x9b, 0x52, 0xf3, 0x6c, 0xb1, 0x8f, 0x74, 0xa1, 0xa1, 0xac, 0xe7, 0xfb, 0xbb, 0xde, 0xfd, 0x2c,
	0x29, 0x1c, 0xe8, 0x1d, 0x5e, 0x52, 0x4e, 0xd9, 0x64, 0x7c, 0x66, 0xbe, 0xe2, 0x71, 0xc9, 0x51,
	0xae, 0xe6, 0x42, 0x27, 0xfe, 0xe0, 0xe8, 0xcd, 0xe5, 0x4e, 0xe1, 0xed, 0xe5, 0x4e, 0xe1, 0x7f,
	0x97, 0x3b, 0x85, 0xd7, 0xef, 0x76, 0xd6, 0xde, 0xbe, 0xdb, 0x59, 0xfb, 0xf7, 0xbb, 0x9d, 0xb5,
	0xdf, 0xff, 0x78, 0x21, 0xe9, 0xe7, 0x3f, 0x0a, 0x7a, 0x71, 0x8a, 0xfd, 0xd9, 0xe2, 0x6f, 0x83,
	0x2a, 0xfb, 0x87, 0x15, 0xd5, 0x83, 0x7e, 0xfa, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xad, 0x53,
	0x45, 0xbd, 0x3f, 0x14, 0x00, 0x00,
}

func (m *Settlement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Settlement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Settlement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BatchId != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.BatchId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ExpiresAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpiresAt):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintSettlement(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x7a
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.SettledTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.SettledTime):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintSettlement(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x72
	if m.SettledHeight != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.SettledHeight))
		i--
		dAtA[i] = 0x68
	}
	n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedTime):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintSettlement(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x62
	if m.CreatedHeight != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.CreatedHeight))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintSettlement(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Reference) > 0 {
		i -= len(m.Reference)
		copy(dAtA[i:], m.Reference)
		i = encodeVarintSettlement(dAtA, i, uint64(len(m.Reference)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintSettlement(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x42
	}
	{
		size := m.NetAmount.Size()
		i -= size
		if _, err := m.NetAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSettlement(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.Fee.Size()
		i -= size
		if _, err := m.Fee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSettlement(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSettlement(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintSettlement(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintSettlement(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintSettlement(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchSettlement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSettlement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSettlement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n7, err7 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.SettledTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.SettledTime):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintSettlement(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x62
	if m.SettledHeight != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.SettledHeight))
		i--
		dAtA[i] = 0x58
	}
	n8, err8 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedTime):])
	if err8 != nil {
		return 0, err8
	}
	i -= n8
	i = encodeVarintSettlement(dAtA, i, uint64(n8))
	i--
	dAtA[i] = 0x52
	if m.CreatedHeight != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.CreatedHeight))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintSettlement(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x42
	}
	if m.Count != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x38
	}
	{
		size := m.NetAmount.Size()
		i -= size
		if _, err := m.NetAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSettlement(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.TotalFees.Size()
		i -= size
		if _, err := m.TotalFees.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSettlement(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.TotalAmount.Size()
		i -= size
		if _, err := m.TotalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSettlement(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.SettlementIds) > 0 {
		dAtA13 := make([]byte, len(m.SettlementIds)*10)
		var j12 int
		for _, num := range m.SettlementIds {
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintSettlement(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Merchant) > 0 {
		i -= len(m.Merchant)
		copy(dAtA[i:], m.Merchant)
		i = encodeVarintSettlement(dAtA, i, uint64(len(m.Merchant)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PaymentChannel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaymentChannel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaymentChannel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nonce != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x68
	}
	if m.ExpiresAtHeight != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.ExpiresAtHeight))
		i--
		dAtA[i] = 0x60
	}
	n14, err14 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ClosedTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ClosedTime):])
	if err14 != nil {
		return 0, err14
	}
	i -= n14
	i = encodeVarintSettlement(dAtA, i, uint64(n14))
	i--
	dAtA[i] = 0x5a
	if m.ClosedHeight != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.ClosedHeight))
		i--
		dAtA[i] = 0x50
	}
	n15, err15 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.OpenedTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.OpenedTime):])
	if err15 != nil {
		return 0, err15
	}
	i -= n15
	i = encodeVarintSettlement(dAtA, i, uint64(n15))
	i--
	dAtA[i] = 0x4a
	if m.OpenedHeight != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.OpenedHeight))
		i--
		dAtA[i] = 0x40
	}
	if m.IsOpen {
		i--
		if m.IsOpen {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	{
		size := m.Balance.Size()
		i -= size
		if _, err := m.Balance.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSettlement(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.Spent.Size()
		i -= size
		if _, err := m.Spent.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSettlement(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.Deposit.Size()
		i -= size
		if _, err := m.Deposit.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSettlement(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintSettlement(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintSettlement(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MerchantConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MerchantConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MerchantConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n19, err19 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.RegisteredAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.RegisteredAt):])
	if err19 != nil {
		return 0, err19
	}
	i -= n19
	i = encodeVarintSettlement(dAtA, i, uint64(n19))
	i--
	dAtA[i] = 0x5a
	if len(m.WebhookUrl) > 0 {
		i -= len(m.WebhookUrl)
		copy(dAtA[i:], m.WebhookUrl)
		i = encodeVarintSettlement(dAtA, i, uint64(len(m.WebhookUrl)))
		i--
		dAtA[i] = 0x52
	}
	if m.IsActive {
		i--
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	n20, err20 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(m.SettlementDelay, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.SettlementDelay):])
	if err20 != nil {
		return 0, err20
	}
	i -= n20
	i = encodeVarintSettlement(dAtA, i, uint64(n20))
	i--
	dAtA[i] = 0x42
	{
		size := m.BatchThreshold.Size()
		i -= size
		if _, err := m.BatchThreshold.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSettlement(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.BatchEnabled {
		i--
		if m.BatchEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.MaxSettlement.Size()
		i -= size
		if _, err := m.MaxSettlement.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSettlement(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.MinSettlement.Size()
		i -= size
		if _, err := m.MinSettlement.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSettlement(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.FeeRateBps != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.FeeRateBps))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSettlement(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintSettlement(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckoutItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckoutItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckoutItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintSettlement(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.UnitPrice.Size()
		i -= size
		if _, err := m.UnitPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSettlement(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Quantity != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.Quantity))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ProductId) > 0 {
		i -= len(m.ProductId)
		copy(dAtA[i:], m.ProductId)
		i = encodeVarintSettlement(dAtA, i, uint64(len(m.ProductId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransferReceipt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferReceipt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferReceipt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reference) > 0 {
		i -= len(m.Reference)
		copy(dAtA[i:], m.Reference)
		i = encodeVarintSettlement(dAtA, i, uint64(len(m.Reference)))
		i--
		dAtA[i] = 0x4a
	}
	{
		size := m.Fee.Size()
		i -= size
		if _, err := m.Fee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSettlement(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSettlement(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintSettlement(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintSettlement(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x2a
	}
	n27, err27 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp):])
	if err27 != nil {
		return 0, err27
	}
	i -= n27
	i = encodeVarintSettlement(dAtA, i, uint64(n27))
	i--
	dAtA[i] = 0x22
	if m.BlockHeight != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x18
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintSettlement(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.SettlementId != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.SettlementId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ChannelsEnabled {
		i--
		if m.ChannelsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.EscrowEnabled {
		i--
		if m.EscrowEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.InstantTransfersEnabled {
		i--
		if m.InstantTransfersEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.MaxQueryLimit != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.MaxQueryLimit))
		i--
		dAtA[i] = 0x50
	}
	if m.MaxBatchSize != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.MaxBatchSize))
		i--
		dAtA[i] = 0x48
	}
	if m.MaxChannelExpiration != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.MaxChannelExpiration))
		i--
		dAtA[i] = 0x40
	}
	if m.MinChannelExpiration != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.MinChannelExpiration))
		i--
		dAtA[i] = 0x38
	}
	if m.MaxEscrowExpiration != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.MaxEscrowExpiration))
		i--
		dAtA[i] = 0x30
	}
	if m.DefaultEscrowExpiration != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.DefaultEscrowExpiration))
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.MaxSettlementAmount.Size()
		i -= size
		if _, err := m.MaxSettlementAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSettlement(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.MinSettlementAmount.Size()
		i -= size
		if _, err := m.MinSettlementAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSettlement(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.FeeCollector) > 0 {
		i -= len(m.FeeCollector)
		copy(dAtA[i:], m.FeeCollector)
		i = encodeVarintSettlement(dAtA, i, uint64(len(m.FeeCollector)))
		i--
		dAtA[i] = 0x12
	}
	if m.DefaultFeeRateBps != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.DefaultFeeRateBps))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GenesisState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NextChannelId != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.NextChannelId))
		i--
		dAtA[i] = 0x40
	}
	if m.NextBatchId != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.NextBatchId))
		i--
		dAtA[i] = 0x38
	}
	if m.NextSettlementId != 0 {
		i = encodeVarintSettlement(dAtA, i, uint64(m.NextSettlementId))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Merchants) > 0 {
		for iNdEx := len(m.Merchants) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Merchants[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSettlement(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Channels) > 0 {
		for iNdEx := len(m.Channels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Channels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSettlement(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Batches) > 0 {
		for iNdEx := len(m.Batches) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Batches[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSettlement(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Settlements) > 0 {
		for iNdEx := len(m.Settlements) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Settlements[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSettlement(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSettlement(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintSettlement(dAtA []byte, offset int, v uint64) int {
	offset -= sovSettlement(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Settlement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovSettlement(uint64(m.Id))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSettlement(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovSettlement(uint64(l))
	}
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovSettlement(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovSettlement(uint64(l))
	l = m.Fee.Size()
	n += 1 + l + sovSettlement(uint64(l))
	l = m.NetAmount.Size()
	n += 1 + l + sovSettlement(uint64(l))
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovSettlement(uint64(l))
	}
	l = len(m.Reference)
	if l > 0 {
		n += 1 + l + sovSettlement(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovSettlement(uint64(l))
	}
	if m.CreatedHeight != 0 {
		n += 1 + sovSettlement(uint64(m.CreatedHeight))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedTime)
	n += 1 + l + sovSettlement(uint64(l))
	if m.SettledHeight != 0 {
		n += 1 + sovSettlement(uint64(m.SettledHeight))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.SettledTime)
	n += 1 + l + sovSettlement(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpiresAt)
	n += 1 + l + sovSettlement(uint64(l))
	if m.BatchId != 0 {
		n += 2 + sovSettlement(uint64(m.BatchId))
	}
	return n
}

func (m *BatchSettlement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovSettlement(uint64(m.Id))
	}
	l = len(m.Merchant)
	if l > 0 {
		n += 1 + l + sovSettlement(uint64(l))
	}
	if len(m.SettlementIds) > 0 {
		l = 0
		for _, e := range m.SettlementIds {
			l += sovSettlement(uint64(e))
		}
		n += 1 + sovSettlement(uint64(l)) + l
	}
	l = m.TotalAmount.Size()
	n += 1 + l + sovSettlement(uint64(l))
	l = m.TotalFees.Size()
	n += 1 + l + sovSettlement(uint64(l))
	l = m.NetAmount.Size()
	n += 1 + l + sovSettlement(uint64(l))
	if m.Count != 0 {
		n += 1 + sovSettlement(uint64(m.Count))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovSettlement(uint64(l))
	}
	if m.CreatedHeight != 0 {
		n += 1 + sovSettlement(uint64(m.CreatedHeight))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedTime)
	n += 1 + l + sovSettlement(uint64(l))
	if m.SettledHeight != 0 {
		n += 1 + sovSettlement(uint64(m.SettledHeight))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.SettledTime)
	n += 1 + l + sovSettlement(uint64(l))
	return n
}

func (m *PaymentChannel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovSettlement(uint64(m.Id))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovSettlement(uint64(l))
	}
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovSettlement(uint64(l))
	}
	l = m.Deposit.Size()
	n += 1 + l + sovSettlement(uint64(l))
	l = m.Spent.Size()
	n += 1 + l + sovSettlement(uint64(l))
	l = m.Balance.Size()
	n += 1 + l + sovSettlement(uint64(l))
	if m.IsOpen {
		n += 2
	}
	if m.OpenedHeight != 0 {
		n += 1 + sovSettlement(uint64(m.OpenedHeight))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.OpenedTime)
	n += 1 + l + sovSettlement(uint64(l))
	if m.ClosedHeight != 0 {
		n += 1 + sovSettlement(uint64(m.ClosedHeight))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ClosedTime)
	n += 1 + l + sovSettlement(uint64(l))
	if m.ExpiresAtHeight != 0 {
		n += 1 + sovSettlement(uint64(m.ExpiresAtHeight))
	}
	if m.Nonce != 0 {
		n += 1 + sovSettlement(uint64(m.Nonce))
	}
	return n
}

func (m *MerchantConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovSettlement(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSettlement(uint64(l))
	}
	if m.FeeRateBps != 0 {
		n += 1 + sovSettlement(uint64(m.FeeRateBps))
	}
	l = m.MinSettlement.Size()
	n += 1 + l + sovSettlement(uint64(l))
	l = m.MaxSettlement.Size()
	n += 1 + l + sovSettlement(uint64(l))
	if m.BatchEnabled {
		n += 2
	}
	l = m.BatchThreshold.Size()
	n += 1 + l + sovSettlement(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.SettlementDelay)
	n += 1 + l + sovSettlement(uint64(l))
	if m.IsActive {
		n += 2
	}
	l = len(m.WebhookUrl)
	if l > 0 {
		n += 1 + l + sovSettlement(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.RegisteredAt)
	n += 1 + l + sovSettlement(uint64(l))
	return n
}

func (m *CheckoutItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProductId)
	if l > 0 {
		n += 1 + l + sovSettlement(uint64(l))
	}
	if m.Quantity != 0 {
		n += 1 + sovSettlement(uint64(m.Quantity))
	}
	l = m.UnitPrice.Size()
	n += 1 + l + sovSettlement(uint64(l))
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovSettlement(uint64(l))
	}
	return n
}

func (m *TransferReceipt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SettlementId != 0 {
		n += 1 + sovSettlement(uint64(m.SettlementId))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovSettlement(uint64(l))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovSettlement(uint64(m.BlockHeight))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovSettlement(uint64(l))
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovSettlement(uint64(l))
	}
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovSettlement(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovSettlement(uint64(l))
	l = m.Fee.Size()
	n += 1 + l + sovSettlement(uint64(l))
	l = len(m.Reference)
	if l > 0 {
		n += 1 + l + sovSettlement(uint64(l))
	}
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultFeeRateBps != 0 {
		n += 1 + sovSettlement(uint64(m.DefaultFeeRateBps))
	}
	l = len(m.FeeCollector)
	if l > 0 {
		n += 1 + l + sovSettlement(uint64(l))
	}
	l = m.MinSettlementAmount.Size()
	n += 1 + l + sovSettlement(uint64(l))
	l = m.MaxSettlementAmount.Size()
	n += 1 + l + sovSettlement(uint64(l))
	if m.DefaultEscrowExpiration != 0 {
		n += 1 + sovSettlement(uint64(m.DefaultEscrowExpiration))
	}
	if m.MaxEscrowExpiration != 0 {
		n += 1 + sovSettlement(uint64(m.MaxEscrowExpiration))
	}
	if m.MinChannelExpiration != 0 {
		n += 1 + sovSettlement(uint64(m.MinChannelExpiration))
	}
	if m.MaxChannelExpiration != 0 {
		n += 1 + sovSettlement(uint64(m.MaxChannelExpiration))
	}
	if m.MaxBatchSize != 0 {
		n += 1 + sovSettlement(uint64(m.MaxBatchSize))
	}
	if m.MaxQueryLimit != 0 {
		n += 1 + sovSettlement(uint64(m.MaxQueryLimit))
	}
	if m.InstantTransfersEnabled {
		n += 2
	}
	if m.EscrowEnabled {
		n += 2
	}
	if m.ChannelsEnabled {
		n += 2
	}
	return n
}

func (m *GenesisState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Params.Size()
	n += 1 + l + sovSettlement(uint64(l))
	if len(m.Settlements) > 0 {
		for _, e := range m.Settlements {
			l = e.Size()
			n += 1 + l + sovSettlement(uint64(l))
		}
	}
	if len(m.Batches) > 0 {
		for _, e := range m.Batches {
			l = e.Size()
			n += 1 + l + sovSettlement(uint64(l))
		}
	}
	if len(m.Channels) > 0 {
		for _, e := range m.Channels {
			l = e.Size()
			n += 1 + l + sovSettlement(uint64(l))
		}
	}
	if len(m.Merchants) > 0 {
		for _, e := range m.Merchants {
			l = e.Size()
			n += 1 + l + sovSettlement(uint64(l))
		}
	}
	if m.NextSettlementId != 0 {
		n += 1 + sovSettlement(uint64(m.NextSettlementId))
	}
	if m.NextBatchId != 0 {
		n += 1 + sovSettlement(uint64(m.NextBatchId))
	}
	if m.NextChannelId != 0 {
		n += 1 + sovSettlement(uint64(m.NextChannelId))
	}
	return n
}

func sovSettlement(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSettlement(x uint64) (n int) {
	return sovSettlement(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Settlement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSettlement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Settlement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Settlement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = SettlementType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NetAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = SettlementStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reference", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reference = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedHeight", wireType)
			}
			m.CreatedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettledHeight", wireType)
			}
			m.SettledHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettledHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettledTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.SettledTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ExpiresAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchId", wireType)
			}
			m.BatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSettlement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSettlement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSettlement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSettlement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSettlement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSettlement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Merchant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Merchant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSettlement
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SettlementIds = append(m.SettlementIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSettlement
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSettlement
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSettlement
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SettlementIds) == 0 {
					m.SettlementIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSettlement
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SettlementIds = append(m.SettlementIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementIds", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFees", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalFees.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NetAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = SettlementStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedHeight", wireType)
			}
			m.CreatedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettledHeight", wireType)
			}
			m.SettledHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettledHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettledTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.SettledTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSettlement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSettlement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaymentChannel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSettlement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaymentChannel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaymentChannel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Deposit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Balance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOpen", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOpen = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenedHeight", wireType)
			}
			m.OpenedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.OpenedTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedHeight", wireType)
			}
			m.ClosedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClosedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ClosedTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAtHeight", wireType)
			}
			m.ExpiresAtHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAtHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSettlement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSettlement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MerchantConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSettlement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MerchantConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MerchantConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeRateBps", wireType)
			}
			m.FeeRateBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeeRateBps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinSettlement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinSettlement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSettlement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxSettlement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BatchEnabled = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchThreshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BatchThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementDelay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(&m.SettlementDelay, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebhookUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WebhookUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisteredAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.RegisteredAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSettlement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSettlement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckoutItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSettlement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckoutItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckoutItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			m.Quantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantity |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UnitPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSettlement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSettlement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferReceipt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSettlement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferReceipt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferReceipt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementId", wireType)
			}
			m.SettlementId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reference", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reference = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSettlement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSettlement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSettlement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFeeRateBps", wireType)
			}
			m.DefaultFeeRateBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultFeeRateBps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeCollector", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeCollector = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinSettlementAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinSettlementAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSettlementAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxSettlementAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultEscrowExpiration", wireType)
			}
			m.DefaultEscrowExpiration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultEscrowExpiration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxEscrowExpiration", wireType)
			}
			m.MaxEscrowExpiration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxEscrowExpiration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinChannelExpiration", wireType)
			}
			m.MinChannelExpiration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinChannelExpiration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxChannelExpiration", wireType)
			}
			m.MaxChannelExpiration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxChannelExpiration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBatchSize", wireType)
			}
			m.MaxBatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBatchSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxQueryLimit", wireType)
			}
			m.MaxQueryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxQueryLimit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstantTransfersEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InstantTransfersEnabled = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EscrowEnabled = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChannelsEnabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSettlement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSettlement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenesisState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSettlement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settlements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Settlements = append(m.Settlements, Settlement{})
			if err := m.Settlements[len(m.Settlements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Batches = append(m.Batches, BatchSettlement{})
			if err := m.Batches[len(m.Batches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channels = append(m.Channels, PaymentChannel{})
			if err := m.Channels[len(m.Channels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Merchants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSettlement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSettlement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Merchants = append(m.Merchants, MerchantConfig{})
			if err := m.Merchants[len(m.Merchants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextSettlementId", wireType)
			}
			m.NextSettlementId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextSettlementId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextBatchId", wireType)
			}
			m.NextBatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextBatchId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextChannelId", wireType)
			}
			m.NextChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextChannelId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSettlement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSettlement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSettlement(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSettlement
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSettlement
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSettlement
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSettlement
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSettlement
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSettlement        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSettlement          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSettlement = fmt.Errorf("proto: unexpected end of group")
)
