// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: stateset/zkpverify/zkpverify.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "github.com/golang/protobuf/ptypes/duration"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// PublicInputField defines expected structure of public inputs.
type PublicInputField struct {
	Name     string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type     string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	Required bool   `protobuf:"varint,3,opt,name=required,proto3" json:"required,omitempty"`
}

func (m *PublicInputField) Reset()         { *m = PublicInputField{} }
func (m *PublicInputField) String() string { return proto.CompactTextString(m) }
func (*PublicInputField) ProtoMessage()    {}
func (*PublicInputField) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ff043c2e8765f53, []int{0}
}
func (m *PublicInputField) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublicInputField) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublicInputField.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublicInputField) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublicInputField.Merge(m, src)
}
func (m *PublicInputField) XXX_Size() int {
	return m.Size()
}
func (m *PublicInputField) XXX_DiscardUnknown() {
	xxx_messageInfo_PublicInputField.DiscardUnknown(m)
}

var xxx_messageInfo_PublicInputField proto.InternalMessageInfo

func (m *PublicInputField) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PublicInputField) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PublicInputField) GetRequired() bool {
	if m != nil {
		return m.Required
	}
	return false
}

// Circuit represents a registered STARK verification circuit.
type Circuit struct {
	Name              string             `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	VerificationKey   []byte             `protobuf:"bytes,2,opt,name=verification_key,json=verificationKey,proto3" json:"verification_key,omitempty"`
	ProofSystem       string             `protobuf:"bytes,3,opt,name=proof_system,json=proofSystem,proto3" json:"proof_system,omitempty"`
	PublicInputSchema []PublicInputField `protobuf:"bytes,4,rep,name=public_input_schema,json=publicInputSchema,proto3" json:"public_input_schema"`
	ConstraintHash    string             `protobuf:"bytes,5,opt,name=constraint_hash,json=constraintHash,proto3" json:"constraint_hash,omitempty"`
	Owner             string             `protobuf:"bytes,6,opt,name=owner,proto3" json:"owner,omitempty"`
	Active            bool               `protobuf:"varint,7,opt,name=active,proto3" json:"active,omitempty"`
	CreatedAt         int64              `protobuf:"varint,8,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	Description       string             `protobuf:"bytes,9,opt,name=description,proto3" json:"description,omitempty"`
	MaxRecursionDepth uint32             `protobuf:"varint,10,opt,name=max_recursion_depth,json=maxRecursionDepth,proto3" json:"max_recursion_depth,omitempty"`
}

func (m *Circuit) Reset()         { *m = Circuit{} }
func (m *Circuit) String() string { return proto.CompactTextString(m) }
func (*Circuit) ProtoMessage()    {}
func (*Circuit) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ff043c2e8765f53, []int{1}
}
func (m *Circuit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Circuit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Circuit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Circuit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Circuit.Merge(m, src)
}
func (m *Circuit) XXX_Size() int {
	return m.Size()
}
func (m *Circuit) XXX_DiscardUnknown() {
	xxx_messageInfo_Circuit.DiscardUnknown(m)
}

var xxx_messageInfo_Circuit proto.InternalMessageInfo

func (m *Circuit) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Circuit) GetVerificationKey() []byte {
	if m != nil {
		return m.VerificationKey
	}
	return nil
}

func (m *Circuit) GetProofSystem() string {
	if m != nil {
		return m.ProofSystem
	}
	return ""
}

func (m *Circuit) GetPublicInputSchema() []PublicInputField {
	if m != nil {
		return m.PublicInputSchema
	}
	return nil
}

func (m *Circuit) GetConstraintHash() string {
	if m != nil {
		return m.ConstraintHash
	}
	return ""
}

func (m *Circuit) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *Circuit) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *Circuit) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *Circuit) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Circuit) GetMaxRecursionDepth() uint32 {
	if m != nil {
		return m.MaxRecursionDepth
	}
	return 0
}

// Condition represents a single condition in a rule.
type Condition struct {
	Field    string `protobuf:"bytes,1,opt,name=field,proto3" json:"field,omitempty"`
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	Value    string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	RefField string `protobuf:"bytes,4,opt,name=ref_field,json=refField,proto3" json:"ref_field,omitempty"`
}

func (m *Condition) Reset()         { *m = Condition{} }
func (m *Condition) String() string { return proto.CompactTextString(m) }
func (*Condition) ProtoMessage()    {}
func (*Condition) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ff043c2e8765f53, []int{2}
}
func (m *Condition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Condition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Condition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Condition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Condition.Merge(m, src)
}
func (m *Condition) XXX_Size() int {
	return m.Size()
}
func (m *Condition) XXX_DiscardUnknown() {
	xxx_messageInfo_Condition.DiscardUnknown(m)
}

var xxx_messageInfo_Condition proto.InternalMessageInfo

func (m *Condition) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *Condition) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *Condition) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Condition) GetRefField() string {
	if m != nil {
		return m.RefField
	}
	return ""
}

// SymbolicRule defines a logical constraint that must be satisfied.
type SymbolicRule struct {
	Name        string      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	CircuitName string      `protobuf:"bytes,2,opt,name=circuit_name,json=circuitName,proto3" json:"circuit_name,omitempty"`
	RuleType    RuleType    `protobuf:"bytes,3,opt,name=rule_type,json=ruleType,proto3,casttype=RuleType" json:"rule_type,omitempty"`
	Conditions  []Condition `protobuf:"bytes,4,rep,name=conditions,proto3" json:"conditions"`
	Description string      `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	Active      bool        `protobuf:"varint,6,opt,name=active,proto3" json:"active,omitempty"`
	CreatedAt   int64       `protobuf:"varint,7,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
}

func (m *SymbolicRule) Reset()         { *m = SymbolicRule{} }
func (m *SymbolicRule) String() string { return proto.CompactTextString(m) }
func (*SymbolicRule) ProtoMessage()    {}
func (*SymbolicRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ff043c2e8765f53, []int{3}
}
func (m *SymbolicRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SymbolicRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SymbolicRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SymbolicRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SymbolicRule.Merge(m, src)
}
func (m *SymbolicRule) XXX_Size() int {
	return m.Size()
}
func (m *SymbolicRule) XXX_DiscardUnknown() {
	xxx_messageInfo_SymbolicRule.DiscardUnknown(m)
}

var xxx_messageInfo_SymbolicRule proto.InternalMessageInfo

func (m *SymbolicRule) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SymbolicRule) GetCircuitName() string {
	if m != nil {
		return m.CircuitName
	}
	return ""
}

func (m *SymbolicRule) GetRuleType() RuleType {
	if m != nil {
		return m.RuleType
	}
	return ""
}

func (m *SymbolicRule) GetConditions() []Condition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *SymbolicRule) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *SymbolicRule) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *SymbolicRule) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

// Proof represents a submitted ZKP for verification.
type Proof struct {
	ID              uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CircuitName     string   `protobuf:"bytes,2,opt,name=circuit_name,json=circuitName,proto3" json:"circuit_name,omitempty"`
	ProofData       []byte   `protobuf:"bytes,3,opt,name=proof_data,json=proofData,proto3" json:"proof_data,omitempty"`
	PublicInputs    []byte   `protobuf:"bytes,4,opt,name=public_inputs,json=publicInputs,proto3" json:"public_inputs,omitempty"`
	DataCommitment  []byte   `protobuf:"bytes,5,opt,name=data_commitment,json=dataCommitment,proto3" json:"data_commitment,omitempty"`
	RecursiveProofs []uint64 `protobuf:"varint,6,rep,packed,name=recursive_proofs,json=recursiveProofs,proto3" json:"recursive_proofs,omitempty"`
	Submitter       string   `protobuf:"bytes,7,opt,name=submitter,proto3" json:"submitter,omitempty"`
	SubmittedAt     int64    `protobuf:"varint,8,opt,name=submitted_at,json=submittedAt,proto3" json:"submitted_at,omitempty"`
	SubmittedHeight int64    `protobuf:"varint,9,opt,name=submitted_height,json=submittedHeight,proto3" json:"submitted_height,omitempty"`
}

func (m *Proof) Reset()         { *m = Proof{} }
func (m *Proof) String() string { return proto.CompactTextString(m) }
func (*Proof) ProtoMessage()    {}
func (*Proof) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ff043c2e8765f53, []int{4}
}
func (m *Proof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proof.Merge(m, src)
}
func (m *Proof) XXX_Size() int {
	return m.Size()
}
func (m *Proof) XXX_DiscardUnknown() {
	xxx_messageInfo_Proof.DiscardUnknown(m)
}

var xxx_messageInfo_Proof proto.InternalMessageInfo

func (m *Proof) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Proof) GetCircuitName() string {
	if m != nil {
		return m.CircuitName
	}
	return ""
}

func (m *Proof) GetProofData() []byte {
	if m != nil {
		return m.ProofData
	}
	return nil
}

func (m *Proof) GetPublicInputs() []byte {
	if m != nil {
		return m.PublicInputs
	}
	return nil
}

func (m *Proof) GetDataCommitment() []byte {
	if m != nil {
		return m.DataCommitment
	}
	return nil
}

func (m *Proof) GetRecursiveProofs() []uint64 {
	if m != nil {
		return m.RecursiveProofs
	}
	return nil
}

func (m *Proof) GetSubmitter() string {
	if m != nil {
		return m.Submitter
	}
	return ""
}

func (m *Proof) GetSubmittedAt() int64 {
	if m != nil {
		return m.SubmittedAt
	}
	return 0
}

func (m *Proof) GetSubmittedHeight() int64 {
	if m != nil {
		return m.SubmittedHeight
	}
	return 0
}

// VerificationResult stores the outcome of proof verification.
type VerificationResult struct {
	ProofID              uint64   `protobuf:"varint,1,opt,name=proof_id,json=proofId,proto3" json:"proof_id,omitempty"`
	CircuitName          string   `protobuf:"bytes,2,opt,name=circuit_name,json=circuitName,proto3" json:"circuit_name,omitempty"`
	Valid                bool     `protobuf:"varint,3,opt,name=valid,proto3" json:"valid,omitempty"`
	VerifiedAtHeight     int64    `protobuf:"varint,4,opt,name=verified_at_height,json=verifiedAtHeight,proto3" json:"verified_at_height,omitempty"`
	VerifiedAt           int64    `protobuf:"varint,5,opt,name=verified_at,json=verifiedAt,proto3" json:"verified_at,omitempty"`
	DataCommitment       []byte   `protobuf:"bytes,6,opt,name=data_commitment,json=dataCommitment,proto3" json:"data_commitment,omitempty"`
	ConstraintsSatisfied []string `protobuf:"bytes,7,rep,name=constraints_satisfied,json=constraintsSatisfied,proto3" json:"constraints_satisfied,omitempty"`
	Error                string   `protobuf:"bytes,8,opt,name=error,proto3" json:"error,omitempty"`
	VerificationTimeMs   int64    `protobuf:"varint,9,opt,name=verification_time_ms,json=verificationTimeMs,proto3" json:"verification_time_ms,omitempty"`
	RecursionDepth       uint32   `protobuf:"varint,10,opt,name=recursion_depth,json=recursionDepth,proto3" json:"recursion_depth,omitempty"`
	Challenged           bool     `protobuf:"varint,11,opt,name=challenged,proto3" json:"challenged,omitempty"`
	ChallengeDeadline    int64    `protobuf:"varint,12,opt,name=challenge_deadline,json=challengeDeadline,proto3" json:"challenge_deadline,omitempty"`
}

func (m *VerificationResult) Reset()         { *m = VerificationResult{} }
func (m *VerificationResult) String() string { return proto.CompactTextString(m) }
func (*VerificationResult) ProtoMessage()    {}
func (*VerificationResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ff043c2e8765f53, []int{5}
}
func (m *VerificationResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerificationResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerificationResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerificationResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerificationResult.Merge(m, src)
}
func (m *VerificationResult) XXX_Size() int {
	return m.Size()
}
func (m *VerificationResult) XXX_DiscardUnknown() {
	xxx_messageInfo_VerificationResult.DiscardUnknown(m)
}

var xxx_messageInfo_VerificationResult proto.InternalMessageInfo

func (m *VerificationResult) GetProofID() uint64 {
	if m != nil {
		return m.ProofID
	}
	return 0
}

func (m *VerificationResult) GetCircuitName() string {
	if m != nil {
		return m.CircuitName
	}
	return ""
}

func (m *VerificationResult) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func (m *VerificationResult) GetVerifiedAtHeight() int64 {
	if m != nil {
		return m.VerifiedAtHeight
	}
	return 0
}

func (m *VerificationResult) GetVerifiedAt() int64 {
	if m != nil {
		return m.VerifiedAt
	}
	return 0
}

func (m *VerificationResult) GetDataCommitment() []byte {
	if m != nil {
		return m.DataCommitment
	}
	return nil
}

func (m *VerificationResult) GetConstraintsSatisfied() []string {
	if m != nil {
		return m.ConstraintsSatisfied
	}
	return nil
}

func (m *VerificationResult) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *VerificationResult) GetVerificationTimeMs() int64 {
	if m != nil {
		return m.VerificationTimeMs
	}
	return 0
}

func (m *VerificationResult) GetRecursionDepth() uint32 {
	if m != nil {
		return m.RecursionDepth
	}
	return 0
}

func (m *VerificationResult) GetChallenged() bool {
	if m != nil {
		return m.Challenged
	}
	return false
}

func (m *VerificationResult) GetChallengeDeadline() int64 {
	if m != nil {
		return m.ChallengeDeadline
	}
	return 0
}

// DataCommitmentRecord tracks off-chain data commitments (validium style).
type DataCommitmentRecord struct {
	Commitment      []byte `protobuf:"bytes,1,opt,name=commitment,proto3" json:"commitment,omitempty"`
	DataHash        []byte `protobuf:"bytes,2,opt,name=data_hash,json=dataHash,proto3" json:"data_hash,omitempty"`
	ProofID         uint64 `protobuf:"varint,3,opt,name=proof_id,json=proofId,proto3" json:"proof_id,omitempty"`
	CommittedAt     int64  `protobuf:"varint,4,opt,name=committed_at,json=committedAt,proto3" json:"committed_at,omitempty"`
	CommittedHeight int64  `protobuf:"varint,5,opt,name=committed_height,json=committedHeight,proto3" json:"committed_height,omitempty"`
	DataURI         string `protobuf:"bytes,6,opt,name=data_uri,json=dataUri,proto3" json:"data_uri,omitempty"`
}

func (m *DataCommitmentRecord) Reset()         { *m = DataCommitmentRecord{} }
func (m *DataCommitmentRecord) String() string { return proto.CompactTextString(m) }
func (*DataCommitmentRecord) ProtoMessage()    {}
func (*DataCommitmentRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ff043c2e8765f53, []int{6}
}
func (m *DataCommitmentRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataCommitmentRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataCommitmentRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataCommitmentRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataCommitmentRecord.Merge(m, src)
}
func (m *DataCommitmentRecord) XXX_Size() int {
	return m.Size()
}
func (m *DataCommitmentRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_DataCommitmentRecord.DiscardUnknown(m)
}

var xxx_messageInfo_DataCommitmentRecord proto.InternalMessageInfo

func (m *DataCommitmentRecord) GetCommitment() []byte {
	if m != nil {
		return m.Commitment
	}
	return nil
}

func (m *DataCommitmentRecord) GetDataHash() []byte {
	if m != nil {
		return m.DataHash
	}
	return nil
}

func (m *DataCommitmentRecord) GetProofID() uint64 {
	if m != nil {
		return m.ProofID
	}
	return 0
}

func (m *DataCommitmentRecord) GetCommittedAt() int64 {
	if m != nil {
		return m.CommittedAt
	}
	return 0
}

func (m *DataCommitmentRecord) GetCommittedHeight() int64 {
	if m != nil {
		return m.CommittedHeight
	}
	return 0
}

func (m *DataCommitmentRecord) GetDataURI() string {
	if m != nil {
		return m.DataURI
	}
	return ""
}

// Params defines the module parameters.
type Params struct {
	MaxProofSize           uint64        `protobuf:"varint,1,opt,name=max_proof_size,json=maxProofSize,proto3" json:"max_proof_size,omitempty"`
	MaxPublicInputSize     uint64        `protobuf:"varint,2,opt,name=max_public_input_size,json=maxPublicInputSize,proto3" json:"max_public_input_size,omitempty"`
	MaxRecursionDepth      uint32        `protobuf:"varint,3,opt,name=max_recursion_depth,json=maxRecursionDepth,proto3" json:"max_recursion_depth,omitempty"`
	ChallengeWindow        time.Duration `protobuf:"bytes,4,opt,name=challenge_window,json=challengeWindow,proto3,stdduration" json:"challenge_window"`
	MinVerificationKeySize uint64        `protobuf:"varint,5,opt,name=min_verification_key_size,json=minVerificationKeySize,proto3" json:"min_verification_key_size,omitempty"`
	MaxCircuitsPerOwner    uint32        `protobuf:"varint,6,opt,name=max_circuits_per_owner,json=maxCircuitsPerOwner,proto3" json:"max_circuits_per_owner,omitempty"`
	ProofSubmissionFee     string        `protobuf:"bytes,7,opt,name=proof_submission_fee,json=proofSubmissionFee,proto3" json:"proof_submission_fee,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ff043c2e8765f53, []int{7}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetMaxProofSize() uint64 {
	if m != nil {
		return m.MaxProofSize
	}
	return 0
}

func (m *Params) GetMaxPublicInputSize() uint64 {
	if m != nil {
		return m.MaxPublicInputSize
	}
	return 0
}

func (m *Params) GetMaxRecursionDepth() uint32 {
	if m != nil {
		return m.MaxRecursionDepth
	}
	return 0
}

func (m *Params) GetChallengeWindow() time.Duration {
	if m != nil {
		return m.ChallengeWindow
	}
	return 0
}

func (m *Params) GetMinVerificationKeySize() uint64 {
	if m != nil {
		return m.MinVerificationKeySize
	}
	return 0
}

func (m *Params) GetMaxCircuitsPerOwner() uint32 {
	if m != nil {
		return m.MaxCircuitsPerOwner
	}
	return 0
}

func (m *Params) GetProofSubmissionFee() string {
	if m != nil {
		return m.ProofSubmissionFee
	}
	return ""
}

func init() {
	proto.RegisterType((*PublicInputField)(nil), "stateset.zkpverify.PublicInputField")
	proto.RegisterType((*Circuit)(nil), "stateset.zkpverify.Circuit")
	proto.RegisterType((*Condition)(nil), "stateset.zkpverify.Condition")
	proto.RegisterType((*SymbolicRule)(nil), "stateset.zkpverify.SymbolicRule")
	proto.RegisterType((*Proof)(nil), "stateset.zkpverify.Proof")
	proto.RegisterType((*VerificationResult)(nil), "stateset.zkpverify.VerificationResult")
	proto.RegisterType((*DataCommitmentRecord)(nil), "stateset.zkpverify.DataCommitmentRecord")
	proto.RegisterType((*Params)(nil), "stateset.zkpverify.Params")
}

func init() {
	proto.RegisterFile("stateset/zkpverify/zkpverify.proto", fileDescriptor_4ff043c2e8765f53)
}

var fileDescriptor_4ff043c2e8765f53 = []byte{
	// 1168 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0x4d, 0x73, 0x13, 0x47,
	0x13, 0xb6, 0x3e, 0xac, 0x8f, 0x96, 0xb0, 0xcd, 0x20, 0x5c, 0x0b, 0xef, 0x8b, 0x2c, 0x14, 0x8a,
	0x28, 0xa9, 0x44, 0x26, 0x70, 0xca, 0x11, 0x5b, 0x45, 0xe1, 0x4a, 0x85, 0xb8, 0xc6, 0x40, 0xaa,
	0xb8, 0x6c, 0xad, 0x77, 0x5b, 0xd2, 0x14, 0xda, 0x8f, 0xcc, 0xcc, 0x1a, 0x8b, 0x6b, 0xee, 0x49,
	0x8e, 0xf9, 0x45, 0x29, 0x8e, 0x1c, 0x73, 0x72, 0x52, 0xe6, 0x17, 0xe4, 0x9a, 0x53, 0x6a, 0x7a,
	0x56, 0xab, 0xb5, 0x11, 0x09, 0xb7, 0xe9, 0xa7, 0x7b, 0x66, 0xba, 0x9f, 0xee, 0xe9, 0x1e, 0xe8,
	0x2b, 0xed, 0x69, 0x54, 0xa8, 0x77, 0x5f, 0xbf, 0x4c, 0x4e, 0x50, 0x8a, 0xf1, 0x7c, 0xb9, 0x1a,
	0x26, 0x32, 0xd6, 0x31, 0x63, 0x0b, 0x9b, 0x61, 0xae, 0xb9, 0xd9, 0x99, 0xc4, 0x93, 0x98, 0xd4,
	0xbb, 0x66, 0x65, 0x2d, 0x6f, 0x76, 0x27, 0x71, 0x3c, 0x99, 0xe1, 0x2e, 0x49, 0xc7, 0xe9, 0x78,
	0x37, 0x48, 0xa5, 0xa7, 0x45, 0x1c, 0x59, 0x7d, 0xff, 0x39, 0x6c, 0x1d, 0xa6, 0xc7, 0x33, 0xe1,
	0x1f, 0x44, 0x49, 0xaa, 0x1f, 0x09, 0x9c, 0x05, 0x8c, 0x41, 0x35, 0xf2, 0x42, 0x74, 0x4a, 0xbd,
	0xd2, 0xa0, 0xc9, 0x69, 0x6d, 0x30, 0x3d, 0x4f, 0xd0, 0x29, 0x5b, 0xcc, 0xac, 0xd9, 0x4d, 0x68,
	0x48, 0xfc, 0x21, 0x15, 0x12, 0x03, 0xa7, 0xd2, 0x2b, 0x0d, 0x1a, 0x3c, 0x97, 0xfb, 0x3f, 0x57,
	0xa0, 0xbe, 0x2f, 0xa4, 0x9f, 0x0a, 0xbd, 0xf2, 0xbc, 0xcf, 0x60, 0x8b, 0xfc, 0x16, 0x3e, 0x79,
	0xe3, 0xbe, 0xc4, 0x39, 0x9d, 0xdd, 0xe6, 0x9b, 0x45, 0xfc, 0x1b, 0x9c, 0xb3, 0xdb, 0xd0, 0x4e,
	0x64, 0x1c, 0x8f, 0x5d, 0x35, 0x57, 0x1a, 0x43, 0xba, 0xaa, 0xc9, 0x5b, 0x84, 0x1d, 0x11, 0xc4,
	0x5e, 0xc0, 0xb5, 0x84, 0xa2, 0x70, 0x85, 0x09, 0xc3, 0x55, 0xfe, 0x14, 0x43, 0xcf, 0xa9, 0xf6,
	0x2a, 0x83, 0xd6, 0xfd, 0x3b, 0xc3, 0xf7, 0xd9, 0x1a, 0x5e, 0x0e, 0x7a, 0xaf, 0xfa, 0xe6, 0x6c,
	0x67, 0x8d, 0x5f, 0x4d, 0x96, 0xf8, 0x11, 0x1d, 0xc2, 0x3e, 0x85, 0x4d, 0x3f, 0x8e, 0x94, 0x96,
	0x9e, 0x88, 0xb4, 0x3b, 0xf5, 0xd4, 0xd4, 0x59, 0x27, 0x0f, 0x36, 0x96, 0xf0, 0x63, 0x4f, 0x4d,
	0x59, 0x07, 0xd6, 0xe3, 0x57, 0x11, 0x4a, 0xa7, 0x46, 0x6a, 0x2b, 0xb0, 0x6d, 0xa8, 0x79, 0xbe,
	0x16, 0x27, 0xe8, 0xd4, 0x89, 0xa2, 0x4c, 0x62, 0xb7, 0x00, 0x7c, 0x89, 0x9e, 0xc6, 0xc0, 0xf5,
	0xb4, 0xd3, 0xe8, 0x95, 0x06, 0x15, 0xde, 0xcc, 0x90, 0x87, 0x9a, 0xf5, 0xa0, 0x15, 0xa0, 0xf2,
	0xa5, 0x48, 0x0c, 0x0d, 0x4e, 0xd3, 0xc6, 0x5c, 0x80, 0xd8, 0x10, 0xae, 0x85, 0xde, 0xa9, 0x2b,
	0xd1, 0x4f, 0xa5, 0x32, 0x14, 0x06, 0x98, 0xe8, 0xa9, 0x03, 0xbd, 0xd2, 0xe0, 0x0a, 0xbf, 0x1a,
	0x7a, 0xa7, 0x7c, 0xa1, 0x19, 0x19, 0x45, 0x3f, 0x81, 0xe6, 0x7e, 0x1c, 0x05, 0x82, 0x36, 0x77,
	0x60, 0x7d, 0x6c, 0xc2, 0xce, 0x72, 0x62, 0x05, 0x93, 0xd0, 0x38, 0x41, 0xe9, 0xe9, 0x58, 0x66,
	0x89, 0xce, 0x65, 0xb3, 0xe3, 0xc4, 0x9b, 0xa5, 0x98, 0xd1, 0x6f, 0x05, 0xf6, 0x3f, 0x68, 0x4a,
	0x1c, 0xbb, 0xf6, 0xac, 0xaa, 0xdd, 0x22, 0x71, 0x4c, 0x94, 0xf6, 0x7f, 0x2a, 0x43, 0xfb, 0x68,
	0x1e, 0x1e, 0xc7, 0x33, 0xe1, 0xf3, 0x74, 0x86, 0x2b, 0x0b, 0xe1, 0x36, 0xb4, 0x7d, 0x5b, 0x27,
	0x2e, 0xe9, 0xec, 0xbd, 0xad, 0x0c, 0x7b, 0x62, 0x6b, 0xa5, 0x29, 0xd3, 0x19, 0xba, 0x54, 0x80,
	0x74, 0xfd, 0x5e, 0xfb, 0xef, 0xb3, 0x9d, 0x86, 0x39, 0xf3, 0xe9, 0x3c, 0x41, 0xde, 0x90, 0xd9,
	0x8a, 0xed, 0x03, 0xf8, 0x8b, 0x20, 0x55, 0x96, 0xff, 0x5b, 0xab, 0xf2, 0x9f, 0x53, 0x91, 0x25,
	0xbe, 0xb0, 0xed, 0x32, 0xf7, 0xeb, 0xef, 0x73, 0xbf, 0x4c, 0x6a, 0xed, 0x5f, 0x92, 0x5a, 0xbf,
	0x94, 0xd4, 0xfe, 0x6f, 0x65, 0x58, 0x3f, 0x34, 0x65, 0xcb, 0xb6, 0xa1, 0x2c, 0x2c, 0xf9, 0xd5,
	0xbd, 0xda, 0xf9, 0xd9, 0x4e, 0xf9, 0x60, 0xc4, 0xcb, 0x22, 0xf8, 0x18, 0x36, 0x6e, 0x01, 0xd8,
	0xe7, 0x10, 0x78, 0xda, 0x23, 0x3a, 0xda, 0xbc, 0x49, 0xc8, 0xc8, 0xd3, 0x1e, 0xfb, 0x04, 0xae,
	0x14, 0x9f, 0x82, 0xa2, 0xac, 0xb4, 0x79, 0xbb, 0x50, 0xd8, 0xca, 0xd4, 0xb4, 0xd9, 0xed, 0xfa,
	0x71, 0x18, 0x0a, 0x1d, 0x62, 0xa4, 0x29, 0xca, 0x36, 0xdf, 0x30, 0xf0, 0x7e, 0x8e, 0x9a, 0x67,
	0x9a, 0x15, 0xd8, 0x09, 0xba, 0x74, 0x89, 0x72, 0x6a, 0xbd, 0xca, 0xa0, 0xca, 0x37, 0x73, 0x9c,
	0x22, 0x52, 0xec, 0xff, 0xd0, 0x54, 0xe9, 0x71, 0x28, 0xb4, 0x46, 0x49, 0xa1, 0x37, 0xf9, 0x12,
	0x30, 0x81, 0x2d, 0x84, 0x42, 0xc1, 0xb7, 0x72, 0xec, 0x21, 0xdd, 0xb5, 0x34, 0x99, 0xa2, 0x98,
	0x4c, 0x35, 0xd5, 0x7d, 0x85, 0x6f, 0xe6, 0xf8, 0x63, 0x82, 0xfb, 0xe7, 0x15, 0x60, 0xcf, 0x0b,
	0x6d, 0x82, 0xa3, 0x4a, 0x67, 0x9a, 0xdd, 0x85, 0x86, 0xa5, 0x26, 0xe7, 0xb6, 0x75, 0x7e, 0xb6,
	0x53, 0x27, 0x07, 0x0f, 0x46, 0xbc, 0x4e, 0xca, 0x83, 0x8f, 0x62, 0xd9, 0x96, 0xbb, 0x58, 0x34,
	0x36, 0x2b, 0xb0, 0x2f, 0x80, 0xd9, 0xee, 0x44, 0x41, 0x2c, 0x9c, 0xac, 0x92, 0x93, 0x5b, 0x0b,
	0xcd, 0x43, 0x6d, 0xbd, 0x64, 0x3b, 0xd0, 0x2a, 0x58, 0x13, 0xc3, 0x15, 0x0e, 0x4b, 0xb3, 0x55,
	0x69, 0xa8, 0xad, 0x4c, 0xc3, 0x03, 0xb8, 0xbe, 0x6c, 0x36, 0xca, 0x55, 0x9e, 0x16, 0xca, 0x9c,
	0xe1, 0xd4, 0x7b, 0x95, 0x41, 0x93, 0x77, 0x0a, 0xca, 0xa3, 0x85, 0xce, 0x84, 0x80, 0x52, 0xc6,
	0x92, 0xb8, 0x6e, 0x72, 0x2b, 0xb0, 0x7b, 0xd0, 0xb9, 0xd0, 0x78, 0xb5, 0x08, 0xd1, 0x0d, 0x55,
	0xc6, 0x34, 0x2b, 0xea, 0x9e, 0x8a, 0x10, 0xbf, 0xa5, 0x62, 0x59, 0xdd, 0x64, 0x36, 0xe4, 0x85,
	0x0e, 0xc3, 0xba, 0x00, 0xfe, 0xd4, 0x9b, 0xcd, 0x30, 0x9a, 0x60, 0xe0, 0xb4, 0x88, 0xb8, 0x02,
	0xc2, 0xbe, 0x04, 0x96, 0x4b, 0x6e, 0x80, 0x5e, 0x30, 0x13, 0x11, 0x3a, 0x6d, 0xba, 0xf8, 0x6a,
	0xae, 0x19, 0x65, 0x8a, 0xfe, 0x5f, 0x25, 0xe8, 0x8c, 0x2e, 0xf0, 0xc0, 0xd1, 0x8f, 0x65, 0x40,
	0xf7, 0x2c, 0x19, 0x2b, 0x11, 0x63, 0x05, 0xc4, 0x34, 0x25, 0xa2, 0x95, 0x7a, 0xb5, 0x1d, 0x2a,
	0x0d, 0x03, 0x50, 0x97, 0x2e, 0xd6, 0x48, 0xe5, 0x3f, 0x6a, 0x84, 0x8e, 0xcc, 0x0a, 0xd6, 0x26,
	0xb9, 0x95, 0x63, 0xb6, 0x60, 0x97, 0x26, 0x59, 0x2d, 0xd8, 0x24, 0x6f, 0xe6, 0x78, 0x56, 0x0a,
	0x77, 0x81, 0x3c, 0x70, 0x53, 0x29, 0xec, 0x78, 0xb0, 0xb7, 0x9a, 0xf0, 0x9e, 0xf1, 0x03, 0x5e,
	0x37, 0xca, 0x67, 0x52, 0xf4, 0x7f, 0xac, 0x40, 0xed, 0xd0, 0x93, 0x5e, 0xa8, 0xd8, 0x1d, 0xd8,
	0x30, 0xfd, 0x3d, 0x1b, 0x7d, 0xe2, 0xb5, 0x6d, 0x9b, 0x55, 0xde, 0x0e, 0xbd, 0x53, 0xf2, 0xf6,
	0x48, 0xbc, 0x46, 0xf6, 0x15, 0x5c, 0x27, 0xab, 0x0b, 0xd3, 0xcf, 0x18, 0x97, 0xc9, 0x98, 0x19,
	0xe3, 0xc2, 0x48, 0x33, 0x5b, 0x3e, 0x30, 0x38, 0x2a, 0x1f, 0x18, 0x1c, 0xec, 0x09, 0x6c, 0x2d,
	0xd3, 0xf6, 0x4a, 0x44, 0x41, 0xfc, 0x8a, 0xd8, 0x68, 0xdd, 0xbf, 0x31, 0xb4, 0xbf, 0x8b, 0xe1,
	0xe2, 0x77, 0x31, 0x1c, 0x65, 0xbf, 0x8b, 0xbd, 0x86, 0xe9, 0xaa, 0xbf, 0xfe, 0xb1, 0x53, 0xe2,
	0x9b, 0xf9, 0xe6, 0xef, 0x69, 0x2f, 0xfb, 0x1a, 0x6e, 0x84, 0x22, 0x72, 0x2f, 0x8f, 0x7f, 0xeb,
	0xf6, 0x3a, 0xb9, 0xbd, 0x1d, 0x8a, 0xe8, 0xf9, 0xc5, 0x6f, 0x00, 0xb9, 0xfe, 0x00, 0xb6, 0x8d,
	0xeb, 0xd9, 0x43, 0x55, 0x6e, 0x82, 0xd2, 0x5d, 0xce, 0xdc, 0x2b, 0xdc, 0x04, 0x96, 0xfd, 0x3a,
	0xd4, 0x21, 0xca, 0xef, 0x68, 0x02, 0xdf, 0x83, 0x4e, 0x46, 0xa2, 0xe9, 0x22, 0x8a, 0x42, 0x1e,
	0x23, 0x66, 0x3d, 0x8a, 0xd9, 0x7f, 0x44, 0xae, 0x7a, 0x84, 0xb8, 0x37, 0x7a, 0x73, 0xde, 0x2d,
	0xbd, 0x3d, 0xef, 0x96, 0xfe, 0x3c, 0xef, 0x96, 0x7e, 0x79, 0xd7, 0x5d, 0x7b, 0xfb, 0xae, 0xbb,
	0xf6, 0xfb, 0xbb, 0xee, 0xda, 0x8b, 0xcf, 0x27, 0x42, 0x4f, 0xd3, 0xe3, 0xa1, 0x1f, 0x87, 0xbb,
	0xf9, 0x3f, 0xcd, 0x8f, 0x25, 0xee, 0x9e, 0x16, 0xbe, 0x6b, 0x66, 0x50, 0xa9, 0xe3, 0x1a, 0xb1,
	0xf2, 0xe0, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd5, 0x7c, 0x2f, 0x9d, 0xd1, 0x09, 0x00, 0x00,
}

func (m *PublicInputField) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicInputField) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublicInputField) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Required {
		i--
		if m.Required {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Circuit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Circuit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Circuit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxRecursionDepth != 0 {
		i = encodeVarintZkpverify(dAtA, i, uint64(m.MaxRecursionDepth))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x4a
	}
	if m.CreatedAt != 0 {
		i = encodeVarintZkpverify(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x40
	}
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ConstraintHash) > 0 {
		i -= len(m.ConstraintHash)
		copy(dAtA[i:], m.ConstraintHash)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.ConstraintHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PublicInputSchema) > 0 {
		for iNdEx := len(m.PublicInputSchema) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PublicInputSchema[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintZkpverify(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ProofSystem) > 0 {
		i -= len(m.ProofSystem)
		copy(dAtA[i:], m.ProofSystem)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.ProofSystem)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.VerificationKey) > 0 {
		i -= len(m.VerificationKey)
		copy(dAtA[i:], m.VerificationKey)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.VerificationKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Condition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Condition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Condition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RefField) > 0 {
		i -= len(m.RefField)
		copy(dAtA[i:], m.RefField)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.RefField)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Field) > 0 {
		i -= len(m.Field)
		copy(dAtA[i:], m.Field)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.Field)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SymbolicRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SymbolicRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SymbolicRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreatedAt != 0 {
		i = encodeVarintZkpverify(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x38
	}
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintZkpverify(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.RuleType) > 0 {
		i -= len(m.RuleType)
		copy(dAtA[i:], m.RuleType)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.RuleType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CircuitName) > 0 {
		i -= len(m.CircuitName)
		copy(dAtA[i:], m.CircuitName)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.CircuitName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Proof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SubmittedHeight != 0 {
		i = encodeVarintZkpverify(dAtA, i, uint64(m.SubmittedHeight))
		i--
		dAtA[i] = 0x48
	}
	if m.SubmittedAt != 0 {
		i = encodeVarintZkpverify(dAtA, i, uint64(m.SubmittedAt))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Submitter) > 0 {
		i -= len(m.Submitter)
		copy(dAtA[i:], m.Submitter)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.Submitter)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.RecursiveProofs) > 0 {
		dAtA2 := make([]byte, len(m.RecursiveProofs)*10)
		var j1 int
		for _, num := range m.RecursiveProofs {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintZkpverify(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DataCommitment) > 0 {
		i -= len(m.DataCommitment)
		copy(dAtA[i:], m.DataCommitment)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.DataCommitment)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PublicInputs) > 0 {
		i -= len(m.PublicInputs)
		copy(dAtA[i:], m.PublicInputs)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.PublicInputs)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ProofData) > 0 {
		i -= len(m.ProofData)
		copy(dAtA[i:], m.ProofData)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.ProofData)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CircuitName) > 0 {
		i -= len(m.CircuitName)
		copy(dAtA[i:], m.CircuitName)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.CircuitName)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintZkpverify(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VerificationResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerificationResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerificationResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ChallengeDeadline != 0 {
		i = encodeVarintZkpverify(dAtA, i, uint64(m.ChallengeDeadline))
		i--
		dAtA[i] = 0x60
	}
	if m.Challenged {
		i--
		if m.Challenged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.RecursionDepth != 0 {
		i = encodeVarintZkpverify(dAtA, i, uint64(m.RecursionDepth))
		i--
		dAtA[i] = 0x50
	}
	if m.VerificationTimeMs != 0 {
		i = encodeVarintZkpverify(dAtA, i, uint64(m.VerificationTimeMs))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ConstraintsSatisfied) > 0 {
		for iNdEx := len(m.ConstraintsSatisfied) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ConstraintsSatisfied[iNdEx])
			copy(dAtA[i:], m.ConstraintsSatisfied[iNdEx])
			i = encodeVarintZkpverify(dAtA, i, uint64(len(m.ConstraintsSatisfied[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.DataCommitment) > 0 {
		i -= len(m.DataCommitment)
		copy(dAtA[i:], m.DataCommitment)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.DataCommitment)))
		i--
		dAtA[i] = 0x32
	}
	if m.VerifiedAt != 0 {
		i = encodeVarintZkpverify(dAtA, i, uint64(m.VerifiedAt))
		i--
		dAtA[i] = 0x28
	}
	if m.VerifiedAtHeight != 0 {
		i = encodeVarintZkpverify(dAtA, i, uint64(m.VerifiedAtHeight))
		i--
		dAtA[i] = 0x20
	}
	if m.Valid {
		i--
		if m.Valid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.CircuitName) > 0 {
		i -= len(m.CircuitName)
		copy(dAtA[i:], m.CircuitName)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.CircuitName)))
		i--
		dAtA[i] = 0x12
	}
	if m.ProofID != 0 {
		i = encodeVarintZkpverify(dAtA, i, uint64(m.ProofID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataCommitmentRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataCommitmentRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataCommitmentRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DataURI) > 0 {
		i -= len(m.DataURI)
		copy(dAtA[i:], m.DataURI)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.DataURI)))
		i--
		dAtA[i] = 0x32
	}
	if m.CommittedHeight != 0 {
		i = encodeVarintZkpverify(dAtA, i, uint64(m.CommittedHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.CommittedAt != 0 {
		i = encodeVarintZkpverify(dAtA, i, uint64(m.CommittedAt))
		i--
		dAtA[i] = 0x20
	}
	if m.ProofID != 0 {
		i = encodeVarintZkpverify(dAtA, i, uint64(m.ProofID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DataHash) > 0 {
		i -= len(m.DataHash)
		copy(dAtA[i:], m.DataHash)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.DataHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Commitment) > 0 {
		i -= len(m.Commitment)
		copy(dAtA[i:], m.Commitment)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.Commitment)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProofSubmissionFee) > 0 {
		i -= len(m.ProofSubmissionFee)
		copy(dAtA[i:], m.ProofSubmissionFee)
		i = encodeVarintZkpverify(dAtA, i, uint64(len(m.ProofSubmissionFee)))
		i--
		dAtA[i] = 0x3a
	}
	if m.MaxCircuitsPerOwner != 0 {
		i = encodeVarintZkpverify(dAtA, i, uint64(m.MaxCircuitsPerOwner))
		i--
		dAtA[i] = 0x30
	}
	if m.MinVerificationKeySize != 0 {
		i = encodeVarintZkpverify(dAtA, i, uint64(m.MinVerificationKeySize))
		i--
		dAtA[i] = 0x28
	}
	n3, err3 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(m.ChallengeWindow, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.ChallengeWindow):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintZkpverify(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x22
	if m.MaxRecursionDepth != 0 {
		i = encodeVarintZkpverify(dAtA, i, uint64(m.MaxRecursionDepth))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxPublicInputSize != 0 {
		i = encodeVarintZkpverify(dAtA, i, uint64(m.MaxPublicInputSize))
		i--
		dAtA[i] = 0x10
	}
	if m.MaxProofSize != 0 {
		i = encodeVarintZkpverify(dAtA, i, uint64(m.MaxProofSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintZkpverify(dAtA []byte, offset int, v uint64) int {
	offset -= sovZkpverify(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PublicInputField) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	if m.Required {
		n += 2
	}
	return n
}

func (m *Circuit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	l = len(m.VerificationKey)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	l = len(m.ProofSystem)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	if len(m.PublicInputSchema) > 0 {
		for _, e := range m.PublicInputSchema {
			l = e.Size()
			n += 1 + l + sovZkpverify(uint64(l))
		}
	}
	l = len(m.ConstraintHash)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	if m.Active {
		n += 2
	}
	if m.CreatedAt != 0 {
		n += 1 + sovZkpverify(uint64(m.CreatedAt))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	if m.MaxRecursionDepth != 0 {
		n += 1 + sovZkpverify(uint64(m.MaxRecursionDepth))
	}
	return n
}

func (m *Condition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Field)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	l = len(m.RefField)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	return n
}

func (m *SymbolicRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	l = len(m.CircuitName)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	l = len(m.RuleType)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovZkpverify(uint64(l))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	if m.Active {
		n += 2
	}
	if m.CreatedAt != 0 {
		n += 1 + sovZkpverify(uint64(m.CreatedAt))
	}
	return n
}

func (m *Proof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovZkpverify(uint64(m.ID))
	}
	l = len(m.CircuitName)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	l = len(m.ProofData)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	l = len(m.PublicInputs)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	l = len(m.DataCommitment)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	if len(m.RecursiveProofs) > 0 {
		l = 0
		for _, e := range m.RecursiveProofs {
			l += sovZkpverify(uint64(e))
		}
		n += 1 + sovZkpverify(uint64(l)) + l
	}
	l = len(m.Submitter)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	if m.SubmittedAt != 0 {
		n += 1 + sovZkpverify(uint64(m.SubmittedAt))
	}
	if m.SubmittedHeight != 0 {
		n += 1 + sovZkpverify(uint64(m.SubmittedHeight))
	}
	return n
}

func (m *VerificationResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProofID != 0 {
		n += 1 + sovZkpverify(uint64(m.ProofID))
	}
	l = len(m.CircuitName)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	if m.Valid {
		n += 2
	}
	if m.VerifiedAtHeight != 0 {
		n += 1 + sovZkpverify(uint64(m.VerifiedAtHeight))
	}
	if m.VerifiedAt != 0 {
		n += 1 + sovZkpverify(uint64(m.VerifiedAt))
	}
	l = len(m.DataCommitment)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	if len(m.ConstraintsSatisfied) > 0 {
		for _, s := range m.ConstraintsSatisfied {
			l = len(s)
			n += 1 + l + sovZkpverify(uint64(l))
		}
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	if m.VerificationTimeMs != 0 {
		n += 1 + sovZkpverify(uint64(m.VerificationTimeMs))
	}
	if m.RecursionDepth != 0 {
		n += 1 + sovZkpverify(uint64(m.RecursionDepth))
	}
	if m.Challenged {
		n += 2
	}
	if m.ChallengeDeadline != 0 {
		n += 1 + sovZkpverify(uint64(m.ChallengeDeadline))
	}
	return n
}

func (m *DataCommitmentRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Commitment)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	l = len(m.DataHash)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	if m.ProofID != 0 {
		n += 1 + sovZkpverify(uint64(m.ProofID))
	}
	if m.CommittedAt != 0 {
		n += 1 + sovZkpverify(uint64(m.CommittedAt))
	}
	if m.CommittedHeight != 0 {
		n += 1 + sovZkpverify(uint64(m.CommittedHeight))
	}
	l = len(m.DataURI)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxProofSize != 0 {
		n += 1 + sovZkpverify(uint64(m.MaxProofSize))
	}
	if m.MaxPublicInputSize != 0 {
		n += 1 + sovZkpverify(uint64(m.MaxPublicInputSize))
	}
	if m.MaxRecursionDepth != 0 {
		n += 1 + sovZkpverify(uint64(m.MaxRecursionDepth))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.ChallengeWindow)
	n += 1 + l + sovZkpverify(uint64(l))
	if m.MinVerificationKeySize != 0 {
		n += 1 + sovZkpverify(uint64(m.MinVerificationKeySize))
	}
	if m.MaxCircuitsPerOwner != 0 {
		n += 1 + sovZkpverify(uint64(m.MaxCircuitsPerOwner))
	}
	l = len(m.ProofSubmissionFee)
	if l > 0 {
		n += 1 + l + sovZkpverify(uint64(l))
	}
	return n
}

func sovZkpverify(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozZkpverify(x uint64) (n int) {
	return sovZkpverify(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PublicInputField) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZkpverify
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublicInputField: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublicInputField: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Required = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipZkpverify(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthZkpverify
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Circuit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZkpverify
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Circuit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Circuit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerificationKey = append(m.VerificationKey[:0], dAtA[iNdEx:postIndex]...)
			if m.VerificationKey == nil {
				m.VerificationKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofSystem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofSystem = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicInputSchema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicInputSchema = append(m.PublicInputSchema, PublicInputField{})
			if err := m.PublicInputSchema[len(m.PublicInputSchema)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConstraintHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRecursionDepth", wireType)
			}
			m.MaxRecursionDepth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRecursionDepth |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZkpverify(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthZkpverify
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Condition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZkpverify
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Condition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Condition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefField", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefField = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZkpverify(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthZkpverify
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SymbolicRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZkpverify
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SymbolicRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SymbolicRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CircuitName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CircuitName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleType = RuleType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZkpverify(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthZkpverify
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZkpverify
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CircuitName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CircuitName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofData = append(m.ProofData[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofData == nil {
				m.ProofData = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicInputs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicInputs = append(m.PublicInputs[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicInputs == nil {
				m.PublicInputs = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataCommitment", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataCommitment = append(m.DataCommitment[:0], dAtA[iNdEx:postIndex]...)
			if m.DataCommitment == nil {
				m.DataCommitment = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZkpverify
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RecursiveProofs = append(m.RecursiveProofs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZkpverify
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthZkpverify
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthZkpverify
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RecursiveProofs) == 0 {
					m.RecursiveProofs = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowZkpverify
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RecursiveProofs = append(m.RecursiveProofs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RecursiveProofs", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Submitter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Submitter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedAt", wireType)
			}
			m.SubmittedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubmittedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedHeight", wireType)
			}
			m.SubmittedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubmittedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZkpverify(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthZkpverify
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerificationResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZkpverify
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerificationResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerificationResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofID", wireType)
			}
			m.ProofID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProofID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CircuitName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CircuitName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Valid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Valid = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifiedAtHeight", wireType)
			}
			m.VerifiedAtHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerifiedAtHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifiedAt", wireType)
			}
			m.VerifiedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerifiedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataCommitment", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataCommitment = append(m.DataCommitment[:0], dAtA[iNdEx:postIndex]...)
			if m.DataCommitment == nil {
				m.DataCommitment = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintsSatisfied", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConstraintsSatisfied = append(m.ConstraintsSatisfied, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationTimeMs", wireType)
			}
			m.VerificationTimeMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerificationTimeMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecursionDepth", wireType)
			}
			m.RecursionDepth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecursionDepth |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Challenged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Challenged = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeDeadline", wireType)
			}
			m.ChallengeDeadline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeDeadline |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZkpverify(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthZkpverify
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataCommitmentRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZkpverify
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataCommitmentRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataCommitmentRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitment", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commitment = append(m.Commitment[:0], dAtA[iNdEx:postIndex]...)
			if m.Commitment == nil {
				m.Commitment = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataHash = append(m.DataHash[:0], dAtA[iNdEx:postIndex]...)
			if m.DataHash == nil {
				m.DataHash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofID", wireType)
			}
			m.ProofID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProofID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommittedAt", wireType)
			}
			m.CommittedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommittedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommittedHeight", wireType)
			}
			m.CommittedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommittedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZkpverify(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthZkpverify
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZkpverify
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxProofSize", wireType)
			}
			m.MaxProofSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxProofSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPublicInputSize", wireType)
			}
			m.MaxPublicInputSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPublicInputSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRecursionDepth", wireType)
			}
			m.MaxRecursionDepth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRecursionDepth |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeWindow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(&m.ChallengeWindow, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinVerificationKeySize", wireType)
			}
			m.MinVerificationKeySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinVerificationKeySize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCircuitsPerOwner", wireType)
			}
			m.MaxCircuitsPerOwner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxCircuitsPerOwner |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofSubmissionFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZkpverify
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZkpverify
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofSubmissionFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZkpverify(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthZkpverify
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipZkpverify(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowZkpverify
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowZkpverify
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthZkpverify
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupZkpverify
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthZkpverify
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthZkpverify        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowZkpverify          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupZkpverify = fmt.Errorf("proto: unexpected end of group")
)
