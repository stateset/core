// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: stateset/metrics/metrics.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "github.com/golang/protobuf/ptypes/duration"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Metric represents a single metric data point.
type Metric struct {
	Name      string                      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type      MetricType                  `protobuf:"bytes,2,opt,name=type,proto3,casttype=MetricType" json:"type,omitempty"`
	Value     cosmossdk_io_math.LegacyDec `protobuf:"bytes,3,opt,name=value,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"value"`
	Labels    map[string]string           `protobuf:"bytes,4,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Timestamp time.Time                   `protobuf:"bytes,5,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	Height    int64                       `protobuf:"varint,6,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *Metric) Reset()         { *m = Metric{} }
func (m *Metric) String() string { return proto.CompactTextString(m) }
func (*Metric) ProtoMessage()    {}
func (*Metric) Descriptor() ([]byte, []int) {
	return fileDescriptor_27fb164c4766a781, []int{0}
}
func (m *Metric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metric.Merge(m, src)
}
func (m *Metric) XXX_Size() int {
	return m.Size()
}
func (m *Metric) XXX_DiscardUnknown() {
	xxx_messageInfo_Metric.DiscardUnknown(m)
}

var xxx_messageInfo_Metric proto.InternalMessageInfo

func (m *Metric) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Metric) GetType() MetricType {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Metric) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Metric) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *Metric) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

// Counter represents a monotonically increasing counter.
type Counter struct {
	Name   string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value  uint64            `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
	Labels map[string]string `protobuf:"bytes,3,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Counter) Reset()         { *m = Counter{} }
func (m *Counter) String() string { return proto.CompactTextString(m) }
func (*Counter) ProtoMessage()    {}
func (*Counter) Descriptor() ([]byte, []int) {
	return fileDescriptor_27fb164c4766a781, []int{1}
}
func (m *Counter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Counter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Counter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Counter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Counter.Merge(m, src)
}
func (m *Counter) XXX_Size() int {
	return m.Size()
}
func (m *Counter) XXX_DiscardUnknown() {
	xxx_messageInfo_Counter.DiscardUnknown(m)
}

var xxx_messageInfo_Counter proto.InternalMessageInfo

func (m *Counter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Counter) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *Counter) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// Gauge represents a value that can go up and down.
type Gauge struct {
	Name      string                      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value     cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=value,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"value"`
	Labels    map[string]string           `protobuf:"bytes,3,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	UpdatedAt time.Time                   `protobuf:"bytes,4,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at"`
}

func (m *Gauge) Reset()         { *m = Gauge{} }
func (m *Gauge) String() string { return proto.CompactTextString(m) }
func (*Gauge) ProtoMessage()    {}
func (*Gauge) Descriptor() ([]byte, []int) {
	return fileDescriptor_27fb164c4766a781, []int{2}
}
func (m *Gauge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Gauge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Gauge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Gauge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Gauge.Merge(m, src)
}
func (m *Gauge) XXX_Size() int {
	return m.Size()
}
func (m *Gauge) XXX_DiscardUnknown() {
	xxx_messageInfo_Gauge.DiscardUnknown(m)
}

var xxx_messageInfo_Gauge proto.InternalMessageInfo

func (m *Gauge) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Gauge) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Gauge) GetUpdatedAt() time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return time.Time{}
}

// HistogramBucket represents a single bucket in a histogram.
type HistogramBucket struct {
	LowerBound cosmossdk_io_math.LegacyDec `protobuf:"bytes,1,opt,name=lower_bound,json=lowerBound,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"lower_bound"`
	UpperBound cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=upper_bound,json=upperBound,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"upper_bound"`
	Count      uint64                      `protobuf:"varint,3,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *HistogramBucket) Reset()         { *m = HistogramBucket{} }
func (m *HistogramBucket) String() string { return proto.CompactTextString(m) }
func (*HistogramBucket) ProtoMessage()    {}
func (*HistogramBucket) Descriptor() ([]byte, []int) {
	return fileDescriptor_27fb164c4766a781, []int{3}
}
func (m *HistogramBucket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HistogramBucket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HistogramBucket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HistogramBucket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HistogramBucket.Merge(m, src)
}
func (m *HistogramBucket) XXX_Size() int {
	return m.Size()
}
func (m *HistogramBucket) XXX_DiscardUnknown() {
	xxx_messageInfo_HistogramBucket.DiscardUnknown(m)
}

var xxx_messageInfo_HistogramBucket proto.InternalMessageInfo

func (m *HistogramBucket) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

// Histogram represents a distribution of values.
type Histogram struct {
	Name      string                      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Buckets   []HistogramBucket           `protobuf:"bytes,2,rep,name=buckets,proto3" json:"buckets"`
	Sum       cosmossdk_io_math.LegacyDec `protobuf:"bytes,3,opt,name=sum,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"sum"`
	Count     uint64                      `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	Labels    map[string]string           `protobuf:"bytes,5,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	UpdatedAt time.Time                   `protobuf:"bytes,6,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at"`
}

func (m *Histogram) Reset()         { *m = Histogram{} }
func (m *Histogram) String() string { return proto.CompactTextString(m) }
func (*Histogram) ProtoMessage()    {}
func (*Histogram) Descriptor() ([]byte, []int) {
	return fileDescriptor_27fb164c4766a781, []int{4}
}
func (m *Histogram) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Histogram) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Histogram.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Histogram) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Histogram.Merge(m, src)
}
func (m *Histogram) XXX_Size() int {
	return m.Size()
}
func (m *Histogram) XXX_DiscardUnknown() {
	xxx_messageInfo_Histogram.DiscardUnknown(m)
}

var xxx_messageInfo_Histogram proto.InternalMessageInfo

func (m *Histogram) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Histogram) GetBuckets() []HistogramBucket {
	if m != nil {
		return m.Buckets
	}
	return nil
}

func (m *Histogram) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Histogram) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Histogram) GetUpdatedAt() time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return time.Time{}
}

// ModuleHealth represents the health status of a module.
type ModuleHealth struct {
	Module       string    `protobuf:"bytes,1,opt,name=module,proto3" json:"module,omitempty"`
	Status       string    `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	ErrorRate    float64   `protobuf:"fixed64,3,opt,name=error_rate,json=errorRate,proto3" json:"error_rate,omitempty"`
	Latency      float64   `protobuf:"fixed64,4,opt,name=latency,proto3" json:"latency,omitempty"`
	LastError    string    `protobuf:"bytes,5,opt,name=last_error,json=lastError,proto3" json:"last_error,omitempty"`
	LastErrorAt  time.Time `protobuf:"bytes,6,opt,name=last_error_at,json=lastErrorAt,proto3,stdtime" json:"last_error_at"`
	Transactions uint64    `protobuf:"varint,7,opt,name=transactions,proto3" json:"transactions,omitempty"`
}

func (m *ModuleHealth) Reset()         { *m = ModuleHealth{} }
func (m *ModuleHealth) String() string { return proto.CompactTextString(m) }
func (*ModuleHealth) ProtoMessage()    {}
func (*ModuleHealth) Descriptor() ([]byte, []int) {
	return fileDescriptor_27fb164c4766a781, []int{5}
}
func (m *ModuleHealth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleHealth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleHealth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModuleHealth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleHealth.Merge(m, src)
}
func (m *ModuleHealth) XXX_Size() int {
	return m.Size()
}
func (m *ModuleHealth) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleHealth.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleHealth proto.InternalMessageInfo

func (m *ModuleHealth) GetModule() string {
	if m != nil {
		return m.Module
	}
	return ""
}

func (m *ModuleHealth) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ModuleHealth) GetErrorRate() float64 {
	if m != nil {
		return m.ErrorRate
	}
	return 0
}

func (m *ModuleHealth) GetLatency() float64 {
	if m != nil {
		return m.Latency
	}
	return 0
}

func (m *ModuleHealth) GetLastError() string {
	if m != nil {
		return m.LastError
	}
	return ""
}

func (m *ModuleHealth) GetLastErrorAt() time.Time {
	if m != nil {
		return m.LastErrorAt
	}
	return time.Time{}
}

func (m *ModuleHealth) GetTransactions() uint64 {
	if m != nil {
		return m.Transactions
	}
	return 0
}

// SystemMetrics represents overall system metrics.
type SystemMetrics struct {
	LastBlockHeight       int64                       `protobuf:"varint,1,opt,name=last_block_height,json=lastBlockHeight,proto3" json:"last_block_height,omitempty"`
	LastBlockTime         time.Time                   `protobuf:"bytes,2,opt,name=last_block_time,json=lastBlockTime,proto3,stdtime" json:"last_block_time"`
	AverageBlockTime      time.Duration               `protobuf:"bytes,3,opt,name=average_block_time,json=averageBlockTime,proto3,stdduration" json:"average_block_time"`
	TransactionsTotal     uint64                      `protobuf:"varint,4,opt,name=transactions_total,json=transactionsTotal,proto3" json:"transactions_total,omitempty"`
	ModuleHealth          map[string]*ModuleHealth    `protobuf:"bytes,5,rep,name=module_health,json=moduleHealth,proto3" json:"module_health,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	TotalCollateralValue  cosmossdk_io_math.Int       `protobuf:"bytes,6,opt,name=total_collateral_value,json=totalCollateralValue,proto3,customtype=cosmossdk.io/math.Int" json:"total_collateral_value"`
	TotalDebtValue        cosmossdk_io_math.Int       `protobuf:"bytes,7,opt,name=total_debt_value,json=totalDebtValue,proto3,customtype=cosmossdk.io/math.Int" json:"total_debt_value"`
	SystemCollateralRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,8,opt,name=system_collateral_ratio,json=systemCollateralRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"system_collateral_ratio"`
	TotalSettlements      uint64                      `protobuf:"varint,9,opt,name=total_settlements,json=totalSettlements,proto3" json:"total_settlements,omitempty"`
	TotalSettlementVolume cosmossdk_io_math.Int       `protobuf:"bytes,10,opt,name=total_settlement_volume,json=totalSettlementVolume,proto3,customtype=cosmossdk.io/math.Int" json:"total_settlement_volume"`
	ActiveEscrows         uint64                      `protobuf:"varint,11,opt,name=active_escrows,json=activeEscrows,proto3" json:"active_escrows,omitempty"`
	ActiveChannels        uint64                      `protobuf:"varint,12,opt,name=active_channels,json=activeChannels,proto3" json:"active_channels,omitempty"`
	PricesUpdated         uint64                      `protobuf:"varint,13,opt,name=prices_updated,json=pricesUpdated,proto3" json:"prices_updated,omitempty"`
	StalePriceCount       uint64                      `protobuf:"varint,14,opt,name=stale_price_count,json=stalePriceCount,proto3" json:"stale_price_count,omitempty"`
	CircuitTrips          uint64                      `protobuf:"varint,15,opt,name=circuit_trips,json=circuitTrips,proto3" json:"circuit_trips,omitempty"`
	RateLimitHits         uint64                      `protobuf:"varint,16,opt,name=rate_limit_hits,json=rateLimitHits,proto3" json:"rate_limit_hits,omitempty"`
	ComplianceBlocks      uint64                      `protobuf:"varint,17,opt,name=compliance_blocks,json=complianceBlocks,proto3" json:"compliance_blocks,omitempty"`
}

func (m *SystemMetrics) Reset()         { *m = SystemMetrics{} }
func (m *SystemMetrics) String() string { return proto.CompactTextString(m) }
func (*SystemMetrics) ProtoMessage()    {}
func (*SystemMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_27fb164c4766a781, []int{6}
}
func (m *SystemMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SystemMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SystemMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SystemMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SystemMetrics.Merge(m, src)
}
func (m *SystemMetrics) XXX_Size() int {
	return m.Size()
}
func (m *SystemMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_SystemMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_SystemMetrics proto.InternalMessageInfo

func (m *SystemMetrics) GetLastBlockHeight() int64 {
	if m != nil {
		return m.LastBlockHeight
	}
	return 0
}

func (m *SystemMetrics) GetLastBlockTime() time.Time {
	if m != nil {
		return m.LastBlockTime
	}
	return time.Time{}
}

func (m *SystemMetrics) GetAverageBlockTime() time.Duration {
	if m != nil {
		return m.AverageBlockTime
	}
	return 0
}

func (m *SystemMetrics) GetTransactionsTotal() uint64 {
	if m != nil {
		return m.TransactionsTotal
	}
	return 0
}

func (m *SystemMetrics) GetModuleHealth() map[string]*ModuleHealth {
	if m != nil {
		return m.ModuleHealth
	}
	return nil
}

func (m *SystemMetrics) GetTotalSettlements() uint64 {
	if m != nil {
		return m.TotalSettlements
	}
	return 0
}

func (m *SystemMetrics) GetActiveEscrows() uint64 {
	if m != nil {
		return m.ActiveEscrows
	}
	return 0
}

func (m *SystemMetrics) GetActiveChannels() uint64 {
	if m != nil {
		return m.ActiveChannels
	}
	return 0
}

func (m *SystemMetrics) GetPricesUpdated() uint64 {
	if m != nil {
		return m.PricesUpdated
	}
	return 0
}

func (m *SystemMetrics) GetStalePriceCount() uint64 {
	if m != nil {
		return m.StalePriceCount
	}
	return 0
}

func (m *SystemMetrics) GetCircuitTrips() uint64 {
	if m != nil {
		return m.CircuitTrips
	}
	return 0
}

func (m *SystemMetrics) GetRateLimitHits() uint64 {
	if m != nil {
		return m.RateLimitHits
	}
	return 0
}

func (m *SystemMetrics) GetComplianceBlocks() uint64 {
	if m != nil {
		return m.ComplianceBlocks
	}
	return 0
}

// AlertConfig defines an alert configuration.
type AlertConfig struct {
	Name       string                      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	MetricName string                      `protobuf:"bytes,2,opt,name=metric_name,json=metricName,proto3" json:"metric_name,omitempty"`
	Condition  AlertCondition              `protobuf:"bytes,3,opt,name=condition,proto3,casttype=AlertCondition" json:"condition,omitempty"`
	Threshold  cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=threshold,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"threshold"`
	Duration   time.Duration               `protobuf:"bytes,5,opt,name=duration,proto3,stdduration" json:"duration"`
	Severity   AlertSeverity               `protobuf:"bytes,6,opt,name=severity,proto3,casttype=AlertSeverity" json:"severity,omitempty"`
	Enabled    bool                        `protobuf:"varint,7,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *AlertConfig) Reset()         { *m = AlertConfig{} }
func (m *AlertConfig) String() string { return proto.CompactTextString(m) }
func (*AlertConfig) ProtoMessage()    {}
func (*AlertConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_27fb164c4766a781, []int{7}
}
func (m *AlertConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlertConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlertConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlertConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlertConfig.Merge(m, src)
}
func (m *AlertConfig) XXX_Size() int {
	return m.Size()
}
func (m *AlertConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_AlertConfig.DiscardUnknown(m)
}

var xxx_messageInfo_AlertConfig proto.InternalMessageInfo

func (m *AlertConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AlertConfig) GetMetricName() string {
	if m != nil {
		return m.MetricName
	}
	return ""
}

func (m *AlertConfig) GetCondition() AlertCondition {
	if m != nil {
		return m.Condition
	}
	return ""
}

func (m *AlertConfig) GetDuration() time.Duration {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *AlertConfig) GetSeverity() AlertSeverity {
	if m != nil {
		return m.Severity
	}
	return ""
}

func (m *AlertConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// Alert represents a triggered alert.
type Alert struct {
	Id          string                      `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	ConfigName  string                      `protobuf:"bytes,2,opt,name=config_name,json=configName,proto3" json:"config_name,omitempty"`
	MetricName  string                      `protobuf:"bytes,3,opt,name=metric_name,json=metricName,proto3" json:"metric_name,omitempty"`
	Value       cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=value,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"value"`
	Threshold   cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=threshold,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"threshold"`
	Severity    AlertSeverity               `protobuf:"bytes,6,opt,name=severity,proto3,casttype=AlertSeverity" json:"severity,omitempty"`
	Message     string                      `protobuf:"bytes,7,opt,name=message,proto3" json:"message,omitempty"`
	TriggeredAt time.Time                   `protobuf:"bytes,8,opt,name=triggered_at,json=triggeredAt,proto3,stdtime" json:"triggered_at"`
	ResolvedAt  time.Time                   `protobuf:"bytes,9,opt,name=resolved_at,json=resolvedAt,proto3,stdtime" json:"resolved_at"`
	Resolved    bool                        `protobuf:"varint,10,opt,name=resolved,proto3" json:"resolved,omitempty"`
}

func (m *Alert) Reset()         { *m = Alert{} }
func (m *Alert) String() string { return proto.CompactTextString(m) }
func (*Alert) ProtoMessage()    {}
func (*Alert) Descriptor() ([]byte, []int) {
	return fileDescriptor_27fb164c4766a781, []int{8}
}
func (m *Alert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Alert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Alert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Alert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Alert.Merge(m, src)
}
func (m *Alert) XXX_Size() int {
	return m.Size()
}
func (m *Alert) XXX_DiscardUnknown() {
	xxx_messageInfo_Alert.DiscardUnknown(m)
}

var xxx_messageInfo_Alert proto.InternalMessageInfo

func (m *Alert) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Alert) GetConfigName() string {
	if m != nil {
		return m.ConfigName
	}
	return ""
}

func (m *Alert) GetMetricName() string {
	if m != nil {
		return m.MetricName
	}
	return ""
}

func (m *Alert) GetSeverity() AlertSeverity {
	if m != nil {
		return m.Severity
	}
	return ""
}

func (m *Alert) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Alert) GetTriggeredAt() time.Time {
	if m != nil {
		return m.TriggeredAt
	}
	return time.Time{}
}

func (m *Alert) GetResolvedAt() time.Time {
	if m != nil {
		return m.ResolvedAt
	}
	return time.Time{}
}

func (m *Alert) GetResolved() bool {
	if m != nil {
		return m.Resolved
	}
	return false
}

// PerformanceStats represents performance statistics.
type PerformanceStats struct {
	Module          string    `protobuf:"bytes,1,opt,name=module,proto3" json:"module,omitempty"`
	Operation       string    `protobuf:"bytes,2,opt,name=operation,proto3" json:"operation,omitempty"`
	TotalCalls      uint64    `protobuf:"varint,3,opt,name=total_calls,json=totalCalls,proto3" json:"total_calls,omitempty"`
	TotalDuration   float64   `protobuf:"fixed64,4,opt,name=total_duration,json=totalDuration,proto3" json:"total_duration,omitempty"`
	AverageDuration float64   `protobuf:"fixed64,5,opt,name=average_duration,json=averageDuration,proto3" json:"average_duration,omitempty"`
	MinDuration     float64   `protobuf:"fixed64,6,opt,name=min_duration,json=minDuration,proto3" json:"min_duration,omitempty"`
	MaxDuration     float64   `protobuf:"fixed64,7,opt,name=max_duration,json=maxDuration,proto3" json:"max_duration,omitempty"`
	ErrorCount      uint64    `protobuf:"varint,8,opt,name=error_count,json=errorCount,proto3" json:"error_count,omitempty"`
	LastCalled      time.Time `protobuf:"bytes,9,opt,name=last_called,json=lastCalled,proto3,stdtime" json:"last_called"`
}

func (m *PerformanceStats) Reset()         { *m = PerformanceStats{} }
func (m *PerformanceStats) String() string { return proto.CompactTextString(m) }
func (*PerformanceStats) ProtoMessage()    {}
func (*PerformanceStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_27fb164c4766a781, []int{9}
}
func (m *PerformanceStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PerformanceStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PerformanceStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PerformanceStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PerformanceStats.Merge(m, src)
}
func (m *PerformanceStats) XXX_Size() int {
	return m.Size()
}
func (m *PerformanceStats) XXX_DiscardUnknown() {
	xxx_messageInfo_PerformanceStats.DiscardUnknown(m)
}

var xxx_messageInfo_PerformanceStats proto.InternalMessageInfo

func (m *PerformanceStats) GetModule() string {
	if m != nil {
		return m.Module
	}
	return ""
}

func (m *PerformanceStats) GetOperation() string {
	if m != nil {
		return m.Operation
	}
	return ""
}

func (m *PerformanceStats) GetTotalCalls() uint64 {
	if m != nil {
		return m.TotalCalls
	}
	return 0
}

func (m *PerformanceStats) GetTotalDuration() float64 {
	if m != nil {
		return m.TotalDuration
	}
	return 0
}

func (m *PerformanceStats) GetAverageDuration() float64 {
	if m != nil {
		return m.AverageDuration
	}
	return 0
}

func (m *PerformanceStats) GetMinDuration() float64 {
	if m != nil {
		return m.MinDuration
	}
	return 0
}

func (m *PerformanceStats) GetMaxDuration() float64 {
	if m != nil {
		return m.MaxDuration
	}
	return 0
}

func (m *PerformanceStats) GetErrorCount() uint64 {
	if m != nil {
		return m.ErrorCount
	}
	return 0
}

func (m *PerformanceStats) GetLastCalled() time.Time {
	if m != nil {
		return m.LastCalled
	}
	return time.Time{}
}

func init() {
	proto.RegisterType((*Metric)(nil), "stateset.metrics.Metric")
	proto.RegisterMapType((map[string]string)(nil), "stateset.metrics.Metric.LabelsEntry")
	proto.RegisterType((*Counter)(nil), "stateset.metrics.Counter")
	proto.RegisterMapType((map[string]string)(nil), "stateset.metrics.Counter.LabelsEntry")
	proto.RegisterType((*Gauge)(nil), "stateset.metrics.Gauge")
	proto.RegisterMapType((map[string]string)(nil), "stateset.metrics.Gauge.LabelsEntry")
	proto.RegisterType((*HistogramBucket)(nil), "stateset.metrics.HistogramBucket")
	proto.RegisterType((*Histogram)(nil), "stateset.metrics.Histogram")
	proto.RegisterMapType((map[string]string)(nil), "stateset.metrics.Histogram.LabelsEntry")
	proto.RegisterType((*ModuleHealth)(nil), "stateset.metrics.ModuleHealth")
	proto.RegisterType((*SystemMetrics)(nil), "stateset.metrics.SystemMetrics")
	proto.RegisterMapType((map[string]*ModuleHealth)(nil), "stateset.metrics.SystemMetrics.ModuleHealthEntry")
	proto.RegisterType((*AlertConfig)(nil), "stateset.metrics.AlertConfig")
	proto.RegisterType((*Alert)(nil), "stateset.metrics.Alert")
	proto.RegisterType((*PerformanceStats)(nil), "stateset.metrics.PerformanceStats")
}

func init() { proto.RegisterFile("stateset/metrics/metrics.proto", fileDescriptor_27fb164c4766a781) }

var fileDescriptor_27fb164c4766a781 = []byte{
	// 1491 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0x4d, 0x6f, 0x1b, 0x37,
	0x1a, 0xb6, 0x3e, 0x2c, 0x4b, 0xaf, 0x2c, 0xcb, 0x26, 0x9c, 0x64, 0xe2, 0xdd, 0x95, 0x1c, 0x65,
	0xb3, 0xf1, 0x6e, 0x10, 0x79, 0x93, 0xdd, 0x43, 0x3f, 0x11, 0x58, 0xb6, 0x61, 0x07, 0x70, 0xd2,
	0x74, 0xec, 0xe4, 0xd0, 0xcb, 0x80, 0x1a, 0x31, 0xd2, 0xc0, 0x33, 0x43, 0x61, 0xc8, 0x71, 0xa2,
	0x7b, 0x7f, 0x40, 0x8e, 0xb9, 0xf6, 0x07, 0xf4, 0xd6, 0x1f, 0x91, 0x5b, 0x83, 0x9e, 0x8a, 0x1e,
	0xdc, 0x22, 0xb9, 0xb4, 0x7f, 0x21, 0x87, 0xa2, 0xe0, 0x4b, 0xce, 0x48, 0xb2, 0xd4, 0x22, 0xb2,
	0x8b, 0x9e, 0x2c, 0xbe, 0x1f, 0x0f, 0xdf, 0x2f, 0x3e, 0xe4, 0x18, 0x6a, 0x42, 0x52, 0xc9, 0x04,
	0x93, 0x9b, 0x01, 0x93, 0x91, 0xe7, 0x8a, 0xe4, 0x6f, 0xb3, 0x1f, 0x71, 0xc9, 0xc9, 0x72, 0xa2,
	0x6f, 0x1a, 0xf9, 0xda, 0x6a, 0x97, 0x77, 0x39, 0x2a, 0x37, 0xd5, 0x2f, 0x6d, 0xb7, 0x76, 0xd5,
	0xe5, 0x22, 0xe0, 0xc2, 0xd1, 0x0a, 0xbd, 0x30, 0xaa, 0x5a, 0x97, 0xf3, 0xae, 0xcf, 0x36, 0x71,
	0xd5, 0x8e, 0x9f, 0x6e, 0x76, 0xe2, 0x88, 0x4a, 0x8f, 0x87, 0x46, 0x5f, 0x3f, 0xab, 0x97, 0x5e,
	0xc0, 0x84, 0xa4, 0x41, 0x5f, 0x1b, 0x34, 0x4e, 0xb3, 0x50, 0x78, 0x80, 0xbb, 0x13, 0x02, 0xf9,
	0x90, 0x06, 0xcc, 0xca, 0xac, 0x67, 0x36, 0x4a, 0x36, 0xfe, 0x26, 0x0d, 0xc8, 0xcb, 0x41, 0x9f,
	0x59, 0x59, 0x25, 0x6b, 0x2d, 0xbd, 0x3b, 0xad, 0x83, 0xb6, 0x3e, 0x1a, 0xf4, 0x99, 0x8d, 0x3a,
	0xb2, 0x07, 0xf3, 0x27, 0xd4, 0x8f, 0x99, 0x95, 0x43, 0xa3, 0x3b, 0xaf, 0x4e, 0xeb, 0x73, 0x3f,
	0x9c, 0xd6, 0xff, 0xa6, 0x03, 0x15, 0x9d, 0xe3, 0xa6, 0xc7, 0x37, 0x03, 0x2a, 0x7b, 0xcd, 0x03,
	0xd6, 0xa5, 0xee, 0x60, 0x87, 0xb9, 0xdf, 0x7d, 0x73, 0x1b, 0x4c, 0x1e, 0x3b, 0xcc, 0xb5, 0xb5,
	0x3f, 0xf9, 0x04, 0x0a, 0x3e, 0x6d, 0x33, 0x5f, 0x58, 0xf9, 0xf5, 0xdc, 0x46, 0xf9, 0xee, 0x3f,
	0x9b, 0x67, 0x0b, 0xd4, 0xd4, 0x9b, 0x37, 0x0f, 0xd0, 0x6c, 0x37, 0x94, 0xd1, 0xc0, 0x36, 0x3e,
	0xa4, 0x05, 0xa5, 0x34, 0x39, 0x6b, 0x7e, 0x3d, 0xb3, 0x51, 0xbe, 0xbb, 0xd6, 0xd4, 0xe9, 0x37,
	0x93, 0xf4, 0x9b, 0x47, 0x89, 0x45, 0xab, 0xa8, 0xc2, 0x7c, 0xf1, 0x63, 0x3d, 0x63, 0x0f, 0xdd,
	0xc8, 0x65, 0x28, 0xf4, 0x98, 0xd7, 0xed, 0x49, 0xab, 0xb0, 0x9e, 0xd9, 0xc8, 0xd9, 0x66, 0xb5,
	0xf6, 0x21, 0x94, 0x47, 0xb6, 0x24, 0xcb, 0x90, 0x3b, 0x66, 0x03, 0x53, 0x28, 0xf5, 0x93, 0xac,
	0x26, 0x35, 0xc0, 0x42, 0x99, 0x84, 0x3e, 0xca, 0x7e, 0x90, 0x69, 0x7c, 0x9d, 0x81, 0x85, 0x6d,
	0x1e, 0x87, 0x92, 0x45, 0x53, 0x2b, 0x3c, 0xe6, 0x99, 0x4f, 0x4a, 0xf1, 0x69, 0x5a, 0x8a, 0x1c,
	0x96, 0xe2, 0xc6, 0x64, 0x29, 0x0c, 0xe8, 0xb4, 0x5a, 0x5c, 0x24, 0xde, 0xaf, 0xb2, 0x30, 0xbf,
	0x47, 0xe3, 0x2e, 0x9b, 0x1a, 0xed, 0xde, 0x98, 0xdf, 0x05, 0x7a, 0xfd, 0xf1, 0x99, 0x04, 0xaf,
	0x4f, 0x26, 0x88, 0x51, 0x4c, 0x6d, 0xf5, 0x36, 0x40, 0xdc, 0xef, 0x50, 0xc9, 0x3a, 0x0e, 0x95,
	0x56, 0x7e, 0x96, 0x5e, 0x1b, 0xbf, 0xad, 0x0b, 0xf5, 0xf4, 0xdb, 0x0c, 0x54, 0xf7, 0x3d, 0x21,
	0x79, 0x37, 0xa2, 0x41, 0x2b, 0x76, 0x8f, 0x99, 0x24, 0x36, 0x94, 0x7d, 0xfe, 0x8c, 0x45, 0x4e,
	0x9b, 0xc7, 0x61, 0x47, 0xe3, 0x9c, 0xa7, 0x3e, 0x80, 0x28, 0x2d, 0x05, 0xa2, 0x30, 0xe3, 0x7e,
	0x3f, 0xc5, 0x3c, 0x77, 0xcd, 0x01, 0x51, 0x34, 0xe6, 0x2a, 0xcc, 0xbb, 0x6a, 0x72, 0xf0, 0xb4,
	0xe6, 0x6d, 0xbd, 0x68, 0xfc, 0x9a, 0x85, 0x52, 0x9a, 0xd1, 0xd4, 0xce, 0x6f, 0xc1, 0x42, 0x1b,
	0x33, 0x15, 0x56, 0x16, 0x3b, 0x76, 0x6d, 0xb2, 0x63, 0x67, 0x6a, 0xd2, 0xca, 0xab, 0x50, 0xed,
	0xc4, 0x8f, 0x6c, 0x43, 0x4e, 0xc4, 0xc1, 0xf9, 0x69, 0x42, 0x79, 0x0f, 0xe3, 0xcf, 0x8f, 0xc4,
	0x4f, 0xee, 0xa5, 0xe3, 0x34, 0x8f, 0xc1, 0xdd, 0xfc, 0x83, 0xe0, 0xde, 0x63, 0xa4, 0x0a, 0x7f,
	0xf9, 0x48, 0x7d, 0x99, 0x85, 0xc5, 0x07, 0xbc, 0x13, 0xfb, 0x6c, 0x9f, 0x51, 0x5f, 0xf6, 0x14,
	0x15, 0x05, 0xb8, 0x36, 0xfe, 0x66, 0xa5, 0xe4, 0x2a, 0xb5, 0x58, 0x18, 0x0c, 0xb3, 0x22, 0xff,
	0x00, 0x60, 0x51, 0xc4, 0x23, 0x27, 0xa2, 0x52, 0x53, 0x71, 0xc6, 0x2e, 0xa1, 0xc4, 0xa6, 0x92,
	0x11, 0x0b, 0x16, 0x7c, 0x2a, 0x59, 0xe8, 0x0e, 0xb0, 0x70, 0x19, 0x3b, 0x59, 0x2a, 0x47, 0x9f,
	0x0a, 0xe9, 0xa0, 0x2d, 0x12, 0x67, 0xc9, 0x2e, 0x29, 0xc9, 0xae, 0x12, 0x90, 0x7d, 0xa8, 0x0c,
	0xd5, 0xb3, 0xd6, 0xa6, 0x9c, 0xe2, 0x6c, 0x49, 0xd2, 0x80, 0x45, 0x19, 0xd1, 0x50, 0x50, 0x57,
	0x5d, 0x50, 0xc2, 0x5a, 0xc0, 0x06, 0x8e, 0xc9, 0x1a, 0x2f, 0x4b, 0x50, 0x39, 0x1c, 0x08, 0xc9,
	0x02, 0xcd, 0xf4, 0x82, 0xfc, 0x07, 0x56, 0x70, 0xff, 0xb6, 0xcf, 0xdd, 0x63, 0xc7, 0xb0, 0x73,
	0x06, 0xd9, 0xb9, 0xaa, 0x14, 0x2d, 0x25, 0xdf, 0x47, 0x31, 0x39, 0x80, 0xea, 0x88, 0xad, 0xa2,
	0x75, 0x2c, 0xd2, 0xfb, 0x46, 0x5b, 0x49, 0xf1, 0x94, 0x96, 0x7c, 0x0e, 0x84, 0x9e, 0xb0, 0x88,
	0x76, 0xd9, 0x28, 0x60, 0x0e, 0x01, 0xaf, 0x4e, 0x00, 0xee, 0x98, 0x8b, 0x57, 0xe3, 0xbd, 0x54,
	0x78, 0xcb, 0xc6, 0x7d, 0x08, 0x79, 0x1b, 0xc8, 0x68, 0xba, 0x8e, 0xe4, 0x92, 0xfa, 0x66, 0x92,
	0x57, 0x46, 0x35, 0x47, 0x4a, 0x41, 0x9e, 0x40, 0x45, 0x77, 0xdd, 0xe9, 0xe1, 0x50, 0x98, 0xe1,
	0xbe, 0x33, 0x39, 0xdc, 0x63, 0x35, 0x6b, 0x8e, 0x0e, 0x92, 0x1e, 0xf3, 0xc5, 0x60, 0x74, 0xb6,
	0x28, 0x5c, 0xc6, 0x9d, 0x1d, 0x97, 0xfb, 0x6a, 0x0c, 0x22, 0xea, 0x3b, 0x7a, 0x2e, 0x0b, 0x78,
	0x36, 0x6f, 0x99, 0xb3, 0x79, 0x69, 0xf2, 0x6c, 0xde, 0x0f, 0xe5, 0xc8, 0xa9, 0xbc, 0x1f, 0x4a,
	0x7b, 0x15, 0xa1, 0xb6, 0x53, 0xa4, 0x27, 0xc8, 0xef, 0x8f, 0x61, 0x59, 0x6f, 0xd1, 0x61, 0x6d,
	0x69, 0xc0, 0x17, 0x66, 0x07, 0x5f, 0x42, 0x90, 0x1d, 0xd6, 0x96, 0x1a, 0xd6, 0x83, 0x2b, 0x02,
	0x53, 0x1d, 0x0d, 0x1d, 0x0b, 0x6f, 0x15, 0xcf, 0x4b, 0x2b, 0x97, 0x34, 0xe2, 0x30, 0x03, 0x5b,
	0xe1, 0x91, 0x5b, 0xb0, 0xa2, 0x33, 0x10, 0x4c, 0x4a, 0x9f, 0x05, 0x2c, 0x94, 0xc2, 0x2a, 0x61,
	0xab, 0x74, 0x6a, 0x87, 0x43, 0x39, 0x71, 0xe1, 0xca, 0x59, 0x63, 0xe7, 0x84, 0xfb, 0x71, 0xc0,
	0x2c, 0x98, 0x3d, 0xeb, 0x4b, 0x67, 0xf0, 0x9f, 0x20, 0x12, 0xb9, 0x01, 0x4b, 0x6a, 0x3c, 0x4e,
	0x98, 0xc3, 0x84, 0x1b, 0xf1, 0x67, 0xc2, 0x2a, 0x63, 0x38, 0x15, 0x2d, 0xdd, 0xd5, 0x42, 0x72,
	0x13, 0xaa, 0xc6, 0xcc, 0xed, 0xd1, 0x30, 0x54, 0xa4, 0xb8, 0x88, 0x76, 0xc6, 0x7b, 0xdb, 0x48,
	0x15, 0x5e, 0x3f, 0xf2, 0x5c, 0x26, 0x1c, 0x43, 0x61, 0x56, 0x45, 0xe3, 0x69, 0xe9, 0x63, 0x2d,
	0x54, 0x27, 0x50, 0x48, 0xea, 0x33, 0x07, 0xc5, 0x8e, 0x66, 0xdf, 0x25, 0xb4, 0xac, 0xa2, 0xe2,
	0x91, 0x92, 0xe3, 0x73, 0x84, 0x5c, 0x87, 0x8a, 0xeb, 0x45, 0x6e, 0xec, 0x49, 0x47, 0x46, 0x5e,
	0x5f, 0x58, 0x55, 0x7d, 0xc8, 0x8d, 0xf0, 0x48, 0xc9, 0xc8, 0xbf, 0xa0, 0xaa, 0x48, 0xca, 0xf1,
	0xbd, 0xc0, 0x93, 0x4e, 0xcf, 0x93, 0xc2, 0x5a, 0xd6, 0x1b, 0x2b, 0xf1, 0x81, 0x92, 0xee, 0x7b,
	0x52, 0xa8, 0x0e, 0xb8, 0x3c, 0xe8, 0xfb, 0x1e, 0x0d, 0x5d, 0x73, 0x06, 0x85, 0xb5, 0xa2, 0x3b,
	0x30, 0x54, 0xe0, 0xe9, 0x12, 0x6b, 0x0e, 0xac, 0x4c, 0x8c, 0xfd, 0x14, 0x06, 0xfe, 0xff, 0x28,
	0x03, 0x97, 0xef, 0xd6, 0xa6, 0x3c, 0x31, 0x47, 0x50, 0xc6, 0x2e, 0xfd, 0x2c, 0x94, 0xb7, 0x7c,
	0x16, 0xc9, 0x6d, 0x1e, 0x3e, 0xf5, 0xba, 0x53, 0x2f, 0xc9, 0x3a, 0x94, 0x35, 0x8c, 0x83, 0x2a,
	0xcd, 0xd0, 0xa0, 0x45, 0x0f, 0x95, 0xc1, 0x7f, 0xa1, 0xe4, 0xf2, 0xb0, 0xe3, 0xa9, 0x43, 0x6e,
	0x2e, 0x42, 0xf2, 0xee, 0xb4, 0xbe, 0x94, 0x00, 0x6b, 0x8d, 0x3d, 0x34, 0x22, 0x9f, 0x41, 0x49,
	0xf6, 0x22, 0x26, 0x7a, 0xdc, 0xef, 0x20, 0x53, 0x9c, 0x6b, 0xc6, 0x87, 0x18, 0xe4, 0x1e, 0x14,
	0x93, 0x8f, 0x04, 0xf3, 0x4c, 0x7e, 0x2f, 0x32, 0x4b, 0x9d, 0xc8, 0x6d, 0x28, 0x0a, 0x76, 0xc2,
	0x22, 0x4f, 0x0e, 0x0c, 0x5f, 0xac, 0xbc, 0x3b, 0xad, 0x57, 0x30, 0x85, 0x43, 0xa3, 0xb0, 0x53,
	0x13, 0x75, 0xf3, 0xb0, 0x90, 0xb6, 0x7d, 0xd6, 0x41, 0x02, 0x28, 0xda, 0xc9, 0xb2, 0xf1, 0x73,
	0x0e, 0xe6, 0xd1, 0x8b, 0x2c, 0x41, 0xd6, 0x33, 0x6f, 0x26, 0x3b, 0xeb, 0x75, 0x54, 0x1d, 0x5d,
	0xac, 0xf2, 0x58, 0x1d, 0xb5, 0xe8, 0xe1, 0x94, 0x42, 0xe7, 0x26, 0x0a, 0x9d, 0x3e, 0x54, 0xf3,
	0x17, 0x7c, 0xa8, 0x8e, 0xd5, 0x7f, 0xfe, 0x4f, 0xa8, 0xff, 0xec, 0xe5, 0x0b, 0x98, 0x10, 0xb4,
	0x6b, 0xf8, 0xd3, 0x4e, 0x96, 0x64, 0x4f, 0xdd, 0xa7, 0x5e, 0xb7, 0xcb, 0x22, 0xfd, 0x68, 0x29,
	0xce, 0x72, 0x31, 0xa7, 0x9e, 0x5b, 0x92, 0xec, 0x42, 0x39, 0x62, 0x82, 0xfb, 0x27, 0x1a, 0xa7,
	0x34, 0x03, 0x0e, 0x24, 0x8e, 0x5b, 0x92, 0xac, 0x41, 0x31, 0x59, 0x21, 0xe9, 0x15, 0xed, 0x74,
	0xdd, 0xf8, 0x25, 0x0b, 0xcb, 0x8f, 0x58, 0xf4, 0x94, 0x47, 0x81, 0x3a, 0xb3, 0x87, 0x92, 0x4a,
	0xf1, 0xbb, 0x4f, 0x9c, 0xbf, 0x43, 0x89, 0xf7, 0x99, 0x19, 0x51, 0xdd, 0xfb, 0xa1, 0x40, 0xb5,
	0xde, 0x5c, 0x5e, 0xd4, 0xc7, 0xcf, 0x07, 0xc5, 0x07, 0xa0, 0x2f, 0x21, 0x25, 0x51, 0xb4, 0x66,
	0xae, 0x9e, 0x64, 0xcc, 0xf5, 0x8b, 0xa7, 0xa2, 0xef, 0x92, 0x64, 0x8c, 0xff, 0x0d, 0xc9, 0xfd,
	0xec, 0x8c, 0x9d, 0x87, 0x8c, 0x5d, 0x35, 0xf2, 0xd4, 0xf4, 0x1a, 0x2c, 0x06, 0x5e, 0x38, 0x34,
	0x2b, 0xa0, 0x59, 0x39, 0xf0, 0xc2, 0x31, 0x13, 0xfa, 0x7c, 0x68, 0xb2, 0x60, 0x4c, 0xe8, 0xf3,
	0xd4, 0xa4, 0x0e, 0x65, 0xfd, 0x88, 0xd2, 0x0c, 0x5a, 0xd4, 0x81, 0xa3, 0x48, 0x93, 0xe7, 0x2e,
	0xe0, 0x7b, 0x09, 0x13, 0x63, 0x9d, 0xd9, 0xfa, 0xa0, 0x1c, 0xb7, 0xd1, 0xaf, 0xd5, 0x7a, 0xf5,
	0xa6, 0x96, 0x79, 0xfd, 0xa6, 0x96, 0xf9, 0xe9, 0x4d, 0x2d, 0xf3, 0xe2, 0x6d, 0x6d, 0xee, 0xf5,
	0xdb, 0xda, 0xdc, 0xf7, 0x6f, 0x6b, 0x73, 0x5f, 0x6c, 0x74, 0x3d, 0xd9, 0x8b, 0xdb, 0x4d, 0x97,
	0x07, 0x9b, 0xe9, 0xff, 0x26, 0x5c, 0x1e, 0xb1, 0xcd, 0xe7, 0xe9, 0xbf, 0x28, 0xd4, 0x27, 0xbd,
	0x68, 0x17, 0x70, 0xb7, 0xff, 0xfd, 0x16, 0x00, 0x00, 0xff, 0xff, 0xa8, 0x67, 0x8c, 0xde, 0xc3,
	0x10, 0x00, 0x00,
}

func (m *Metric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x30
	}
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintMetrics(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x2a
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintMetrics(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMetrics(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMetrics(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size := m.Value.Size()
		i -= size
		if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMetrics(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Counter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Counter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Counter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintMetrics(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMetrics(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMetrics(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Value != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Gauge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Gauge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Gauge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.UpdatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintMetrics(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x22
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintMetrics(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMetrics(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMetrics(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.Value.Size()
		i -= size
		if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMetrics(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HistogramBucket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HistogramBucket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HistogramBucket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.UpperBound.Size()
		i -= size
		if _, err := m.UpperBound.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMetrics(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.LowerBound.Size()
		i -= size
		if _, err := m.LowerBound.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMetrics(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Histogram) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Histogram) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Histogram) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.UpdatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintMetrics(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x32
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintMetrics(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMetrics(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMetrics(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Count != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.Sum.Size()
		i -= size
		if _, err := m.Sum.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMetrics(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Buckets) > 0 {
		for iNdEx := len(m.Buckets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Buckets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetrics(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModuleHealth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleHealth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModuleHealth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Transactions != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Transactions))
		i--
		dAtA[i] = 0x38
	}
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastErrorAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastErrorAt):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintMetrics(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x32
	if len(m.LastError) > 0 {
		i -= len(m.LastError)
		copy(dAtA[i:], m.LastError)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.LastError)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Latency != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Latency))))
		i--
		dAtA[i] = 0x21
	}
	if m.ErrorRate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ErrorRate))))
		i--
		dAtA[i] = 0x19
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Module) > 0 {
		i -= len(m.Module)
		copy(dAtA[i:], m.Module)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.Module)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SystemMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SystemMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SystemMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ComplianceBlocks != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.ComplianceBlocks))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.RateLimitHits != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.RateLimitHits))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.CircuitTrips != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.CircuitTrips))
		i--
		dAtA[i] = 0x78
	}
	if m.StalePriceCount != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.StalePriceCount))
		i--
		dAtA[i] = 0x70
	}
	if m.PricesUpdated != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.PricesUpdated))
		i--
		dAtA[i] = 0x68
	}
	if m.ActiveChannels != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.ActiveChannels))
		i--
		dAtA[i] = 0x60
	}
	if m.ActiveEscrows != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.ActiveEscrows))
		i--
		dAtA[i] = 0x58
	}
	{
		size := m.TotalSettlementVolume.Size()
		i -= size
		if _, err := m.TotalSettlementVolume.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMetrics(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if m.TotalSettlements != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.TotalSettlements))
		i--
		dAtA[i] = 0x48
	}
	{
		size := m.SystemCollateralRatio.Size()
		i -= size
		if _, err := m.SystemCollateralRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMetrics(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.TotalDebtValue.Size()
		i -= size
		if _, err := m.TotalDebtValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMetrics(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.TotalCollateralValue.Size()
		i -= size
		if _, err := m.TotalCollateralValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMetrics(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.ModuleHealth) > 0 {
		for k := range m.ModuleHealth {
			v := m.ModuleHealth[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintMetrics(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMetrics(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMetrics(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.TransactionsTotal != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.TransactionsTotal))
		i--
		dAtA[i] = 0x20
	}
	n6, err6 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(m.AverageBlockTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.AverageBlockTime):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintMetrics(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x1a
	n7, err7 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastBlockTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastBlockTime):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintMetrics(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x12
	if m.LastBlockHeight != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.LastBlockHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlertConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlertConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Severity) > 0 {
		i -= len(m.Severity)
		copy(dAtA[i:], m.Severity)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.Severity)))
		i--
		dAtA[i] = 0x32
	}
	n8, err8 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(m.Duration, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.Duration):])
	if err8 != nil {
		return 0, err8
	}
	i -= n8
	i = encodeVarintMetrics(dAtA, i, uint64(n8))
	i--
	dAtA[i] = 0x2a
	{
		size := m.Threshold.Size()
		i -= size
		if _, err := m.Threshold.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMetrics(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Condition) > 0 {
		i -= len(m.Condition)
		copy(dAtA[i:], m.Condition)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.Condition)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MetricName) > 0 {
		i -= len(m.MetricName)
		copy(dAtA[i:], m.MetricName)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.MetricName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Alert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Resolved {
		i--
		if m.Resolved {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	n9, err9 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ResolvedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ResolvedAt):])
	if err9 != nil {
		return 0, err9
	}
	i -= n9
	i = encodeVarintMetrics(dAtA, i, uint64(n9))
	i--
	dAtA[i] = 0x4a
	n10, err10 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.TriggeredAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.TriggeredAt):])
	if err10 != nil {
		return 0, err10
	}
	i -= n10
	i = encodeVarintMetrics(dAtA, i, uint64(n10))
	i--
	dAtA[i] = 0x42
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Severity) > 0 {
		i -= len(m.Severity)
		copy(dAtA[i:], m.Severity)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.Severity)))
		i--
		dAtA[i] = 0x32
	}
	{
		size := m.Threshold.Size()
		i -= size
		if _, err := m.Threshold.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMetrics(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.Value.Size()
		i -= size
		if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMetrics(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.MetricName) > 0 {
		i -= len(m.MetricName)
		copy(dAtA[i:], m.MetricName)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.MetricName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ConfigName) > 0 {
		i -= len(m.ConfigName)
		copy(dAtA[i:], m.ConfigName)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.ConfigName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PerformanceStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PerformanceStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PerformanceStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n11, err11 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastCalled, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastCalled):])
	if err11 != nil {
		return 0, err11
	}
	i -= n11
	i = encodeVarintMetrics(dAtA, i, uint64(n11))
	i--
	dAtA[i] = 0x4a
	if m.ErrorCount != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.ErrorCount))
		i--
		dAtA[i] = 0x40
	}
	if m.MaxDuration != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MaxDuration))))
		i--
		dAtA[i] = 0x39
	}
	if m.MinDuration != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MinDuration))))
		i--
		dAtA[i] = 0x31
	}
	if m.AverageDuration != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AverageDuration))))
		i--
		dAtA[i] = 0x29
	}
	if m.TotalDuration != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TotalDuration))))
		i--
		dAtA[i] = 0x21
	}
	if m.TotalCalls != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.TotalCalls))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Operation) > 0 {
		i -= len(m.Operation)
		copy(dAtA[i:], m.Operation)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.Operation)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Module) > 0 {
		i -= len(m.Module)
		copy(dAtA[i:], m.Module)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.Module)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMetrics(dAtA []byte, offset int, v uint64) int {
	offset -= sovMetrics(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Metric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	l = m.Value.Size()
	n += 1 + l + sovMetrics(uint64(l))
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMetrics(uint64(len(k))) + 1 + len(v) + sovMetrics(uint64(len(v)))
			n += mapEntrySize + 1 + sovMetrics(uint64(mapEntrySize))
		}
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovMetrics(uint64(l))
	if m.Height != 0 {
		n += 1 + sovMetrics(uint64(m.Height))
	}
	return n
}

func (m *Counter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovMetrics(uint64(m.Value))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMetrics(uint64(len(k))) + 1 + len(v) + sovMetrics(uint64(len(v)))
			n += mapEntrySize + 1 + sovMetrics(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Gauge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	l = m.Value.Size()
	n += 1 + l + sovMetrics(uint64(l))
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMetrics(uint64(len(k))) + 1 + len(v) + sovMetrics(uint64(len(v)))
			n += mapEntrySize + 1 + sovMetrics(uint64(mapEntrySize))
		}
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt)
	n += 1 + l + sovMetrics(uint64(l))
	return n
}

func (m *HistogramBucket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.LowerBound.Size()
	n += 1 + l + sovMetrics(uint64(l))
	l = m.UpperBound.Size()
	n += 1 + l + sovMetrics(uint64(l))
	if m.Count != 0 {
		n += 1 + sovMetrics(uint64(m.Count))
	}
	return n
}

func (m *Histogram) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	if len(m.Buckets) > 0 {
		for _, e := range m.Buckets {
			l = e.Size()
			n += 1 + l + sovMetrics(uint64(l))
		}
	}
	l = m.Sum.Size()
	n += 1 + l + sovMetrics(uint64(l))
	if m.Count != 0 {
		n += 1 + sovMetrics(uint64(m.Count))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMetrics(uint64(len(k))) + 1 + len(v) + sovMetrics(uint64(len(v)))
			n += mapEntrySize + 1 + sovMetrics(uint64(mapEntrySize))
		}
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt)
	n += 1 + l + sovMetrics(uint64(l))
	return n
}

func (m *ModuleHealth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	if m.ErrorRate != 0 {
		n += 9
	}
	if m.Latency != 0 {
		n += 9
	}
	l = len(m.LastError)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastErrorAt)
	n += 1 + l + sovMetrics(uint64(l))
	if m.Transactions != 0 {
		n += 1 + sovMetrics(uint64(m.Transactions))
	}
	return n
}

func (m *SystemMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastBlockHeight != 0 {
		n += 1 + sovMetrics(uint64(m.LastBlockHeight))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastBlockTime)
	n += 1 + l + sovMetrics(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.AverageBlockTime)
	n += 1 + l + sovMetrics(uint64(l))
	if m.TransactionsTotal != 0 {
		n += 1 + sovMetrics(uint64(m.TransactionsTotal))
	}
	if len(m.ModuleHealth) > 0 {
		for k, v := range m.ModuleHealth {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMetrics(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMetrics(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMetrics(uint64(mapEntrySize))
		}
	}
	l = m.TotalCollateralValue.Size()
	n += 1 + l + sovMetrics(uint64(l))
	l = m.TotalDebtValue.Size()
	n += 1 + l + sovMetrics(uint64(l))
	l = m.SystemCollateralRatio.Size()
	n += 1 + l + sovMetrics(uint64(l))
	if m.TotalSettlements != 0 {
		n += 1 + sovMetrics(uint64(m.TotalSettlements))
	}
	l = m.TotalSettlementVolume.Size()
	n += 1 + l + sovMetrics(uint64(l))
	if m.ActiveEscrows != 0 {
		n += 1 + sovMetrics(uint64(m.ActiveEscrows))
	}
	if m.ActiveChannels != 0 {
		n += 1 + sovMetrics(uint64(m.ActiveChannels))
	}
	if m.PricesUpdated != 0 {
		n += 1 + sovMetrics(uint64(m.PricesUpdated))
	}
	if m.StalePriceCount != 0 {
		n += 1 + sovMetrics(uint64(m.StalePriceCount))
	}
	if m.CircuitTrips != 0 {
		n += 1 + sovMetrics(uint64(m.CircuitTrips))
	}
	if m.RateLimitHits != 0 {
		n += 2 + sovMetrics(uint64(m.RateLimitHits))
	}
	if m.ComplianceBlocks != 0 {
		n += 2 + sovMetrics(uint64(m.ComplianceBlocks))
	}
	return n
}

func (m *AlertConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	l = len(m.MetricName)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	l = len(m.Condition)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	l = m.Threshold.Size()
	n += 1 + l + sovMetrics(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.Duration)
	n += 1 + l + sovMetrics(uint64(l))
	l = len(m.Severity)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *Alert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	l = len(m.ConfigName)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	l = len(m.MetricName)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	l = m.Value.Size()
	n += 1 + l + sovMetrics(uint64(l))
	l = m.Threshold.Size()
	n += 1 + l + sovMetrics(uint64(l))
	l = len(m.Severity)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.TriggeredAt)
	n += 1 + l + sovMetrics(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ResolvedAt)
	n += 1 + l + sovMetrics(uint64(l))
	if m.Resolved {
		n += 2
	}
	return n
}

func (m *PerformanceStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	l = len(m.Operation)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	if m.TotalCalls != 0 {
		n += 1 + sovMetrics(uint64(m.TotalCalls))
	}
	if m.TotalDuration != 0 {
		n += 9
	}
	if m.AverageDuration != 0 {
		n += 9
	}
	if m.MinDuration != 0 {
		n += 9
	}
	if m.MaxDuration != 0 {
		n += 9
	}
	if m.ErrorCount != 0 {
		n += 1 + sovMetrics(uint64(m.ErrorCount))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastCalled)
	n += 1 + l + sovMetrics(uint64(l))
	return n
}

func sovMetrics(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMetrics(x uint64) (n int) {
	return sovMetrics(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Metric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = MetricType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetrics
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetrics
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetrics
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMetrics
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetrics
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMetrics
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthMetrics
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetrics(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMetrics
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetrics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetrics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Counter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Counter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Counter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetrics
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetrics
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetrics
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMetrics
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetrics
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMetrics
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthMetrics
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetrics(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMetrics
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetrics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetrics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Gauge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Gauge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Gauge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetrics
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetrics
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetrics
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMetrics
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetrics
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMetrics
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthMetrics
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetrics(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMetrics
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetrics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetrics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HistogramBucket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HistogramBucket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HistogramBucket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowerBound", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LowerBound.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperBound", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UpperBound.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetrics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetrics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Histogram) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Histogram: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Histogram: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buckets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buckets = append(m.Buckets, HistogramBucket{})
			if err := m.Buckets[len(m.Buckets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Sum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetrics
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetrics
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetrics
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMetrics
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetrics
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMetrics
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthMetrics
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetrics(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMetrics
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetrics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetrics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleHealth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleHealth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleHealth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ErrorRate = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latency", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Latency = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastErrorAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastErrorAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
			}
			m.Transactions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Transactions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetrics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetrics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SystemMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SystemMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBlockHeight", wireType)
			}
			m.LastBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBlockTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastBlockTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AverageBlockTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(&m.AverageBlockTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionsTotal", wireType)
			}
			m.TransactionsTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionsTotal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleHealth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModuleHealth == nil {
				m.ModuleHealth = make(map[string]*ModuleHealth)
			}
			var mapkey string
			var mapvalue *ModuleHealth
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetrics
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetrics
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetrics
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMetrics
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetrics
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMetrics
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthMetrics
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ModuleHealth{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetrics(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMetrics
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ModuleHealth[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCollateralValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalCollateralValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDebtValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalDebtValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemCollateralRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SystemCollateralRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSettlements", wireType)
			}
			m.TotalSettlements = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSettlements |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSettlementVolume", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalSettlementVolume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveEscrows", wireType)
			}
			m.ActiveEscrows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveEscrows |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveChannels", wireType)
			}
			m.ActiveChannels = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveChannels |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PricesUpdated", wireType)
			}
			m.PricesUpdated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PricesUpdated |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StalePriceCount", wireType)
			}
			m.StalePriceCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StalePriceCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CircuitTrips", wireType)
			}
			m.CircuitTrips = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CircuitTrips |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimitHits", wireType)
			}
			m.RateLimitHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RateLimitHits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComplianceBlocks", wireType)
			}
			m.ComplianceBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComplianceBlocks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetrics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetrics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Condition = AlertCondition(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Threshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(&m.Duration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Severity = AlertSeverity(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMetrics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetrics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Alert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Alert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Alert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Threshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Severity = AlertSeverity(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggeredAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.TriggeredAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ResolvedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolved", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Resolved = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMetrics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetrics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PerformanceStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PerformanceStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PerformanceStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCalls", wireType)
			}
			m.TotalCalls = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCalls |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDuration", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TotalDuration = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AverageDuration", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AverageDuration = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDuration", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MinDuration = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDuration", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MaxDuration = float64(math.Float64frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCount", wireType)
			}
			m.ErrorCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCalled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastCalled, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetrics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetrics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetrics(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMetrics
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMetrics
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMetrics
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMetrics        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetrics          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMetrics = fmt.Errorf("proto: unexpected end of group")
)
