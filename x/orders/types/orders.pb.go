// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: stateset/core/orders/orders.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/types"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params defines configurable parameters for the orders module.
type Params struct {
	DefaultOrderExpiration    int64                                   `protobuf:"varint,1,opt,name=default_order_expiration,json=defaultOrderExpiration,proto3" json:"default_order_expiration,omitempty"`
	DefaultEscrowExpiration   int64                                   `protobuf:"varint,2,opt,name=default_escrow_expiration,json=defaultEscrowExpiration,proto3" json:"default_escrow_expiration,omitempty"`
	DisputeWindow             int64                                   `protobuf:"varint,3,opt,name=dispute_window,json=disputeWindow,proto3" json:"dispute_window,omitempty"`
	MinOrderAmount            github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,4,opt,name=min_order_amount,json=minOrderAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"min_order_amount"`
	MaxOrderAmount            github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,5,opt,name=max_order_amount,json=maxOrderAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"max_order_amount"`
	DefaultFeeRateBps         uint32                                  `protobuf:"varint,6,opt,name=default_fee_rate_bps,json=defaultFeeRateBps,proto3" json:"default_fee_rate_bps,omitempty"`
	StablecoinDenom           string                                  `protobuf:"bytes,7,opt,name=stablecoin_denom,json=stablecoinDenom,proto3" json:"stablecoin_denom,omitempty"`
	AutoCompleteAfterDelivery bool                                    `protobuf:"varint,8,opt,name=auto_complete_after_delivery,json=autoCompleteAfterDelivery,proto3" json:"auto_complete_after_delivery,omitempty"`
	AutoCompleteWindow        int64                                   `protobuf:"varint,9,opt,name=auto_complete_window,json=autoCompleteWindow,proto3" json:"auto_complete_window,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b255b0366c5e824, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetDefaultOrderExpiration() int64 {
	if m != nil {
		return m.DefaultOrderExpiration
	}
	return 0
}

func (m *Params) GetDefaultEscrowExpiration() int64 {
	if m != nil {
		return m.DefaultEscrowExpiration
	}
	return 0
}

func (m *Params) GetDisputeWindow() int64 {
	if m != nil {
		return m.DisputeWindow
	}
	return 0
}

func (m *Params) GetDefaultFeeRateBps() uint32 {
	if m != nil {
		return m.DefaultFeeRateBps
	}
	return 0
}

func (m *Params) GetStablecoinDenom() string {
	if m != nil {
		return m.StablecoinDenom
	}
	return ""
}

func (m *Params) GetAutoCompleteAfterDelivery() bool {
	if m != nil {
		return m.AutoCompleteAfterDelivery
	}
	return false
}

func (m *Params) GetAutoCompleteWindow() int64 {
	if m != nil {
		return m.AutoCompleteWindow
	}
	return 0
}

// Order represents a customer order in the Stateset commerce system.
type Order struct {
	Id             uint64                                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Customer       string                                  `protobuf:"bytes,2,opt,name=customer,proto3" json:"customer,omitempty"`
	Merchant       string                                  `protobuf:"bytes,3,opt,name=merchant,proto3" json:"merchant,omitempty"`
	Status         string                                  `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`
	Items          []OrderItem                             `protobuf:"bytes,5,rep,name=items,proto3" json:"items"`
	Subtotal       github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,6,opt,name=subtotal,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"subtotal"`
	ShippingCost   github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,7,opt,name=shipping_cost,json=shippingCost,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"shipping_cost"`
	TaxAmount      github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,8,opt,name=tax_amount,json=taxAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"tax_amount"`
	DiscountAmount github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,9,opt,name=discount_amount,json=discountAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"discount_amount"`
	TotalAmount    github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,10,opt,name=total_amount,json=totalAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"total_amount"`
	PaymentInfo    PaymentInfo                             `protobuf:"bytes,11,opt,name=payment_info,json=paymentInfo,proto3" json:"payment_info"`
	ShippingInfo   ShippingInfo                            `protobuf:"bytes,12,opt,name=shipping_info,json=shippingInfo,proto3" json:"shipping_info"`
	Metadata       string                                  `protobuf:"bytes,13,opt,name=metadata,proto3" json:"metadata,omitempty"`
	CreatedAt      time.Time                               `protobuf:"bytes,14,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at"`
	UpdatedAt      time.Time                               `protobuf:"bytes,15,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at"`
	PaidAt         time.Time                               `protobuf:"bytes,16,opt,name=paid_at,json=paidAt,proto3,stdtime" json:"paid_at"`
	ShippedAt      time.Time                               `protobuf:"bytes,17,opt,name=shipped_at,json=shippedAt,proto3,stdtime" json:"shipped_at"`
	DeliveredAt    time.Time                               `protobuf:"bytes,18,opt,name=delivered_at,json=deliveredAt,proto3,stdtime" json:"delivered_at"`
	CompletedAt    time.Time                               `protobuf:"bytes,19,opt,name=completed_at,json=completedAt,proto3,stdtime" json:"completed_at"`
	ExpiresAt      time.Time                               `protobuf:"bytes,20,opt,name=expires_at,json=expiresAt,proto3,stdtime" json:"expires_at"`
	SettlementId   uint64                                  `protobuf:"varint,21,opt,name=settlement_id,json=settlementId,proto3" json:"settlement_id,omitempty"`
	DisputeId      uint64                                  `protobuf:"varint,22,opt,name=dispute_id,json=disputeId,proto3" json:"dispute_id,omitempty"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b255b0366c5e824, []int{1}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Order) GetCustomer() string {
	if m != nil {
		return m.Customer
	}
	return ""
}

func (m *Order) GetMerchant() string {
	if m != nil {
		return m.Merchant
	}
	return ""
}

func (m *Order) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Order) GetItems() []OrderItem {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *Order) GetPaymentInfo() PaymentInfo {
	if m != nil {
		return m.PaymentInfo
	}
	return PaymentInfo{}
}

func (m *Order) GetShippingInfo() ShippingInfo {
	if m != nil {
		return m.ShippingInfo
	}
	return ShippingInfo{}
}

func (m *Order) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Order) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

func (m *Order) GetUpdatedAt() time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return time.Time{}
}

func (m *Order) GetPaidAt() time.Time {
	if m != nil {
		return m.PaidAt
	}
	return time.Time{}
}

func (m *Order) GetShippedAt() time.Time {
	if m != nil {
		return m.ShippedAt
	}
	return time.Time{}
}

func (m *Order) GetDeliveredAt() time.Time {
	if m != nil {
		return m.DeliveredAt
	}
	return time.Time{}
}

func (m *Order) GetCompletedAt() time.Time {
	if m != nil {
		return m.CompletedAt
	}
	return time.Time{}
}

func (m *Order) GetExpiresAt() time.Time {
	if m != nil {
		return m.ExpiresAt
	}
	return time.Time{}
}

func (m *Order) GetSettlementId() uint64 {
	if m != nil {
		return m.SettlementId
	}
	return 0
}

func (m *Order) GetDisputeId() uint64 {
	if m != nil {
		return m.DisputeId
	}
	return 0
}

// OrderItem represents an individual item within an order.
type OrderItem struct {
	Id          string                                  `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	ProductId   string                                  `protobuf:"bytes,2,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	ProductName string                                  `protobuf:"bytes,3,opt,name=product_name,json=productName,proto3" json:"product_name,omitempty"`
	Quantity    uint64                                  `protobuf:"varint,4,opt,name=quantity,proto3" json:"quantity,omitempty"`
	UnitPrice   github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,5,opt,name=unit_price,json=unitPrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"unit_price"`
	TotalPrice  github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,6,opt,name=total_price,json=totalPrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"total_price"`
	Variant     string                                  `protobuf:"bytes,7,opt,name=variant,proto3" json:"variant,omitempty"`
	Metadata    string                                  `protobuf:"bytes,8,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *OrderItem) Reset()         { *m = OrderItem{} }
func (m *OrderItem) String() string { return proto.CompactTextString(m) }
func (*OrderItem) ProtoMessage()    {}
func (*OrderItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b255b0366c5e824, []int{2}
}
func (m *OrderItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderItem.Merge(m, src)
}
func (m *OrderItem) XXX_Size() int {
	return m.Size()
}
func (m *OrderItem) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderItem.DiscardUnknown(m)
}

var xxx_messageInfo_OrderItem proto.InternalMessageInfo

func (m *OrderItem) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *OrderItem) GetProductId() string {
	if m != nil {
		return m.ProductId
	}
	return ""
}

func (m *OrderItem) GetProductName() string {
	if m != nil {
		return m.ProductName
	}
	return ""
}

func (m *OrderItem) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *OrderItem) GetVariant() string {
	if m != nil {
		return m.Variant
	}
	return ""
}

func (m *OrderItem) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

// PaymentInfo contains payment details for an order.
type PaymentInfo struct {
	Status         string                                  `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	Method         string                                  `protobuf:"bytes,2,opt,name=method,proto3" json:"method,omitempty"`
	TransactionId  string                                  `protobuf:"bytes,3,opt,name=transaction_id,json=transactionId,proto3" json:"transaction_id,omitempty"`
	SettlementId   uint64                                  `protobuf:"varint,4,opt,name=settlement_id,json=settlementId,proto3" json:"settlement_id,omitempty"`
	EscrowId       uint64                                  `protobuf:"varint,5,opt,name=escrow_id,json=escrowId,proto3" json:"escrow_id,omitempty"`
	PaidAmount     github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,6,opt,name=paid_amount,json=paidAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"paid_amount"`
	RefundedAmount github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,7,opt,name=refunded_amount,json=refundedAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"refunded_amount"`
	FeeAmount      github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,8,opt,name=fee_amount,json=feeAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"fee_amount"`
	PaidAt         time.Time                               `protobuf:"bytes,9,opt,name=paid_at,json=paidAt,proto3,stdtime" json:"paid_at"`
}

func (m *PaymentInfo) Reset()         { *m = PaymentInfo{} }
func (m *PaymentInfo) String() string { return proto.CompactTextString(m) }
func (*PaymentInfo) ProtoMessage()    {}
func (*PaymentInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b255b0366c5e824, []int{3}
}
func (m *PaymentInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PaymentInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PaymentInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PaymentInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaymentInfo.Merge(m, src)
}
func (m *PaymentInfo) XXX_Size() int {
	return m.Size()
}
func (m *PaymentInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PaymentInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PaymentInfo proto.InternalMessageInfo

func (m *PaymentInfo) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *PaymentInfo) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *PaymentInfo) GetTransactionId() string {
	if m != nil {
		return m.TransactionId
	}
	return ""
}

func (m *PaymentInfo) GetSettlementId() uint64 {
	if m != nil {
		return m.SettlementId
	}
	return 0
}

func (m *PaymentInfo) GetEscrowId() uint64 {
	if m != nil {
		return m.EscrowId
	}
	return 0
}

func (m *PaymentInfo) GetPaidAt() time.Time {
	if m != nil {
		return m.PaidAt
	}
	return time.Time{}
}

// ShippingInfo contains shipping details for an order.
type ShippingInfo struct {
	Address           Address   `protobuf:"bytes,1,opt,name=address,proto3" json:"address"`
	Method            string    `protobuf:"bytes,2,opt,name=method,proto3" json:"method,omitempty"`
	Carrier           string    `protobuf:"bytes,3,opt,name=carrier,proto3" json:"carrier,omitempty"`
	TrackingNumber    string    `protobuf:"bytes,4,opt,name=tracking_number,json=trackingNumber,proto3" json:"tracking_number,omitempty"`
	EstimatedDelivery time.Time `protobuf:"bytes,5,opt,name=estimated_delivery,json=estimatedDelivery,proto3,stdtime" json:"estimated_delivery"`
	ActualDelivery    time.Time `protobuf:"bytes,6,opt,name=actual_delivery,json=actualDelivery,proto3,stdtime" json:"actual_delivery"`
}

func (m *ShippingInfo) Reset()         { *m = ShippingInfo{} }
func (m *ShippingInfo) String() string { return proto.CompactTextString(m) }
func (*ShippingInfo) ProtoMessage()    {}
func (*ShippingInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b255b0366c5e824, []int{4}
}
func (m *ShippingInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShippingInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShippingInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShippingInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShippingInfo.Merge(m, src)
}
func (m *ShippingInfo) XXX_Size() int {
	return m.Size()
}
func (m *ShippingInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ShippingInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ShippingInfo proto.InternalMessageInfo

func (m *ShippingInfo) GetAddress() Address {
	if m != nil {
		return m.Address
	}
	return Address{}
}

func (m *ShippingInfo) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *ShippingInfo) GetCarrier() string {
	if m != nil {
		return m.Carrier
	}
	return ""
}

func (m *ShippingInfo) GetTrackingNumber() string {
	if m != nil {
		return m.TrackingNumber
	}
	return ""
}

func (m *ShippingInfo) GetEstimatedDelivery() time.Time {
	if m != nil {
		return m.EstimatedDelivery
	}
	return time.Time{}
}

func (m *ShippingInfo) GetActualDelivery() time.Time {
	if m != nil {
		return m.ActualDelivery
	}
	return time.Time{}
}

// Address represents a shipping or billing address.
type Address struct {
	Line1      string `protobuf:"bytes,1,opt,name=line1,proto3" json:"line1,omitempty"`
	Line2      string `protobuf:"bytes,2,opt,name=line2,proto3" json:"line2,omitempty"`
	City       string `protobuf:"bytes,3,opt,name=city,proto3" json:"city,omitempty"`
	State      string `protobuf:"bytes,4,opt,name=state,proto3" json:"state,omitempty"`
	PostalCode string `protobuf:"bytes,5,opt,name=postal_code,json=postalCode,proto3" json:"postal_code,omitempty"`
	Country    string `protobuf:"bytes,6,opt,name=country,proto3" json:"country,omitempty"`
	Name       string `protobuf:"bytes,7,opt,name=name,proto3" json:"name,omitempty"`
	Phone      string `protobuf:"bytes,8,opt,name=phone,proto3" json:"phone,omitempty"`
}

func (m *Address) Reset()         { *m = Address{} }
func (m *Address) String() string { return proto.CompactTextString(m) }
func (*Address) ProtoMessage()    {}
func (*Address) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b255b0366c5e824, []int{5}
}
func (m *Address) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Address) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Address.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Address) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Address.Merge(m, src)
}
func (m *Address) XXX_Size() int {
	return m.Size()
}
func (m *Address) XXX_DiscardUnknown() {
	xxx_messageInfo_Address.DiscardUnknown(m)
}

var xxx_messageInfo_Address proto.InternalMessageInfo

func (m *Address) GetLine1() string {
	if m != nil {
		return m.Line1
	}
	return ""
}

func (m *Address) GetLine2() string {
	if m != nil {
		return m.Line2
	}
	return ""
}

func (m *Address) GetCity() string {
	if m != nil {
		return m.City
	}
	return ""
}

func (m *Address) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *Address) GetPostalCode() string {
	if m != nil {
		return m.PostalCode
	}
	return ""
}

func (m *Address) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func (m *Address) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Address) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

// Dispute represents a dispute on an order.
type Dispute struct {
	Id          uint64                                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	OrderId     uint64                                  `protobuf:"varint,2,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	Customer    string                                  `protobuf:"bytes,3,opt,name=customer,proto3" json:"customer,omitempty"`
	Merchant    string                                  `protobuf:"bytes,4,opt,name=merchant,proto3" json:"merchant,omitempty"`
	Reason      string                                  `protobuf:"bytes,5,opt,name=reason,proto3" json:"reason,omitempty"`
	Description string                                  `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	Evidence    []string                                `protobuf:"bytes,7,rep,name=evidence,proto3" json:"evidence,omitempty"`
	Status      string                                  `protobuf:"bytes,8,opt,name=status,proto3" json:"status,omitempty"`
	Resolution  string                                  `protobuf:"bytes,9,opt,name=resolution,proto3" json:"resolution,omitempty"`
	ResolvedBy  string                                  `protobuf:"bytes,10,opt,name=resolved_by,json=resolvedBy,proto3" json:"resolved_by,omitempty"`
	CreatedAt   time.Time                               `protobuf:"bytes,11,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at"`
	UpdatedAt   time.Time                               `protobuf:"bytes,12,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at"`
	ResolvedAt  time.Time                               `protobuf:"bytes,13,opt,name=resolved_at,json=resolvedAt,proto3,stdtime" json:"resolved_at"`
	Amount      github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,14,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"amount"`
}

func (m *Dispute) Reset()         { *m = Dispute{} }
func (m *Dispute) String() string { return proto.CompactTextString(m) }
func (*Dispute) ProtoMessage()    {}
func (*Dispute) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b255b0366c5e824, []int{6}
}
func (m *Dispute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dispute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dispute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Dispute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dispute.Merge(m, src)
}
func (m *Dispute) XXX_Size() int {
	return m.Size()
}
func (m *Dispute) XXX_DiscardUnknown() {
	xxx_messageInfo_Dispute.DiscardUnknown(m)
}

var xxx_messageInfo_Dispute proto.InternalMessageInfo

func (m *Dispute) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Dispute) GetOrderId() uint64 {
	if m != nil {
		return m.OrderId
	}
	return 0
}

func (m *Dispute) GetCustomer() string {
	if m != nil {
		return m.Customer
	}
	return ""
}

func (m *Dispute) GetMerchant() string {
	if m != nil {
		return m.Merchant
	}
	return ""
}

func (m *Dispute) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *Dispute) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Dispute) GetEvidence() []string {
	if m != nil {
		return m.Evidence
	}
	return nil
}

func (m *Dispute) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Dispute) GetResolution() string {
	if m != nil {
		return m.Resolution
	}
	return ""
}

func (m *Dispute) GetResolvedBy() string {
	if m != nil {
		return m.ResolvedBy
	}
	return ""
}

func (m *Dispute) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

func (m *Dispute) GetUpdatedAt() time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return time.Time{}
}

func (m *Dispute) GetResolvedAt() time.Time {
	if m != nil {
		return m.ResolvedAt
	}
	return time.Time{}
}

func init() {
	proto.RegisterType((*Params)(nil), "stateset.core.orders.Params")
	proto.RegisterType((*Order)(nil), "stateset.core.orders.Order")
	proto.RegisterType((*OrderItem)(nil), "stateset.core.orders.OrderItem")
	proto.RegisterType((*PaymentInfo)(nil), "stateset.core.orders.PaymentInfo")
	proto.RegisterType((*ShippingInfo)(nil), "stateset.core.orders.ShippingInfo")
	proto.RegisterType((*Address)(nil), "stateset.core.orders.Address")
	proto.RegisterType((*Dispute)(nil), "stateset.core.orders.Dispute")
}

func init() { proto.RegisterFile("stateset/core/orders/orders.proto", fileDescriptor_0b255b0366c5e824) }

var fileDescriptor_0b255b0366c5e824 = []byte{
	// 1412 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xc1, 0x6e, 0x1b, 0x37,
	0x13, 0xb6, 0x6c, 0x59, 0xd6, 0x8e, 0x64, 0x39, 0xe1, 0xef, 0xdf, 0xff, 0xda, 0x7f, 0x23, 0x2b,
	0x2a, 0x8a, 0xb8, 0x87, 0x4a, 0x8d, 0x7b, 0x29, 0x5a, 0x14, 0x85, 0xec, 0xa4, 0x85, 0x0a, 0x24,
	0x0d, 0x36, 0x05, 0x0a, 0xf4, 0xb2, 0xa0, 0x96, 0x94, 0x4d, 0x44, 0xbb, 0xdc, 0x2e, 0xb9, 0x8e,
	0xfd, 0x04, 0xbd, 0xe6, 0x41, 0x7a, 0xea, 0x33, 0xf4, 0x90, 0x43, 0x0f, 0x39, 0x16, 0x3d, 0xa4,
	0x41, 0xf2, 0x22, 0x05, 0x87, 0xdc, 0xf5, 0xaa, 0x71, 0x8b, 0xaa, 0x90, 0x4f, 0xde, 0x19, 0xce,
	0x7c, 0x43, 0x0e, 0x87, 0xdf, 0x8c, 0x05, 0xb7, 0x95, 0xa6, 0x9a, 0x2b, 0xae, 0x87, 0x91, 0xcc,
	0xf8, 0x50, 0x66, 0x8c, 0x67, 0xca, 0xfd, 0x19, 0xa4, 0x99, 0xd4, 0x92, 0x6c, 0x17, 0x26, 0x03,
	0x63, 0x32, 0xb0, 0x6b, 0x7b, 0xdb, 0x27, 0xf2, 0x44, 0xa2, 0xc1, 0xd0, 0x7c, 0x59, 0xdb, 0xbd,
	0x6e, 0x24, 0x55, 0x2c, 0xd5, 0x70, 0x42, 0x15, 0x1f, 0x9e, 0xdd, 0x9d, 0x70, 0x4d, 0xef, 0x0e,
	0x23, 0x29, 0x12, 0xb7, 0xbe, 0x7f, 0x22, 0xe5, 0xc9, 0x8c, 0x0f, 0x51, 0x9a, 0xe4, 0xd3, 0xa1,
	0x16, 0x31, 0x57, 0x9a, 0xc6, 0xa9, 0x35, 0xe8, 0xbf, 0xaa, 0x43, 0xe3, 0x11, 0xcd, 0x68, 0xac,
	0xc8, 0xc7, 0xe0, 0x33, 0x3e, 0xa5, 0xf9, 0x4c, 0x87, 0x18, 0x33, 0xe4, 0xe7, 0xa9, 0xc8, 0xa8,
	0x16, 0x32, 0xf1, 0x6b, 0xbd, 0xda, 0xc1, 0x5a, 0xb0, 0xe3, 0xd6, 0xbf, 0x36, 0xcb, 0xf7, 0xcb,
	0x55, 0xf2, 0x09, 0xec, 0x16, 0x9e, 0x5c, 0x45, 0x99, 0x7c, 0x5a, 0x75, 0x5d, 0x45, 0xd7, 0xff,
	0x39, 0x83, 0xfb, 0xb8, 0x5e, 0xf1, 0x7d, 0x0f, 0x3a, 0x4c, 0xa8, 0x34, 0xd7, 0x3c, 0x7c, 0x2a,
	0x12, 0x26, 0x9f, 0xfa, 0x6b, 0xe8, 0xb0, 0xe9, 0xb4, 0xdf, 0xa2, 0x92, 0x68, 0xb8, 0x11, 0x8b,
	0xc4, 0x6d, 0x8c, 0xc6, 0x32, 0x4f, 0xb4, 0x5f, 0xef, 0xd5, 0x0e, 0x5a, 0x87, 0xbb, 0x03, 0x9b,
	0x83, 0x81, 0xc9, 0xc1, 0xc0, 0xe5, 0x60, 0x70, 0x2c, 0x45, 0x72, 0x34, 0x7c, 0xfe, 0x72, 0x7f,
	0xe5, 0xb7, 0x97, 0xfb, 0x77, 0x4e, 0x84, 0x3e, 0xcd, 0x27, 0x83, 0x48, 0xc6, 0x43, 0x97, 0x30,
	0xfb, 0xe7, 0x03, 0xc5, 0x9e, 0x0c, 0xf5, 0x45, 0xca, 0x15, 0x3a, 0x04, 0x9d, 0x58, 0x24, 0x78,
	0xb8, 0x11, 0x46, 0xc0, 0xa8, 0xf4, 0x7c, 0x3e, 0xea, 0xfa, 0x35, 0x44, 0xa5, 0xe7, 0xd5, 0xa8,
	0x43, 0xd8, 0x2e, 0xd2, 0x39, 0xe5, 0x3c, 0xcc, 0xa8, 0xe6, 0xe1, 0x24, 0x55, 0x7e, 0xa3, 0x57,
	0x3b, 0xd8, 0x0c, 0x6e, 0xba, 0xb5, 0x2f, 0x38, 0x0f, 0xa8, 0xe6, 0x47, 0xa9, 0x22, 0xef, 0xc3,
	0x0d, 0xa5, 0xe9, 0x64, 0xc6, 0xcd, 0xcd, 0x87, 0x8c, 0x27, 0x32, 0xf6, 0x37, 0x7a, 0xb5, 0x03,
	0x2f, 0xd8, 0xba, 0xd4, 0xdf, 0x33, 0x6a, 0xf2, 0x39, 0xbc, 0x43, 0x73, 0x2d, 0xc3, 0x48, 0xc6,
	0xe9, 0x8c, 0x6b, 0x1e, 0xd2, 0xa9, 0xe6, 0x59, 0xc8, 0xf8, 0x4c, 0x9c, 0xf1, 0xec, 0xc2, 0x6f,
	0xf6, 0x6a, 0x07, 0xcd, 0x60, 0xd7, 0xd8, 0x1c, 0x3b, 0x93, 0x91, 0xb1, 0xb8, 0xe7, 0x0c, 0xc8,
	0x87, 0xb0, 0x3d, 0x0f, 0xe0, 0x6e, 0xcd, 0xc3, 0x5b, 0x23, 0x55, 0x47, 0x7b, 0x75, 0xfd, 0x1f,
	0x5b, 0xb0, 0x8e, 0xc7, 0x23, 0x1d, 0x58, 0x15, 0x0c, 0x6b, 0xa9, 0x1e, 0xac, 0x0a, 0x46, 0xf6,
	0xa0, 0x19, 0xe5, 0x4a, 0xcb, 0x98, 0x67, 0x58, 0x26, 0x5e, 0x50, 0xca, 0x66, 0x2d, 0xe6, 0x59,
	0x74, 0x4a, 0x13, 0x8d, 0x15, 0xe1, 0x05, 0xa5, 0x4c, 0x76, 0xa0, 0x61, 0xde, 0x48, 0xae, 0xb0,
	0x04, 0xbc, 0xc0, 0x49, 0xe4, 0x53, 0x58, 0x17, 0x9a, 0xc7, 0xca, 0x5f, 0xef, 0xad, 0x1d, 0xb4,
	0x0e, 0xf7, 0x07, 0x57, 0xbd, 0xa4, 0x01, 0xee, 0x65, 0xac, 0x79, 0x7c, 0x54, 0x37, 0x37, 0x15,
	0x58, 0x1f, 0x32, 0x85, 0xa6, 0xca, 0x27, 0x5a, 0x6a, 0x3a, 0xc3, 0x4c, 0x2f, 0xf7, 0x8e, 0x4b,
	0x6c, 0x22, 0x61, 0x53, 0x9d, 0x8a, 0x34, 0x15, 0xc9, 0x49, 0x18, 0x49, 0xa5, 0xf1, 0xa6, 0x96,
	0x1b, 0xac, 0x5d, 0x04, 0x38, 0x96, 0x4a, 0x13, 0x01, 0xa0, 0xe9, 0x79, 0x51, 0xbe, 0xcd, 0xa5,
	0x47, 0xf3, 0x34, 0x3d, 0x77, 0x95, 0xab, 0x60, 0x8b, 0x09, 0x15, 0x99, 0xef, 0x22, 0x9e, 0xb7,
	0xfc, 0xe7, 0x52, 0x84, 0x70, 0x41, 0x63, 0x68, 0x63, 0x66, 0x8b, 0x88, 0xb0, 0xf4, 0x88, 0x2d,
	0xc4, 0x77, 0xe1, 0xbe, 0x82, 0x76, 0x4a, 0x2f, 0x62, 0x9e, 0xe8, 0x50, 0x24, 0x53, 0xe9, 0xb7,
	0x30, 0xdc, 0xed, 0xab, 0x6b, 0xed, 0x91, 0xb5, 0x1c, 0x27, 0x53, 0xe9, 0xaa, 0xad, 0x95, 0x5e,
	0xaa, 0xc8, 0x83, 0x4a, 0x2d, 0x20, 0x58, 0x1b, 0xc1, 0xfa, 0x57, 0x83, 0x3d, 0x76, 0xa6, 0x15,
	0xb4, 0xf2, 0xa6, 0x11, 0x0e, 0xdf, 0x8c, 0xa6, 0x8c, 0x6a, 0xea, 0x6f, 0x16, 0x6f, 0xc6, 0xca,
	0xe4, 0x18, 0x20, 0xca, 0x38, 0xd5, 0x9c, 0x85, 0x54, 0xfb, 0x1d, 0x8c, 0xb3, 0x37, 0xb0, 0xed,
	0x61, 0x50, 0xb4, 0x87, 0xc1, 0x37, 0x45, 0x7b, 0x38, 0x6a, 0x1a, 0xfc, 0x67, 0xbf, 0xef, 0xd7,
	0x02, 0xcf, 0xf9, 0x8d, 0xb4, 0x01, 0xc9, 0x53, 0x56, 0x80, 0x6c, 0x2d, 0x02, 0xe2, 0xfc, 0x46,
	0x9a, 0x7c, 0x06, 0x1b, 0x29, 0x15, 0x88, 0x70, 0x63, 0x01, 0x84, 0x86, 0x71, 0xb2, 0x7b, 0xc0,
	0x43, 0xdb, 0x3d, 0xdc, 0x5c, 0x64, 0x0f, 0xce, 0x6f, 0xa4, 0xc9, 0x97, 0xd0, 0x76, 0x94, 0x67,
	0x61, 0xc8, 0x02, 0x30, 0xad, 0xd2, 0xd3, 0x02, 0x15, 0x4c, 0x88, 0x40, 0xff, 0x59, 0x04, 0xa8,
	0xf4, 0xb4, 0xc7, 0xc2, 0xa6, 0xc9, 0x95, 0x81, 0xd9, 0x5e, 0xe4, 0x58, 0xce, 0x6f, 0xa4, 0xc9,
	0xbb, 0xb0, 0xa9, 0xb8, 0xd6, 0x33, 0x6e, 0xcb, 0x93, 0xf9, 0xff, 0x45, 0xae, 0x6d, 0x5f, 0x2a,
	0xc7, 0x8c, 0xdc, 0x02, 0x28, 0x3a, 0xae, 0x60, 0xfe, 0x0e, 0x5a, 0x78, 0x4e, 0x33, 0x66, 0xfd,
	0x1f, 0xd6, 0xc0, 0x2b, 0x29, 0xb2, 0x42, 0xd9, 0x1e, 0x52, 0xf6, 0x2d, 0x80, 0x34, 0x93, 0x2c,
	0x8f, 0x10, 0xde, 0x92, 0xb6, 0xe7, 0x34, 0x63, 0x46, 0x6e, 0x43, 0xbb, 0x58, 0x4e, 0x68, 0xcc,
	0x1d, 0x73, 0xb7, 0x9c, 0xee, 0x21, 0x8d, 0xb9, 0x29, 0xd2, 0xef, 0x73, 0x9a, 0x68, 0xa1, 0x2f,
	0x90, 0xbe, 0xeb, 0x41, 0x29, 0x1b, 0xaa, 0xca, 0x13, 0xa1, 0xc3, 0x34, 0x13, 0x11, 0xbf, 0x86,
	0x4e, 0xeb, 0x19, 0xf4, 0x47, 0x06, 0x9c, 0x3c, 0x01, 0xfb, 0xaa, 0x5d, 0xac, 0xe5, 0x33, 0x3e,
	0x20, 0xbc, 0x0d, 0xe6, 0xc3, 0xc6, 0x19, 0xcd, 0x84, 0xe9, 0x65, 0xb6, 0x2f, 0x17, 0xe2, 0xdc,
	0x93, 0x6d, 0xce, 0x3f, 0xd9, 0xfe, 0x4f, 0x75, 0x68, 0x55, 0x08, 0xa4, 0xd2, 0xf6, 0x6a, 0x73,
	0x6d, 0x6f, 0x07, 0x1a, 0x31, 0xd7, 0xa7, 0xb2, 0xb8, 0x0f, 0x27, 0x99, 0xd1, 0x4a, 0x67, 0x34,
	0x51, 0x34, 0x32, 0x93, 0x96, 0xb9, 0x2f, 0x7b, 0x1d, 0x9b, 0x15, 0xed, 0x98, 0xbd, 0x5d, 0x34,
	0xf5, 0x2b, 0x8a, 0xe6, 0xff, 0xe0, 0xb9, 0xd1, 0x4e, 0x30, 0xbc, 0x98, 0x7a, 0xd0, 0xb4, 0x8a,
	0x31, 0x33, 0xb9, 0xb4, 0x2f, 0xda, 0x12, 0xf0, 0x35, 0xe4, 0x12, 0xdf, 0x7e, 0xd9, 0x63, 0x32,
	0x3e, 0xcd, 0x13, 0xc6, 0xcb, 0x80, 0xcb, 0xef, 0xa0, 0x9d, 0x22, 0x84, 0x0b, 0x2a, 0x00, 0xcc,
	0x28, 0x76, 0x7d, 0x3d, 0x74, 0xca, 0xb9, 0x0b, 0x55, 0xa1, 0x47, 0x6f, 0x71, 0x7a, 0xec, 0xff,
	0xb2, 0x0a, 0xed, 0x6a, 0xa3, 0x30, 0x78, 0x94, 0xb1, 0x8c, 0x2b, 0x5b, 0x36, 0xad, 0xc3, 0x5b,
	0x57, 0x77, 0x97, 0x91, 0x35, 0x72, 0x8d, 0xa5, 0xf0, 0xf9, 0xcb, 0xe2, 0xf2, 0x61, 0x23, 0xa2,
	0x59, 0x26, 0x78, 0xe6, 0xaa, 0xaa, 0x10, 0xc9, 0x1d, 0xd8, 0xd2, 0x19, 0x8d, 0x9e, 0x98, 0xa6,
	0x96, 0xe4, 0xf1, 0x84, 0x67, 0x6e, 0x4c, 0xeb, 0x14, 0xea, 0x87, 0xa8, 0x25, 0x8f, 0x81, 0x70,
	0xa5, 0x45, 0x8c, 0xfd, 0xa4, 0x9c, 0x40, 0xd7, 0x17, 0x38, 0xf4, 0xcd, 0xd2, 0xbf, 0x9c, 0x4f,
	0x1f, 0xc0, 0x16, 0x8d, 0x74, 0x4e, 0x67, 0x97, 0x88, 0x8d, 0x05, 0x10, 0x3b, 0xd6, 0xb9, 0x80,
	0xeb, 0xff, 0x5c, 0x83, 0x0d, 0x97, 0x19, 0xb2, 0x0d, 0xeb, 0x33, 0x91, 0xf0, 0xbb, 0xee, 0xf9,
	0x59, 0xa1, 0xd0, 0x1e, 0xba, 0xfc, 0x58, 0x81, 0x10, 0xa8, 0x47, 0x86, 0xe1, 0x6c, 0x6e, 0xf0,
	0xdb, 0x58, 0x62, 0xe6, 0x5d, 0x3a, 0xac, 0x40, 0xf6, 0xa1, 0x95, 0x4a, 0x65, 0x98, 0x28, 0x92,
	0xcc, 0x92, 0x9e, 0x17, 0x80, 0x55, 0x1d, 0x4b, 0x86, 0xe4, 0x81, 0xe3, 0x8e, 0x3b, 0x89, 0xc9,
	0xb4, 0x15, 0x4d, 0x10, 0x64, 0x59, 0xcb, 0x29, 0xf8, 0x6d, 0x82, 0xa4, 0xa7, 0x32, 0xe1, 0x8e,
	0x4d, 0xac, 0xd0, 0x7f, 0x51, 0x87, 0x8d, 0x7b, 0x96, 0xe2, 0xdf, 0x9a, 0xc2, 0x77, 0xa1, 0x69,
	0xff, 0xc1, 0x71, 0x84, 0x5e, 0x0f, 0x36, 0x50, 0x1e, 0xcf, 0x0f, 0xe8, 0x6b, 0x7f, 0x33, 0xa0,
	0xd7, 0xdf, 0x1e, 0xd0, 0x33, 0x4e, 0x95, 0x4c, 0xdc, 0x71, 0x9c, 0x44, 0x7a, 0xd0, 0x62, 0x86,
	0x35, 0x44, 0x8a, 0xff, 0x1a, 0xda, 0xe3, 0x54, 0x55, 0x06, 0x95, 0x9f, 0x09, 0xc6, 0x93, 0xc8,
	0x1c, 0x6b, 0xcd, 0xa0, 0x16, 0x72, 0x85, 0xff, 0x9a, 0x73, 0xfc, 0xd7, 0x05, 0xc8, 0xb8, 0x92,
	0xb3, 0x1c, 0x41, 0x3d, 0x9b, 0xc0, 0x4b, 0x8d, 0xc9, 0x30, 0x4a, 0x67, 0x9c, 0x85, 0x93, 0x0b,
	0x9c, 0x0f, 0x0b, 0x83, 0x33, 0xce, 0x8e, 0x2e, 0xfe, 0x34, 0x1b, 0xb5, 0x96, 0x31, 0x1b, 0xb5,
	0xff, 0xdd, 0x6c, 0x74, 0xbf, 0xb2, 0x55, 0xaa, 0x71, 0x88, 0xfb, 0xa7, 0x28, 0xe5, 0x81, 0x46,
	0x9a, 0x4c, 0xa0, 0xe1, 0xa8, 0xaa, 0xb3, 0x74, 0xaa, 0x72, 0xc8, 0x47, 0xa3, 0xe7, 0xaf, 0xbb,
	0xb5, 0x17, 0xaf, 0xbb, 0xb5, 0x57, 0xaf, 0xbb, 0xb5, 0x67, 0x6f, 0xba, 0x2b, 0x2f, 0xde, 0x74,
	0x57, 0x7e, 0x7d, 0xd3, 0x5d, 0xf9, 0xae, 0x0a, 0x35, 0xff, 0x73, 0xc7, 0x79, 0xf1, 0x83, 0x07,
	0xe2, 0x4d, 0x1a, 0x78, 0xa0, 0x8f, 0xfe, 0x08, 0x00, 0x00, 0xff, 0xff, 0xba, 0x3d, 0x9b, 0x69,
	0x15, 0x11, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AutoCompleteWindow != 0 {
		i = encodeVarintOrders(dAtA, i, uint64(m.AutoCompleteWindow))
		i--
		dAtA[i] = 0x48
	}
	if m.AutoCompleteAfterDelivery {
		i--
		if m.AutoCompleteAfterDelivery {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.StablecoinDenom) > 0 {
		i -= len(m.StablecoinDenom)
		copy(dAtA[i:], m.StablecoinDenom)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.StablecoinDenom)))
		i--
		dAtA[i] = 0x3a
	}
	if m.DefaultFeeRateBps != 0 {
		i = encodeVarintOrders(dAtA, i, uint64(m.DefaultFeeRateBps))
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.MaxOrderAmount.Size()
		i -= size
		if _, err := m.MaxOrderAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOrders(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.MinOrderAmount.Size()
		i -= size
		if _, err := m.MinOrderAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOrders(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.DisputeWindow != 0 {
		i = encodeVarintOrders(dAtA, i, uint64(m.DisputeWindow))
		i--
		dAtA[i] = 0x18
	}
	if m.DefaultEscrowExpiration != 0 {
		i = encodeVarintOrders(dAtA, i, uint64(m.DefaultEscrowExpiration))
		i--
		dAtA[i] = 0x10
	}
	if m.DefaultOrderExpiration != 0 {
		i = encodeVarintOrders(dAtA, i, uint64(m.DefaultOrderExpiration))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DisputeId != 0 {
		i = encodeVarintOrders(dAtA, i, uint64(m.DisputeId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.SettlementId != 0 {
		i = encodeVarintOrders(dAtA, i, uint64(m.SettlementId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ExpiresAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpiresAt):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintOrders(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa2
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CompletedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CompletedAt):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintOrders(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x9a
	n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.DeliveredAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.DeliveredAt):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintOrders(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x92
	n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ShippedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ShippedAt):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintOrders(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	n7, err7 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.PaidAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.PaidAt):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintOrders(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	n8, err8 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.UpdatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt):])
	if err8 != nil {
		return 0, err8
	}
	i -= n8
	i = encodeVarintOrders(dAtA, i, uint64(n8))
	i--
	dAtA[i] = 0x7a
	n9, err9 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
	if err9 != nil {
		return 0, err9
	}
	i -= n9
	i = encodeVarintOrders(dAtA, i, uint64(n9))
	i--
	dAtA[i] = 0x72
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x6a
	}
	{
		size, err := m.ShippingInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOrders(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size, err := m.PaymentInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOrders(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size := m.TotalAmount.Size()
		i -= size
		if _, err := m.TotalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOrders(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size := m.DiscountAmount.Size()
		i -= size
		if _, err := m.DiscountAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOrders(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size := m.TaxAmount.Size()
		i -= size
		if _, err := m.TaxAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOrders(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.ShippingCost.Size()
		i -= size
		if _, err := m.ShippingCost.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOrders(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.Subtotal.Size()
		i -= size
		if _, err := m.Subtotal.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOrders(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOrders(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Merchant) > 0 {
		i -= len(m.Merchant)
		copy(dAtA[i:], m.Merchant)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Merchant)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Customer) > 0 {
		i -= len(m.Customer)
		copy(dAtA[i:], m.Customer)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Customer)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintOrders(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OrderItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Variant) > 0 {
		i -= len(m.Variant)
		copy(dAtA[i:], m.Variant)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Variant)))
		i--
		dAtA[i] = 0x3a
	}
	{
		size := m.TotalPrice.Size()
		i -= size
		if _, err := m.TotalPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOrders(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.UnitPrice.Size()
		i -= size
		if _, err := m.UnitPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOrders(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.Quantity != 0 {
		i = encodeVarintOrders(dAtA, i, uint64(m.Quantity))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ProductName) > 0 {
		i -= len(m.ProductName)
		copy(dAtA[i:], m.ProductName)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ProductName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ProductId) > 0 {
		i -= len(m.ProductId)
		copy(dAtA[i:], m.ProductId)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ProductId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PaymentInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaymentInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaymentInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n19, err19 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.PaidAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.PaidAt):])
	if err19 != nil {
		return 0, err19
	}
	i -= n19
	i = encodeVarintOrders(dAtA, i, uint64(n19))
	i--
	dAtA[i] = 0x4a
	{
		size := m.FeeAmount.Size()
		i -= size
		if _, err := m.FeeAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOrders(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.RefundedAmount.Size()
		i -= size
		if _, err := m.RefundedAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOrders(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.PaidAmount.Size()
		i -= size
		if _, err := m.PaidAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOrders(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.EscrowId != 0 {
		i = encodeVarintOrders(dAtA, i, uint64(m.EscrowId))
		i--
		dAtA[i] = 0x28
	}
	if m.SettlementId != 0 {
		i = encodeVarintOrders(dAtA, i, uint64(m.SettlementId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.TransactionId) > 0 {
		i -= len(m.TransactionId)
		copy(dAtA[i:], m.TransactionId)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TransactionId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShippingInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShippingInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShippingInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n23, err23 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ActualDelivery, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ActualDelivery):])
	if err23 != nil {
		return 0, err23
	}
	i -= n23
	i = encodeVarintOrders(dAtA, i, uint64(n23))
	i--
	dAtA[i] = 0x32
	n24, err24 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.EstimatedDelivery, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.EstimatedDelivery):])
	if err24 != nil {
		return 0, err24
	}
	i -= n24
	i = encodeVarintOrders(dAtA, i, uint64(n24))
	i--
	dAtA[i] = 0x2a
	if len(m.TrackingNumber) > 0 {
		i -= len(m.TrackingNumber)
		copy(dAtA[i:], m.TrackingNumber)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TrackingNumber)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Carrier) > 0 {
		i -= len(m.Carrier)
		copy(dAtA[i:], m.Carrier)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Carrier)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOrders(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Address) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Address) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Address) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Phone) > 0 {
		i -= len(m.Phone)
		copy(dAtA[i:], m.Phone)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Phone)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Country) > 0 {
		i -= len(m.Country)
		copy(dAtA[i:], m.Country)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Country)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PostalCode) > 0 {
		i -= len(m.PostalCode)
		copy(dAtA[i:], m.PostalCode)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.PostalCode)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.City) > 0 {
		i -= len(m.City)
		copy(dAtA[i:], m.City)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.City)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Line2) > 0 {
		i -= len(m.Line2)
		copy(dAtA[i:], m.Line2)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Line2)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Line1) > 0 {
		i -= len(m.Line1)
		copy(dAtA[i:], m.Line1)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Line1)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Dispute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dispute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dispute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOrders(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	n27, err27 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ResolvedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ResolvedAt):])
	if err27 != nil {
		return 0, err27
	}
	i -= n27
	i = encodeVarintOrders(dAtA, i, uint64(n27))
	i--
	dAtA[i] = 0x6a
	n28, err28 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.UpdatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt):])
	if err28 != nil {
		return 0, err28
	}
	i -= n28
	i = encodeVarintOrders(dAtA, i, uint64(n28))
	i--
	dAtA[i] = 0x62
	n29, err29 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
	if err29 != nil {
		return 0, err29
	}
	i -= n29
	i = encodeVarintOrders(dAtA, i, uint64(n29))
	i--
	dAtA[i] = 0x5a
	if len(m.ResolvedBy) > 0 {
		i -= len(m.ResolvedBy)
		copy(dAtA[i:], m.ResolvedBy)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ResolvedBy)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Resolution) > 0 {
		i -= len(m.Resolution)
		copy(dAtA[i:], m.Resolution)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Resolution)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Evidence) > 0 {
		for iNdEx := len(m.Evidence) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Evidence[iNdEx])
			copy(dAtA[i:], m.Evidence[iNdEx])
			i = encodeVarintOrders(dAtA, i, uint64(len(m.Evidence[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Merchant) > 0 {
		i -= len(m.Merchant)
		copy(dAtA[i:], m.Merchant)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Merchant)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Customer) > 0 {
		i -= len(m.Customer)
		copy(dAtA[i:], m.Customer)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Customer)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OrderId != 0 {
		i = encodeVarintOrders(dAtA, i, uint64(m.OrderId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintOrders(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintOrders(dAtA []byte, offset int, v uint64) int {
	offset -= sovOrders(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultOrderExpiration != 0 {
		n += 1 + sovOrders(uint64(m.DefaultOrderExpiration))
	}
	if m.DefaultEscrowExpiration != 0 {
		n += 1 + sovOrders(uint64(m.DefaultEscrowExpiration))
	}
	if m.DisputeWindow != 0 {
		n += 1 + sovOrders(uint64(m.DisputeWindow))
	}
	l = m.MinOrderAmount.Size()
	n += 1 + l + sovOrders(uint64(l))
	l = m.MaxOrderAmount.Size()
	n += 1 + l + sovOrders(uint64(l))
	if m.DefaultFeeRateBps != 0 {
		n += 1 + sovOrders(uint64(m.DefaultFeeRateBps))
	}
	l = len(m.StablecoinDenom)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.AutoCompleteAfterDelivery {
		n += 2
	}
	if m.AutoCompleteWindow != 0 {
		n += 1 + sovOrders(uint64(m.AutoCompleteWindow))
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOrders(uint64(m.Id))
	}
	l = len(m.Customer)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Merchant)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovOrders(uint64(l))
		}
	}
	l = m.Subtotal.Size()
	n += 1 + l + sovOrders(uint64(l))
	l = m.ShippingCost.Size()
	n += 1 + l + sovOrders(uint64(l))
	l = m.TaxAmount.Size()
	n += 1 + l + sovOrders(uint64(l))
	l = m.DiscountAmount.Size()
	n += 1 + l + sovOrders(uint64(l))
	l = m.TotalAmount.Size()
	n += 1 + l + sovOrders(uint64(l))
	l = m.PaymentInfo.Size()
	n += 1 + l + sovOrders(uint64(l))
	l = m.ShippingInfo.Size()
	n += 1 + l + sovOrders(uint64(l))
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovOrders(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt)
	n += 1 + l + sovOrders(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.PaidAt)
	n += 2 + l + sovOrders(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ShippedAt)
	n += 2 + l + sovOrders(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.DeliveredAt)
	n += 2 + l + sovOrders(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CompletedAt)
	n += 2 + l + sovOrders(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpiresAt)
	n += 2 + l + sovOrders(uint64(l))
	if m.SettlementId != 0 {
		n += 2 + sovOrders(uint64(m.SettlementId))
	}
	if m.DisputeId != 0 {
		n += 2 + sovOrders(uint64(m.DisputeId))
	}
	return n
}

func (m *OrderItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.ProductId)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.ProductName)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.Quantity != 0 {
		n += 1 + sovOrders(uint64(m.Quantity))
	}
	l = m.UnitPrice.Size()
	n += 1 + l + sovOrders(uint64(l))
	l = m.TotalPrice.Size()
	n += 1 + l + sovOrders(uint64(l))
	l = len(m.Variant)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *PaymentInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TransactionId)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.SettlementId != 0 {
		n += 1 + sovOrders(uint64(m.SettlementId))
	}
	if m.EscrowId != 0 {
		n += 1 + sovOrders(uint64(m.EscrowId))
	}
	l = m.PaidAmount.Size()
	n += 1 + l + sovOrders(uint64(l))
	l = m.RefundedAmount.Size()
	n += 1 + l + sovOrders(uint64(l))
	l = m.FeeAmount.Size()
	n += 1 + l + sovOrders(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.PaidAt)
	n += 1 + l + sovOrders(uint64(l))
	return n
}

func (m *ShippingInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Address.Size()
	n += 1 + l + sovOrders(uint64(l))
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Carrier)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TrackingNumber)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.EstimatedDelivery)
	n += 1 + l + sovOrders(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ActualDelivery)
	n += 1 + l + sovOrders(uint64(l))
	return n
}

func (m *Address) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Line1)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Line2)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.City)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.PostalCode)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Country)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *Dispute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOrders(uint64(m.Id))
	}
	if m.OrderId != 0 {
		n += 1 + sovOrders(uint64(m.OrderId))
	}
	l = len(m.Customer)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Merchant)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if len(m.Evidence) > 0 {
		for _, s := range m.Evidence {
			l = len(s)
			n += 1 + l + sovOrders(uint64(l))
		}
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Resolution)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.ResolvedBy)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovOrders(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt)
	n += 1 + l + sovOrders(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ResolvedAt)
	n += 1 + l + sovOrders(uint64(l))
	l = m.Amount.Size()
	n += 1 + l + sovOrders(uint64(l))
	return n
}

func sovOrders(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOrders(x uint64) (n int) {
	return sovOrders(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultOrderExpiration", wireType)
			}
			m.DefaultOrderExpiration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultOrderExpiration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultEscrowExpiration", wireType)
			}
			m.DefaultEscrowExpiration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultEscrowExpiration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisputeWindow", wireType)
			}
			m.DisputeWindow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DisputeWindow |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinOrderAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinOrderAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxOrderAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxOrderAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFeeRateBps", wireType)
			}
			m.DefaultFeeRateBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultFeeRateBps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StablecoinDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StablecoinDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCompleteAfterDelivery", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoCompleteAfterDelivery = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCompleteWindow", wireType)
			}
			m.AutoCompleteWindow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoCompleteWindow |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Customer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Customer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Merchant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Merchant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, OrderItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subtotal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Subtotal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShippingCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ShippingCost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaxAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TaxAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscountAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DiscountAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PaymentInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShippingInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ShippingInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaidAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.PaidAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShippedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ShippedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveredAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.DeliveredAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CompletedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ExpiresAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementId", wireType)
			}
			m.SettlementId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisputeId", wireType)
			}
			m.DisputeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DisputeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			m.Quantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantity |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UnitPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaymentInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaymentInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaymentInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementId", wireType)
			}
			m.SettlementId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowId", wireType)
			}
			m.EscrowId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EscrowId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaidAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PaidAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefundedAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RefundedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FeeAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaidAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.PaidAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShippingInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShippingInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShippingInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Carrier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Carrier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackingNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrackingNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedDelivery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.EstimatedDelivery, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActualDelivery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ActualDelivery, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Address) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Address: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Address: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Line1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Line1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Line2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Line2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostalCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PostalCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dispute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dispute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dispute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			m.OrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Customer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Customer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Merchant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Merchant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Evidence", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Evidence = append(m.Evidence, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolution", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resolution = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResolvedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ResolvedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOrders(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOrders
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOrders
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOrders
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOrders        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOrders          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOrders = fmt.Errorf("proto: unexpected end of group")
)
