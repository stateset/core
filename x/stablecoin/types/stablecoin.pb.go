// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: stateset/stablecoin/stablecoin.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "github.com/golang/protobuf/ptypes/duration"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// CollateralParam defines risk limits for a collateral type.
type CollateralParam struct {
	Denom            string                      `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	LiquidationRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=liquidation_ratio,json=liquidationRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"liquidation_ratio"`
	StabilityFee     cosmossdk_io_math.LegacyDec `protobuf:"bytes,3,opt,name=stability_fee,json=stabilityFee,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"stability_fee"`
	DebtLimit        cosmossdk_io_math.Int       `protobuf:"bytes,4,opt,name=debt_limit,json=debtLimit,proto3,customtype=cosmossdk.io/math.Int" json:"debt_limit"`
	Active           bool                        `protobuf:"varint,5,opt,name=active,proto3" json:"active,omitempty"`
}

func (m *CollateralParam) Reset()         { *m = CollateralParam{} }
func (m *CollateralParam) String() string { return proto.CompactTextString(m) }
func (*CollateralParam) ProtoMessage()    {}
func (*CollateralParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b637ce4a2037bd4, []int{0}
}
func (m *CollateralParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollateralParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollateralParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollateralParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollateralParam.Merge(m, src)
}
func (m *CollateralParam) XXX_Size() int {
	return m.Size()
}
func (m *CollateralParam) XXX_DiscardUnknown() {
	xxx_messageInfo_CollateralParam.DiscardUnknown(m)
}

var xxx_messageInfo_CollateralParam proto.InternalMessageInfo

func (m *CollateralParam) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *CollateralParam) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

// Params contains global vault parameters.
type Params struct {
	CollateralParams    []CollateralParam `protobuf:"bytes,1,rep,name=collateral_params,json=collateralParams,proto3" json:"collateral_params"`
	VaultMintingEnabled bool              `protobuf:"varint,2,opt,name=vault_minting_enabled,json=vaultMintingEnabled,proto3" json:"vault_minting_enabled,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b637ce4a2037bd4, []int{1}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetCollateralParams() []CollateralParam {
	if m != nil {
		return m.CollateralParams
	}
	return nil
}

func (m *Params) GetVaultMintingEnabled() bool {
	if m != nil {
		return m.VaultMintingEnabled
	}
	return false
}

// Vault tracks a collateralized debt position for ssUSD issuance.
type Vault struct {
	Id              uint64                                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Owner           string                                  `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	Collateral      github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,3,opt,name=collateral,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"collateral"`
	CollateralDenom string                                  `protobuf:"bytes,4,opt,name=collateral_denom,json=collateralDenom,proto3" json:"collateral_denom,omitempty"`
	Debt            cosmossdk_io_math.Int                   `protobuf:"bytes,5,opt,name=debt,proto3,customtype=cosmossdk.io/math.Int" json:"debt"`
	LastAccrued     int64                                   `protobuf:"varint,6,opt,name=last_accrued,json=lastAccrued,proto3" json:"last_accrued,omitempty"`
}

func (m *Vault) Reset()         { *m = Vault{} }
func (m *Vault) String() string { return proto.CompactTextString(m) }
func (*Vault) ProtoMessage()    {}
func (*Vault) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b637ce4a2037bd4, []int{2}
}
func (m *Vault) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vault) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vault.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vault) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vault.Merge(m, src)
}
func (m *Vault) XXX_Size() int {
	return m.Size()
}
func (m *Vault) XXX_DiscardUnknown() {
	xxx_messageInfo_Vault.DiscardUnknown(m)
}

var xxx_messageInfo_Vault proto.InternalMessageInfo

func (m *Vault) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Vault) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *Vault) GetCollateralDenom() string {
	if m != nil {
		return m.CollateralDenom
	}
	return ""
}

func (m *Vault) GetLastAccrued() int64 {
	if m != nil {
		return m.LastAccrued
	}
	return 0
}

// TokenizedTreasuryConfig defines an approved tokenized treasury token.
type TokenizedTreasuryConfig struct {
	Denom            string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	Issuer           string `protobuf:"bytes,2,opt,name=issuer,proto3" json:"issuer,omitempty"`
	UnderlyingType   string `protobuf:"bytes,3,opt,name=underlying_type,json=underlyingType,proto3" json:"underlying_type,omitempty"`
	Active           bool   `protobuf:"varint,4,opt,name=active,proto3" json:"active,omitempty"`
	HaircutBps       uint32 `protobuf:"varint,5,opt,name=haircut_bps,json=haircutBps,proto3" json:"haircut_bps,omitempty"`
	MaxAllocationBps uint32 `protobuf:"varint,6,opt,name=max_allocation_bps,json=maxAllocationBps,proto3" json:"max_allocation_bps,omitempty"`
	OracleDenom      string `protobuf:"bytes,7,opt,name=oracle_denom,json=oracleDenom,proto3" json:"oracle_denom,omitempty"`
}

func (m *TokenizedTreasuryConfig) Reset()         { *m = TokenizedTreasuryConfig{} }
func (m *TokenizedTreasuryConfig) String() string { return proto.CompactTextString(m) }
func (*TokenizedTreasuryConfig) ProtoMessage()    {}
func (*TokenizedTreasuryConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b637ce4a2037bd4, []int{3}
}
func (m *TokenizedTreasuryConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenizedTreasuryConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenizedTreasuryConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenizedTreasuryConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenizedTreasuryConfig.Merge(m, src)
}
func (m *TokenizedTreasuryConfig) XXX_Size() int {
	return m.Size()
}
func (m *TokenizedTreasuryConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenizedTreasuryConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TokenizedTreasuryConfig proto.InternalMessageInfo

func (m *TokenizedTreasuryConfig) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *TokenizedTreasuryConfig) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *TokenizedTreasuryConfig) GetUnderlyingType() string {
	if m != nil {
		return m.UnderlyingType
	}
	return ""
}

func (m *TokenizedTreasuryConfig) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *TokenizedTreasuryConfig) GetHaircutBps() uint32 {
	if m != nil {
		return m.HaircutBps
	}
	return 0
}

func (m *TokenizedTreasuryConfig) GetMaxAllocationBps() uint32 {
	if m != nil {
		return m.MaxAllocationBps
	}
	return 0
}

func (m *TokenizedTreasuryConfig) GetOracleDenom() string {
	if m != nil {
		return m.OracleDenom
	}
	return ""
}

// ReserveParams defines reserve-backed stablecoin policy.
type ReserveParams struct {
	MinReserveRatioBps    uint32                    `protobuf:"varint,1,opt,name=min_reserve_ratio_bps,json=minReserveRatioBps,proto3" json:"min_reserve_ratio_bps,omitempty"`
	TargetReserveRatioBps uint32                    `protobuf:"varint,2,opt,name=target_reserve_ratio_bps,json=targetReserveRatioBps,proto3" json:"target_reserve_ratio_bps,omitempty"`
	MintFeeBps            uint32                    `protobuf:"varint,3,opt,name=mint_fee_bps,json=mintFeeBps,proto3" json:"mint_fee_bps,omitempty"`
	RedeemFeeBps          uint32                    `protobuf:"varint,4,opt,name=redeem_fee_bps,json=redeemFeeBps,proto3" json:"redeem_fee_bps,omitempty"`
	MinMintAmount         cosmossdk_io_math.Int     `protobuf:"bytes,5,opt,name=min_mint_amount,json=minMintAmount,proto3,customtype=cosmossdk.io/math.Int" json:"min_mint_amount"`
	MinRedeemAmount       cosmossdk_io_math.Int     `protobuf:"bytes,6,opt,name=min_redeem_amount,json=minRedeemAmount,proto3,customtype=cosmossdk.io/math.Int" json:"min_redeem_amount"`
	RedemptionDelay       time.Duration             `protobuf:"bytes,7,opt,name=redemption_delay,json=redemptionDelay,proto3,stdduration" json:"redemption_delay"`
	MaxDailyMint          cosmossdk_io_math.Int     `protobuf:"bytes,8,opt,name=max_daily_mint,json=maxDailyMint,proto3,customtype=cosmossdk.io/math.Int" json:"max_daily_mint"`
	MaxDailyRedeem        cosmossdk_io_math.Int     `protobuf:"bytes,9,opt,name=max_daily_redeem,json=maxDailyRedeem,proto3,customtype=cosmossdk.io/math.Int" json:"max_daily_redeem"`
	TokenizedTreasuries   []TokenizedTreasuryConfig `protobuf:"bytes,10,rep,name=tokenized_treasuries,json=tokenizedTreasuries,proto3" json:"tokenized_treasuries"`
	RequireKyc            bool                      `protobuf:"varint,11,opt,name=require_kyc,json=requireKyc,proto3" json:"require_kyc,omitempty"`
	MintPaused            bool                      `protobuf:"varint,12,opt,name=mint_paused,json=mintPaused,proto3" json:"mint_paused,omitempty"`
	RedeemPaused          bool                      `protobuf:"varint,13,opt,name=redeem_paused,json=redeemPaused,proto3" json:"redeem_paused,omitempty"`
}

func (m *ReserveParams) Reset()         { *m = ReserveParams{} }
func (m *ReserveParams) String() string { return proto.CompactTextString(m) }
func (*ReserveParams) ProtoMessage()    {}
func (*ReserveParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b637ce4a2037bd4, []int{4}
}
func (m *ReserveParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReserveParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReserveParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReserveParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReserveParams.Merge(m, src)
}
func (m *ReserveParams) XXX_Size() int {
	return m.Size()
}
func (m *ReserveParams) XXX_DiscardUnknown() {
	xxx_messageInfo_ReserveParams.DiscardUnknown(m)
}

var xxx_messageInfo_ReserveParams proto.InternalMessageInfo

func (m *ReserveParams) GetMinReserveRatioBps() uint32 {
	if m != nil {
		return m.MinReserveRatioBps
	}
	return 0
}

func (m *ReserveParams) GetTargetReserveRatioBps() uint32 {
	if m != nil {
		return m.TargetReserveRatioBps
	}
	return 0
}

func (m *ReserveParams) GetMintFeeBps() uint32 {
	if m != nil {
		return m.MintFeeBps
	}
	return 0
}

func (m *ReserveParams) GetRedeemFeeBps() uint32 {
	if m != nil {
		return m.RedeemFeeBps
	}
	return 0
}

func (m *ReserveParams) GetRedemptionDelay() time.Duration {
	if m != nil {
		return m.RedemptionDelay
	}
	return 0
}

func (m *ReserveParams) GetTokenizedTreasuries() []TokenizedTreasuryConfig {
	if m != nil {
		return m.TokenizedTreasuries
	}
	return nil
}

func (m *ReserveParams) GetRequireKyc() bool {
	if m != nil {
		return m.RequireKyc
	}
	return false
}

func (m *ReserveParams) GetMintPaused() bool {
	if m != nil {
		return m.MintPaused
	}
	return false
}

func (m *ReserveParams) GetRedeemPaused() bool {
	if m != nil {
		return m.RedeemPaused
	}
	return false
}

// Reserve represents the on-chain reserve backing for ssUSD.
type Reserve struct {
	TotalDeposited    github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=total_deposited,json=totalDeposited,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"total_deposited"`
	TotalValue        cosmossdk_io_math.Int                    `protobuf:"bytes,2,opt,name=total_value,json=totalValue,proto3,customtype=cosmossdk.io/math.Int" json:"total_value"`
	TotalMinted       cosmossdk_io_math.Int                    `protobuf:"bytes,3,opt,name=total_minted,json=totalMinted,proto3,customtype=cosmossdk.io/math.Int" json:"total_minted"`
	LastUpdatedHeight int64                                    `protobuf:"varint,4,opt,name=last_updated,json=lastUpdated,proto3" json:"last_updated,omitempty"`
	LastUpdatedTime   time.Time                                `protobuf:"bytes,5,opt,name=last_updated_time,json=lastUpdatedTime,proto3,stdtime" json:"last_updated_time"`
}

func (m *Reserve) Reset()         { *m = Reserve{} }
func (m *Reserve) String() string { return proto.CompactTextString(m) }
func (*Reserve) ProtoMessage()    {}
func (*Reserve) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b637ce4a2037bd4, []int{5}
}
func (m *Reserve) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Reserve) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Reserve.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Reserve) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reserve.Merge(m, src)
}
func (m *Reserve) XXX_Size() int {
	return m.Size()
}
func (m *Reserve) XXX_DiscardUnknown() {
	xxx_messageInfo_Reserve.DiscardUnknown(m)
}

var xxx_messageInfo_Reserve proto.InternalMessageInfo

func (m *Reserve) GetTotalDeposited() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TotalDeposited
	}
	return nil
}

func (m *Reserve) GetLastUpdatedHeight() int64 {
	if m != nil {
		return m.LastUpdatedHeight
	}
	return 0
}

func (m *Reserve) GetLastUpdatedTime() time.Time {
	if m != nil {
		return m.LastUpdatedTime
	}
	return time.Time{}
}

// ReserveDeposit represents a deposit of approved tokenized treasuries.
type ReserveDeposit struct {
	Id          uint64                                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Depositor   string                                  `protobuf:"bytes,2,opt,name=depositor,proto3" json:"depositor,omitempty"`
	Amount      github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,3,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"amount"`
	UsdValue    cosmossdk_io_math.Int                   `protobuf:"bytes,4,opt,name=usd_value,json=usdValue,proto3,customtype=cosmossdk.io/math.Int" json:"usd_value"`
	SsusdMinted cosmossdk_io_math.Int                   `protobuf:"bytes,5,opt,name=ssusd_minted,json=ssusdMinted,proto3,customtype=cosmossdk.io/math.Int" json:"ssusd_minted"`
	DepositedAt time.Time                               `protobuf:"bytes,6,opt,name=deposited_at,json=depositedAt,proto3,stdtime" json:"deposited_at"`
	Status      string                                  `protobuf:"bytes,7,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *ReserveDeposit) Reset()         { *m = ReserveDeposit{} }
func (m *ReserveDeposit) String() string { return proto.CompactTextString(m) }
func (*ReserveDeposit) ProtoMessage()    {}
func (*ReserveDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b637ce4a2037bd4, []int{6}
}
func (m *ReserveDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReserveDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReserveDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReserveDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReserveDeposit.Merge(m, src)
}
func (m *ReserveDeposit) XXX_Size() int {
	return m.Size()
}
func (m *ReserveDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_ReserveDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_ReserveDeposit proto.InternalMessageInfo

func (m *ReserveDeposit) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ReserveDeposit) GetDepositor() string {
	if m != nil {
		return m.Depositor
	}
	return ""
}

func (m *ReserveDeposit) GetDepositedAt() time.Time {
	if m != nil {
		return m.DepositedAt
	}
	return time.Time{}
}

func (m *ReserveDeposit) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// RedemptionRequest represents a request to redeem ssUSD into reserve assets.
type RedemptionRequest struct {
	Id              uint64                                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Requester       string                                  `protobuf:"bytes,2,opt,name=requester,proto3" json:"requester,omitempty"`
	SsusdAmount     cosmossdk_io_math.Int                   `protobuf:"bytes,3,opt,name=ssusd_amount,json=ssusdAmount,proto3,customtype=cosmossdk.io/math.Int" json:"ssusd_amount"`
	OutputDenom     string                                  `protobuf:"bytes,4,opt,name=output_denom,json=outputDenom,proto3" json:"output_denom,omitempty"`
	RequestedAt     time.Time                               `protobuf:"bytes,5,opt,name=requested_at,json=requestedAt,proto3,stdtime" json:"requested_at"`
	ExecutableAfter time.Time                               `protobuf:"bytes,6,opt,name=executable_after,json=executableAfter,proto3,stdtime" json:"executable_after"`
	Status          string                                  `protobuf:"bytes,7,opt,name=status,proto3" json:"status,omitempty"`
	ExecutedAt      time.Time                               `protobuf:"bytes,8,opt,name=executed_at,json=executedAt,proto3,stdtime" json:"executed_at"`
	OutputAmount    github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,9,opt,name=output_amount,json=outputAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"output_amount"`
}

func (m *RedemptionRequest) Reset()         { *m = RedemptionRequest{} }
func (m *RedemptionRequest) String() string { return proto.CompactTextString(m) }
func (*RedemptionRequest) ProtoMessage()    {}
func (*RedemptionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b637ce4a2037bd4, []int{7}
}
func (m *RedemptionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RedemptionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RedemptionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RedemptionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RedemptionRequest.Merge(m, src)
}
func (m *RedemptionRequest) XXX_Size() int {
	return m.Size()
}
func (m *RedemptionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RedemptionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RedemptionRequest proto.InternalMessageInfo

func (m *RedemptionRequest) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RedemptionRequest) GetRequester() string {
	if m != nil {
		return m.Requester
	}
	return ""
}

func (m *RedemptionRequest) GetOutputDenom() string {
	if m != nil {
		return m.OutputDenom
	}
	return ""
}

func (m *RedemptionRequest) GetRequestedAt() time.Time {
	if m != nil {
		return m.RequestedAt
	}
	return time.Time{}
}

func (m *RedemptionRequest) GetExecutableAfter() time.Time {
	if m != nil {
		return m.ExecutableAfter
	}
	return time.Time{}
}

func (m *RedemptionRequest) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *RedemptionRequest) GetExecutedAt() time.Time {
	if m != nil {
		return m.ExecutedAt
	}
	return time.Time{}
}

// DailyMintStats tracks daily minting/redemption totals.
type DailyMintStats struct {
	Date          string                `protobuf:"bytes,1,opt,name=date,proto3" json:"date,omitempty"`
	TotalMinted   cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_minted,json=totalMinted,proto3,customtype=cosmossdk.io/math.Int" json:"total_minted"`
	TotalRedeemed cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_redeemed,json=totalRedeemed,proto3,customtype=cosmossdk.io/math.Int" json:"total_redeemed"`
}

func (m *DailyMintStats) Reset()         { *m = DailyMintStats{} }
func (m *DailyMintStats) String() string { return proto.CompactTextString(m) }
func (*DailyMintStats) ProtoMessage()    {}
func (*DailyMintStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b637ce4a2037bd4, []int{8}
}
func (m *DailyMintStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DailyMintStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DailyMintStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DailyMintStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DailyMintStats.Merge(m, src)
}
func (m *DailyMintStats) XXX_Size() int {
	return m.Size()
}
func (m *DailyMintStats) XXX_DiscardUnknown() {
	xxx_messageInfo_DailyMintStats.DiscardUnknown(m)
}

var xxx_messageInfo_DailyMintStats proto.InternalMessageInfo

func (m *DailyMintStats) GetDate() string {
	if m != nil {
		return m.Date
	}
	return ""
}

// OffChainReserveAttestation represents an off-chain reserve attestation.
type OffChainReserveAttestation struct {
	Id              uint64                `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Attester        string                `protobuf:"bytes,2,opt,name=attester,proto3" json:"attester,omitempty"`
	TotalCash       cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_cash,json=totalCash,proto3,customtype=cosmossdk.io/math.Int" json:"total_cash"`
	TotalTbills     cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=total_tbills,json=totalTbills,proto3,customtype=cosmossdk.io/math.Int" json:"total_tbills"`
	TotalTnotes     cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=total_tnotes,json=totalTnotes,proto3,customtype=cosmossdk.io/math.Int" json:"total_tnotes"`
	TotalTbonds     cosmossdk_io_math.Int `protobuf:"bytes,6,opt,name=total_tbonds,json=totalTbonds,proto3,customtype=cosmossdk.io/math.Int" json:"total_tbonds"`
	TotalRepos      cosmossdk_io_math.Int `protobuf:"bytes,7,opt,name=total_repos,json=totalRepos,proto3,customtype=cosmossdk.io/math.Int" json:"total_repos"`
	TotalMmf        cosmossdk_io_math.Int `protobuf:"bytes,8,opt,name=total_mmf,json=totalMmf,proto3,customtype=cosmossdk.io/math.Int" json:"total_mmf"`
	TotalValue      cosmossdk_io_math.Int `protobuf:"bytes,9,opt,name=total_value,json=totalValue,proto3,customtype=cosmossdk.io/math.Int" json:"total_value"`
	CustodianName   string                `protobuf:"bytes,10,opt,name=custodian_name,json=custodianName,proto3" json:"custodian_name,omitempty"`
	AuditFirm       string                `protobuf:"bytes,11,opt,name=audit_firm,json=auditFirm,proto3" json:"audit_firm,omitempty"`
	ReportDate      time.Time             `protobuf:"bytes,12,opt,name=report_date,json=reportDate,proto3,stdtime" json:"report_date"`
	AttestationHash string                `protobuf:"bytes,13,opt,name=attestation_hash,json=attestationHash,proto3" json:"attestation_hash,omitempty"`
	Timestamp       time.Time             `protobuf:"bytes,14,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
}

func (m *OffChainReserveAttestation) Reset()         { *m = OffChainReserveAttestation{} }
func (m *OffChainReserveAttestation) String() string { return proto.CompactTextString(m) }
func (*OffChainReserveAttestation) ProtoMessage()    {}
func (*OffChainReserveAttestation) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b637ce4a2037bd4, []int{9}
}
func (m *OffChainReserveAttestation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OffChainReserveAttestation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OffChainReserveAttestation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OffChainReserveAttestation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OffChainReserveAttestation.Merge(m, src)
}
func (m *OffChainReserveAttestation) XXX_Size() int {
	return m.Size()
}
func (m *OffChainReserveAttestation) XXX_DiscardUnknown() {
	xxx_messageInfo_OffChainReserveAttestation.DiscardUnknown(m)
}

var xxx_messageInfo_OffChainReserveAttestation proto.InternalMessageInfo

func (m *OffChainReserveAttestation) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *OffChainReserveAttestation) GetAttester() string {
	if m != nil {
		return m.Attester
	}
	return ""
}

func (m *OffChainReserveAttestation) GetCustodianName() string {
	if m != nil {
		return m.CustodianName
	}
	return ""
}

func (m *OffChainReserveAttestation) GetAuditFirm() string {
	if m != nil {
		return m.AuditFirm
	}
	return ""
}

func (m *OffChainReserveAttestation) GetReportDate() time.Time {
	if m != nil {
		return m.ReportDate
	}
	return time.Time{}
}

func (m *OffChainReserveAttestation) GetAttestationHash() string {
	if m != nil {
		return m.AttestationHash
	}
	return ""
}

func (m *OffChainReserveAttestation) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

// TotalReserves aggregates on-chain and off-chain reserves.
type TotalReserves struct {
	OnChainValue       cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=on_chain_value,json=onChainValue,proto3,customtype=cosmossdk.io/math.Int" json:"on_chain_value"`
	OffChainValue      cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=off_chain_value,json=offChainValue,proto3,customtype=cosmossdk.io/math.Int" json:"off_chain_value"`
	TotalValue         cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_value,json=totalValue,proto3,customtype=cosmossdk.io/math.Int" json:"total_value"`
	TotalSupply        cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=total_supply,json=totalSupply,proto3,customtype=cosmossdk.io/math.Int" json:"total_supply"`
	ReserveRatioBps    uint32                `protobuf:"varint,5,opt,name=reserve_ratio_bps,json=reserveRatioBps,proto3" json:"reserve_ratio_bps,omitempty"`
	LastOnChainUpdate  time.Time             `protobuf:"bytes,6,opt,name=last_on_chain_update,json=lastOnChainUpdate,proto3,stdtime" json:"last_on_chain_update"`
	LastOffChainUpdate time.Time             `protobuf:"bytes,7,opt,name=last_off_chain_update,json=lastOffChainUpdate,proto3,stdtime" json:"last_off_chain_update"`
}

func (m *TotalReserves) Reset()         { *m = TotalReserves{} }
func (m *TotalReserves) String() string { return proto.CompactTextString(m) }
func (*TotalReserves) ProtoMessage()    {}
func (*TotalReserves) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b637ce4a2037bd4, []int{10}
}
func (m *TotalReserves) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TotalReserves) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TotalReserves.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TotalReserves) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TotalReserves.Merge(m, src)
}
func (m *TotalReserves) XXX_Size() int {
	return m.Size()
}
func (m *TotalReserves) XXX_DiscardUnknown() {
	xxx_messageInfo_TotalReserves.DiscardUnknown(m)
}

var xxx_messageInfo_TotalReserves proto.InternalMessageInfo

func (m *TotalReserves) GetReserveRatioBps() uint32 {
	if m != nil {
		return m.ReserveRatioBps
	}
	return 0
}

func (m *TotalReserves) GetLastOnChainUpdate() time.Time {
	if m != nil {
		return m.LastOnChainUpdate
	}
	return time.Time{}
}

func (m *TotalReserves) GetLastOffChainUpdate() time.Time {
	if m != nil {
		return m.LastOffChainUpdate
	}
	return time.Time{}
}

func init() {
	proto.RegisterType((*CollateralParam)(nil), "stateset.stablecoin.CollateralParam")
	proto.RegisterType((*Params)(nil), "stateset.stablecoin.Params")
	proto.RegisterType((*Vault)(nil), "stateset.stablecoin.Vault")
	proto.RegisterType((*TokenizedTreasuryConfig)(nil), "stateset.stablecoin.TokenizedTreasuryConfig")
	proto.RegisterType((*ReserveParams)(nil), "stateset.stablecoin.ReserveParams")
	proto.RegisterType((*Reserve)(nil), "stateset.stablecoin.Reserve")
	proto.RegisterType((*ReserveDeposit)(nil), "stateset.stablecoin.ReserveDeposit")
	proto.RegisterType((*RedemptionRequest)(nil), "stateset.stablecoin.RedemptionRequest")
	proto.RegisterType((*DailyMintStats)(nil), "stateset.stablecoin.DailyMintStats")
	proto.RegisterType((*OffChainReserveAttestation)(nil), "stateset.stablecoin.OffChainReserveAttestation")
	proto.RegisterType((*TotalReserves)(nil), "stateset.stablecoin.TotalReserves")
}

func init() {
	proto.RegisterFile("stateset/stablecoin/stablecoin.proto", fileDescriptor_4b637ce4a2037bd4)
}

var fileDescriptor_4b637ce4a2037bd4 = []byte{
	// 1693 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x4b, 0x73, 0x1b, 0x4b,
	0x15, 0xb6, 0x2c, 0x45, 0x91, 0x8e, 0x5e, 0x76, 0xc7, 0xbe, 0xe8, 0x1a, 0xb0, 0x7d, 0x45, 0xa8,
	0xeb, 0x90, 0x44, 0xc2, 0x66, 0x01, 0x3b, 0x4a, 0xb2, 0xf2, 0x02, 0xe7, 0xc1, 0xd8, 0x49, 0xaa,
	0x58, 0x30, 0xd5, 0x9a, 0x69, 0x49, 0x8d, 0x67, 0xa6, 0x95, 0xe9, 0x1e, 0x63, 0xf1, 0x2b, 0xb2,
	0xa1, 0x8a, 0x0d, 0xac, 0x81, 0x1d, 0x55, 0x6c, 0x58, 0xb3, 0xc9, 0x32, 0xc5, 0x8a, 0x62, 0x91,
	0x50, 0x4e, 0x15, 0x3f, 0x82, 0x15, 0xd5, 0xa7, 0x5b, 0x23, 0xc5, 0x76, 0x6e, 0x45, 0x4a, 0x36,
	0x89, 0xfb, 0xf4, 0x39, 0x5f, 0x77, 0x7f, 0xe7, 0x39, 0x82, 0xeb, 0x52, 0x51, 0xc5, 0x24, 0x53,
	0x2d, 0xa9, 0x68, 0x2f, 0x60, 0x9e, 0xe0, 0xd1, 0xcc, 0x9f, 0xcd, 0x51, 0x2c, 0x94, 0x20, 0xd7,
	0x26, 0x5a, 0xcd, 0xe9, 0xd6, 0xc6, 0xda, 0x40, 0x0c, 0x04, 0xee, 0xb7, 0xf4, 0x5f, 0x46, 0x75,
	0xe3, 0x4b, 0x4f, 0xc8, 0x50, 0x48, 0xd7, 0x6c, 0x98, 0x85, 0xdd, 0xda, 0x34, 0xab, 0x56, 0x8f,
	0x4a, 0xd6, 0x3a, 0xd9, 0xed, 0x31, 0x45, 0x77, 0x5b, 0xd3, 0x53, 0x36, 0xb6, 0x06, 0x42, 0x0c,
	0x02, 0xd6, 0xc2, 0x55, 0x2f, 0xe9, 0xb7, 0x14, 0x0f, 0x99, 0x54, 0x34, 0x1c, 0x4d, 0x00, 0xce,
	0x2b, 0xf8, 0x49, 0x4c, 0x15, 0x17, 0x16, 0xa0, 0xf1, 0x8f, 0x65, 0xa8, 0xed, 0x8b, 0x20, 0xa0,
	0x8a, 0xc5, 0x34, 0x78, 0x42, 0x63, 0x1a, 0x92, 0x35, 0xb8, 0xe2, 0xb3, 0x48, 0x84, 0xf5, 0xcc,
	0x76, 0x66, 0xa7, 0xe8, 0x98, 0x05, 0xf9, 0x15, 0xac, 0x06, 0xfc, 0x45, 0xc2, 0x7d, 0x34, 0x77,
	0x11, 0xa5, 0xbe, 0xac, 0x35, 0x3a, 0xbb, 0xaf, 0xde, 0x6c, 0x2d, 0xfd, 0xfb, 0xcd, 0xd6, 0xb7,
	0xcd, 0x6d, 0xa5, 0x7f, 0xdc, 0xe4, 0xa2, 0x15, 0x52, 0x35, 0x6c, 0x1e, 0xb0, 0x01, 0xf5, 0xc6,
	0x5d, 0xe6, 0xfd, 0xf3, 0x6f, 0xb7, 0xc1, 0x3e, 0xad, 0xcb, 0x3c, 0x67, 0x65, 0x06, 0xcb, 0xd1,
	0xff, 0x92, 0x67, 0x50, 0xd1, 0x4c, 0xf1, 0x80, 0xab, 0xb1, 0xdb, 0x67, 0xac, 0x9e, 0x5d, 0x14,
	0xbb, 0x9c, 0xe2, 0xdc, 0x65, 0x8c, 0xfc, 0x0c, 0xc0, 0x67, 0x3d, 0xe5, 0x06, 0x3c, 0xe4, 0xaa,
	0x9e, 0x43, 0xd0, 0x9b, 0x16, 0x74, 0xfd, 0x22, 0xe8, 0x83, 0x48, 0xcd, 0xc0, 0x3d, 0x88, 0x94,
	0x53, 0xd4, 0xe6, 0x07, 0xda, 0x9a, 0x7c, 0x01, 0x79, 0xea, 0x29, 0x7e, 0xc2, 0xea, 0x57, 0xb6,
	0x33, 0x3b, 0x05, 0xc7, 0xae, 0x1a, 0xbf, 0xcb, 0x40, 0x1e, 0xb9, 0x93, 0xe4, 0x39, 0xac, 0x7a,
	0x29, 0x9f, 0xee, 0x08, 0x85, 0xf5, 0xcc, 0x76, 0x76, 0xa7, 0xb4, 0x77, 0xbd, 0x79, 0x49, 0x4c,
	0x34, 0xcf, 0xb1, 0xdf, 0xc9, 0xe9, 0xbb, 0x39, 0x2b, 0xde, 0xfb, 0x62, 0x49, 0xf6, 0x60, 0xfd,
	0x84, 0x26, 0x81, 0x72, 0x43, 0x1e, 0x29, 0x1e, 0x0d, 0x5c, 0x16, 0x69, 0x0c, 0x1f, 0x7d, 0x50,
	0x70, 0xae, 0xe1, 0xe6, 0x43, 0xb3, 0x77, 0xc7, 0x6c, 0x35, 0xfe, 0xb4, 0x0c, 0x57, 0x9e, 0x69,
	0x39, 0xa9, 0xc2, 0x32, 0xf7, 0xd1, 0xa1, 0x39, 0x67, 0x99, 0xfb, 0xda, 0xc7, 0xe2, 0x37, 0x11,
	0x8b, 0x8d, 0x07, 0x1d, 0xb3, 0x20, 0xbf, 0x06, 0x98, 0x9e, 0x8b, 0x0e, 0x28, 0xed, 0x7d, 0xd9,
	0xb4, 0x5c, 0xe8, 0x18, 0x6c, 0xda, 0x18, 0x6c, 0xee, 0x0b, 0x1e, 0x75, 0x5a, 0x96, 0xc6, 0xaf,
	0x07, 0x5c, 0x0d, 0x93, 0x5e, 0xd3, 0x13, 0xa1, 0x0d, 0x5f, 0xfb, 0xdf, 0x6d, 0xe9, 0x1f, 0xb7,
	0xd4, 0x78, 0xc4, 0x24, 0x1a, 0x38, 0x33, 0xe8, 0xe4, 0x06, 0xcc, 0xbc, 0xd1, 0x35, 0x01, 0x87,
	0xde, 0x71, 0x6a, 0x53, 0x79, 0x17, 0x43, 0xef, 0xa7, 0x90, 0xd3, 0x3e, 0x40, 0xd2, 0xe7, 0x74,
	0x1e, 0x1a, 0x92, 0xaf, 0xa0, 0x1c, 0x50, 0xa9, 0x5c, 0xea, 0x79, 0x71, 0xc2, 0xfc, 0x7a, 0x7e,
	0x3b, 0xb3, 0x93, 0x75, 0x4a, 0x5a, 0xd6, 0x36, 0xa2, 0xc6, 0xff, 0x32, 0xf0, 0xad, 0x23, 0x71,
	0xcc, 0x22, 0xfe, 0x5b, 0xe6, 0x1f, 0xc5, 0x8c, 0xca, 0x24, 0x1e, 0xef, 0x8b, 0xa8, 0xcf, 0x07,
	0x1f, 0x48, 0x88, 0x2f, 0x20, 0xcf, 0xa5, 0x4c, 0x52, 0x0e, 0xed, 0x8a, 0x7c, 0x0d, 0xb5, 0x24,
	0xf2, 0x59, 0x1c, 0x8c, 0xb5, 0x97, 0xf4, 0xeb, 0x4d, 0x28, 0x3b, 0xd5, 0xa9, 0xf8, 0x68, 0x3c,
	0x62, 0x33, 0xd1, 0x94, 0x9b, 0x8d, 0x26, 0xb2, 0x05, 0xa5, 0x21, 0xe5, 0xb1, 0x97, 0x28, 0xb7,
	0x37, 0x92, 0xf8, 0xea, 0x8a, 0x03, 0x56, 0xd4, 0x19, 0x49, 0x72, 0x0b, 0x48, 0x48, 0x4f, 0x5d,
	0x1a, 0x04, 0xc2, 0x33, 0xd9, 0xa8, 0xf5, 0xf2, 0xa8, 0xb7, 0x12, 0xd2, 0xd3, 0x76, 0xba, 0xa1,
	0xb5, 0xbf, 0x82, 0xb2, 0x88, 0xa9, 0x17, 0x30, 0x4b, 0xf2, 0x55, 0xbc, 0x4c, 0xc9, 0xc8, 0x90,
	0xe0, 0xc6, 0xdf, 0xf3, 0x50, 0x71, 0x98, 0x64, 0xf1, 0x09, 0xb3, 0xd1, 0xb6, 0x0b, 0xeb, 0x21,
	0x8f, 0xdc, 0xd8, 0x08, 0x4d, 0xb6, 0xe3, 0x29, 0x19, 0x3c, 0x85, 0x84, 0x3c, 0xb2, 0x06, 0x98,
	0xbd, 0xfa, 0x9c, 0x1f, 0x43, 0x5d, 0xd1, 0x78, 0xc0, 0xd4, 0x25, 0x56, 0xcb, 0x68, 0xb5, 0x6e,
	0xf6, 0xcf, 0x1b, 0x6e, 0x43, 0x59, 0xc7, 0xb4, 0x4e, 0x7a, 0x54, 0xce, 0x9a, 0x07, 0x6b, 0xd9,
	0x5d, 0xc6, 0xb4, 0xc6, 0x75, 0xa8, 0xc6, 0xcc, 0x67, 0x2c, 0x4c, 0x75, 0x72, 0xa8, 0x53, 0x36,
	0x52, 0xab, 0x75, 0x08, 0x35, 0x7d, 0x67, 0xc4, 0xa2, 0xa1, 0x48, 0xa2, 0x85, 0x22, 0xa6, 0x12,
	0xf2, 0x48, 0xa7, 0x51, 0x1b, 0x11, 0x74, 0x3e, 0x1b, 0x22, 0xf0, 0x78, 0x0b, 0x9b, 0x9f, 0x1f,
	0xb6, 0x86, 0x8c, 0x69, 0x10, 0x0b, 0xfc, 0x08, 0x56, 0x34, 0x68, 0x38, 0x42, 0x07, 0xfa, 0x2c,
	0xa0, 0x63, 0x74, 0x8d, 0xce, 0x38, 0x53, 0xb4, 0x9b, 0x93, 0xa2, 0xdd, 0xec, 0xda, 0xa2, 0xdd,
	0x29, 0xe8, 0x23, 0x7f, 0xff, 0x76, 0x2b, 0xe3, 0xd4, 0xa6, 0xc6, 0x5d, 0x6d, 0x4b, 0x7e, 0x01,
	0x55, 0x1d, 0x14, 0x3e, 0xe5, 0xc1, 0x18, 0x39, 0xa8, 0x17, 0xe6, 0xbf, 0x65, 0x39, 0xa4, 0xa7,
	0x5d, 0x8d, 0xa0, 0x19, 0x20, 0x4f, 0x61, 0x65, 0x0a, 0x69, 0x18, 0xa8, 0x17, 0xe7, 0x07, 0xad,
	0x4e, 0x40, 0xcd, 0xfb, 0x09, 0x83, 0x35, 0x35, 0xc9, 0x34, 0x57, 0x99, 0x54, 0xe3, 0x4c, 0xd6,
	0x01, 0xab, 0xe4, 0xad, 0x4b, 0xab, 0xe4, 0x07, 0x52, 0xd3, 0x56, 0xcb, 0x6b, 0xea, 0xdc, 0x36,
	0x67, 0x52, 0xa7, 0x51, 0xcc, 0x5e, 0x24, 0x3c, 0x66, 0xee, 0xf1, 0xd8, 0xab, 0x97, 0x30, 0xc7,
	0xc0, 0x8a, 0x7e, 0x3e, 0xf6, 0xb4, 0x02, 0xc6, 0xca, 0x88, 0x26, 0x92, 0xf9, 0xf5, 0xb2, 0x51,
	0xd0, 0xa2, 0x27, 0x28, 0x21, 0xdf, 0x83, 0x8a, 0xf5, 0xbb, 0x55, 0xa9, 0xa0, 0x8a, 0x8d, 0x3a,
	0xa3, 0xd4, 0xf8, 0x73, 0x16, 0xae, 0xda, 0x88, 0x26, 0x0a, 0x6a, 0x4a, 0x28, 0x2c, 0x67, 0x23,
	0x21, 0xb9, 0x62, 0xbe, 0x2d, 0xfd, 0xdf, 0x50, 0x44, 0x7f, 0xa8, 0x5f, 0xf0, 0x97, 0xb7, 0x5b,
	0x3b, 0x1f, 0x59, 0x44, 0xa5, 0x53, 0xc5, 0x33, 0xba, 0x93, 0x23, 0xc8, 0x01, 0x94, 0xcc, 0xa9,
	0x27, 0x34, 0x48, 0x98, 0xed, 0xc9, 0x73, 0x79, 0x08, 0xd0, 0xfe, 0x99, 0x36, 0x27, 0x8f, 0xa0,
	0x6c, 0xd0, 0x34, 0x11, 0xcc, 0xb7, 0x6d, 0x78, 0x2e, 0x38, 0x73, 0x9d, 0x87, 0x68, 0x4f, 0x7e,
	0x62, 0x6b, 0x6f, 0x32, 0xf2, 0xa9, 0xc6, 0xd3, 0x99, 0x9b, 0xed, 0xac, 0x9f, 0xbd, 0xd9, 0x5a,
	0x3d, 0xa0, 0x52, 0x3d, 0x35, 0xe2, 0xfb, 0x8c, 0x0f, 0x86, 0xca, 0x94, 0x64, 0x2b, 0x22, 0x4f,
	0x60, 0x75, 0xd6, 0xd2, 0xd5, 0xb3, 0x0d, 0x66, 0x74, 0x69, 0x6f, 0xe3, 0x42, 0x8a, 0x1c, 0x4d,
	0x06, 0x1f, 0x93, 0x23, 0x2f, 0x31, 0x47, 0x66, 0xd0, 0xf4, 0x7e, 0xe3, 0x0f, 0x59, 0xa8, 0x5a,
	0x5f, 0x59, 0xfa, 0x2e, 0x34, 0xc6, 0xef, 0x40, 0xd1, 0x3a, 0x4f, 0x4c, 0x0a, 0xfb, 0x54, 0x40,
	0x7a, 0x90, 0xb7, 0x25, 0xe0, 0xf3, 0x37, 0x47, 0x8b, 0x4c, 0xee, 0x43, 0x31, 0x91, 0xbe, 0x75,
	0xe6, 0x02, 0xf3, 0x4a, 0x21, 0x91, 0x7e, 0xea, 0x4a, 0x29, 0x35, 0x96, 0x75, 0xe5, 0x02, 0xd5,
	0xb0, 0x84, 0x00, 0xd6, 0x95, 0xf7, 0xa0, 0x9c, 0x06, 0xb6, 0x4b, 0x4d, 0x19, 0xfc, 0x58, 0x5f,
	0x94, 0x52, 0xcb, 0x36, 0xce, 0x51, 0x3a, 0xc9, 0x13, 0x69, 0x9b, 0x91, 0x5d, 0x35, 0xfe, 0x98,
	0x83, 0x55, 0x27, 0xad, 0x6b, 0x0e, 0x7b, 0x91, 0x30, 0x79, 0xa9, 0x8b, 0x62, 0xb3, 0x95, 0xf6,
	0xde, 0xa9, 0x60, 0xfa, 0xe8, 0x19, 0x47, 0x2d, 0xf4, 0x68, 0x5b, 0xa7, 0x75, 0xfb, 0x4c, 0xd4,
	0x28, 0x51, 0xef, 0xcd, 0x28, 0x25, 0x23, 0x33, 0xf3, 0xc9, 0x3d, 0x28, 0x4f, 0xce, 0x47, 0x5e,
	0xe6, 0x89, 0xd1, 0x52, 0x6a, 0xd9, 0x56, 0xe4, 0x31, 0xac, 0xb0, 0x53, 0xe6, 0x25, 0x58, 0xf7,
	0x5c, 0xda, 0xd7, 0x0f, 0x9c, 0x87, 0xe4, 0xda, 0xd4, 0xba, 0xad, 0x8d, 0x3f, 0x44, 0x34, 0xb9,
	0x03, 0x25, 0xa3, 0x6a, 0x2e, 0x5c, 0x98, 0xe3, 0x0c, 0x98, 0x18, 0xb6, 0x15, 0x11, 0x50, 0xb1,
	0xdc, 0x58, 0xb2, 0x8b, 0x9f, 0x3d, 0x2b, 0x2c, 0xf9, 0xc6, 0x19, 0x8d, 0x57, 0x19, 0xa8, 0xa6,
	0xfd, 0xe9, 0x50, 0x51, 0x25, 0x09, 0x81, 0x9c, 0x4e, 0x70, 0x3b, 0x9b, 0xe1, 0xdf, 0x17, 0x6a,
	0xd8, 0xf2, 0x27, 0xd6, 0x30, 0x07, 0x4c, 0xcd, 0xb5, 0x4d, 0x70, 0xb1, 0xaa, 0x58, 0x41, 0x08,
	0xc7, 0x22, 0x34, 0xfe, 0x9b, 0x87, 0x8d, 0xc7, 0xfd, 0xfe, 0xfe, 0x90, 0xa6, 0xa3, 0x54, 0x5b,
	0x29, 0x4d, 0xb7, 0x8e, 0xfd, 0x0b, 0x41, 0xbf, 0x01, 0x05, 0x8a, 0xdb, 0x69, 0xcc, 0xa7, 0x6b,
	0xfd, 0x89, 0x63, 0xae, 0xe7, 0x51, 0x39, 0x5c, 0xe4, 0x6a, 0x45, 0x34, 0xdf, 0xa7, 0x72, 0x38,
	0xa5, 0x4e, 0xf5, 0x78, 0x10, 0xc8, 0x45, 0x0a, 0x90, 0xa1, 0xee, 0x08, 0xed, 0x67, 0xf0, 0x22,
	0xa1, 0x98, 0x5c, 0xa8, 0x06, 0x19, 0x3c, 0xb4, 0x9f, 0xbd, 0x9f, 0x88, 0x7c, 0xb9, 0xc8, 0x28,
	0x36, 0xb9, 0x9f, 0xb6, 0x9f, 0x36, 0xcf, 0x58, 0xd7, 0x27, 0x93, 0x26, 0x8b, 0x34, 0x4f, 0x47,
	0x9b, 0xeb, 0xda, 0x6d, 0x03, 0x2f, 0xec, 0x2f, 0x32, 0x7f, 0x15, 0x4c, 0xd4, 0x85, 0xfd, 0xf3,
	0x4d, 0xbd, 0xf8, 0x69, 0x4d, 0xfd, 0xfb, 0x50, 0xf5, 0x12, 0xa9, 0x84, 0xcf, 0x69, 0xe4, 0x46,
	0x34, 0x64, 0x75, 0xc0, 0x18, 0xaa, 0xa4, 0xd2, 0x47, 0x34, 0x64, 0xe4, 0xbb, 0x00, 0x34, 0xf1,
	0xb9, 0x72, 0xfb, 0x3c, 0x0e, 0x71, 0x62, 0x2a, 0x3a, 0x45, 0x94, 0xdc, 0xe5, 0x71, 0xa8, 0xab,
	0x86, 0x66, 0x29, 0x56, 0x2e, 0x66, 0x5c, 0x79, 0x9e, 0xaa, 0x61, 0x0c, 0xbb, 0x3a, 0x3b, 0x6f,
	0xc0, 0x0a, 0x9d, 0x46, 0xba, 0x3b, 0xd4, 0x41, 0x5b, 0x31, 0x5f, 0x7e, 0x33, 0xf2, 0xfb, 0x3a,
	0x1a, 0x3b, 0x50, 0x4c, 0x7f, 0xd1, 0xa8, 0x57, 0xe7, 0x38, 0x6f, 0x6a, 0xd6, 0xf8, 0x6b, 0x0e,
	0x2a, 0x47, 0xc6, 0x45, 0x98, 0x65, 0x52, 0x8f, 0xca, 0x22, 0x72, 0x3d, 0x9d, 0x79, 0x96, 0xde,
	0xcc, 0x02, 0xa3, 0xb2, 0x88, 0x30, 0x77, 0x0d, 0xc1, 0x87, 0x50, 0x13, 0xfd, 0xfe, 0x7b, 0x98,
	0x0b, 0x14, 0x9d, 0x8a, 0xb0, 0x05, 0xc1, 0x80, 0x9e, 0x8b, 0x81, 0xec, 0x67, 0x1a, 0xec, 0x64,
	0x32, 0x1a, 0x05, 0xe3, 0xc5, 0x33, 0xfb, 0x10, 0xed, 0xc9, 0x0f, 0x60, 0xf5, 0xe2, 0x87, 0x9e,
	0xf9, 0x58, 0xad, 0xc5, 0xe7, 0x3e, 0xf1, 0x9e, 0xc2, 0x1a, 0x8e, 0x72, 0x29, 0xed, 0x66, 0xa6,
	0x9b, 0xab, 0xb9, 0xe1, 0x30, 0xf8, 0xd8, 0x90, 0x6e, 0x86, 0x3a, 0xf2, 0x1c, 0xd6, 0x0d, 0x6c,
	0x4a, 0xbd, 0xc5, 0xbd, 0x3a, 0x07, 0x2e, 0x41, 0x5c, 0x4b, 0xbc, 0x01, 0xee, 0xdc, 0x79, 0x75,
	0xb6, 0x99, 0x79, 0x7d, 0xb6, 0x99, 0xf9, 0xcf, 0xd9, 0x66, 0xe6, 0xe5, 0xbb, 0xcd, 0xa5, 0xd7,
	0xef, 0x36, 0x97, 0xfe, 0xf5, 0x6e, 0x73, 0xe9, 0x97, 0x37, 0x67, 0x1a, 0x57, 0xfa, 0x43, 0xa0,
	0x27, 0x62, 0xd6, 0x3a, 0x9d, 0xfd, 0x3d, 0x10, 0x3b, 0x58, 0x2f, 0x8f, 0x07, 0xff, 0xe8, 0xff,
	0x01, 0x00, 0x00, 0xff, 0xff, 0x66, 0x82, 0xc6, 0x3a, 0x33, 0x14, 0x00, 0x00,
}

func (m *CollateralParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollateralParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollateralParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.DebtLimit.Size()
		i -= size
		if _, err := m.DebtLimit.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.StabilityFee.Size()
		i -= size
		if _, err := m.StabilityFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.LiquidationRatio.Size()
		i -= size
		if _, err := m.LiquidationRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintStablecoin(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VaultMintingEnabled {
		i--
		if m.VaultMintingEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.CollateralParams) > 0 {
		for iNdEx := len(m.CollateralParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollateralParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStablecoin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Vault) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vault) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vault) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastAccrued != 0 {
		i = encodeVarintStablecoin(dAtA, i, uint64(m.LastAccrued))
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.Debt.Size()
		i -= size
		if _, err := m.Debt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.CollateralDenom) > 0 {
		i -= len(m.CollateralDenom)
		copy(dAtA[i:], m.CollateralDenom)
		i = encodeVarintStablecoin(dAtA, i, uint64(len(m.CollateralDenom)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.Collateral.Size()
		i -= size
		if _, err := m.Collateral.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintStablecoin(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintStablecoin(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TokenizedTreasuryConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenizedTreasuryConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenizedTreasuryConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OracleDenom) > 0 {
		i -= len(m.OracleDenom)
		copy(dAtA[i:], m.OracleDenom)
		i = encodeVarintStablecoin(dAtA, i, uint64(len(m.OracleDenom)))
		i--
		dAtA[i] = 0x3a
	}
	if m.MaxAllocationBps != 0 {
		i = encodeVarintStablecoin(dAtA, i, uint64(m.MaxAllocationBps))
		i--
		dAtA[i] = 0x30
	}
	if m.HaircutBps != 0 {
		i = encodeVarintStablecoin(dAtA, i, uint64(m.HaircutBps))
		i--
		dAtA[i] = 0x28
	}
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.UnderlyingType) > 0 {
		i -= len(m.UnderlyingType)
		copy(dAtA[i:], m.UnderlyingType)
		i = encodeVarintStablecoin(dAtA, i, uint64(len(m.UnderlyingType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintStablecoin(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintStablecoin(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReserveParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReserveParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReserveParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RedeemPaused {
		i--
		if m.RedeemPaused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.MintPaused {
		i--
		if m.MintPaused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.RequireKyc {
		i--
		if m.RequireKyc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.TokenizedTreasuries) > 0 {
		for iNdEx := len(m.TokenizedTreasuries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TokenizedTreasuries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStablecoin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	{
		size := m.MaxDailyRedeem.Size()
		i -= size
		if _, err := m.MaxDailyRedeem.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size := m.MaxDailyMint.Size()
		i -= size
		if _, err := m.MaxDailyMint.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	n2, err2 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(m.RedemptionDelay, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.RedemptionDelay):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintStablecoin(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x3a
	{
		size := m.MinRedeemAmount.Size()
		i -= size
		if _, err := m.MinRedeemAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.MinMintAmount.Size()
		i -= size
		if _, err := m.MinMintAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.RedeemFeeBps != 0 {
		i = encodeVarintStablecoin(dAtA, i, uint64(m.RedeemFeeBps))
		i--
		dAtA[i] = 0x20
	}
	if m.MintFeeBps != 0 {
		i = encodeVarintStablecoin(dAtA, i, uint64(m.MintFeeBps))
		i--
		dAtA[i] = 0x18
	}
	if m.TargetReserveRatioBps != 0 {
		i = encodeVarintStablecoin(dAtA, i, uint64(m.TargetReserveRatioBps))
		i--
		dAtA[i] = 0x10
	}
	if m.MinReserveRatioBps != 0 {
		i = encodeVarintStablecoin(dAtA, i, uint64(m.MinReserveRatioBps))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Reserve) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reserve) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Reserve) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastUpdatedTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastUpdatedTime):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintStablecoin(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x2a
	if m.LastUpdatedHeight != 0 {
		i = encodeVarintStablecoin(dAtA, i, uint64(m.LastUpdatedHeight))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.TotalMinted.Size()
		i -= size
		if _, err := m.TotalMinted.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalValue.Size()
		i -= size
		if _, err := m.TotalValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.TotalDeposited) > 0 {
		for iNdEx := len(m.TotalDeposited) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalDeposited[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStablecoin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReserveDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReserveDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReserveDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintStablecoin(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x3a
	}
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.DepositedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.DepositedAt):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintStablecoin(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x32
	{
		size := m.SsusdMinted.Size()
		i -= size
		if _, err := m.SsusdMinted.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.UsdValue.Size()
		i -= size
		if _, err := m.UsdValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Depositor) > 0 {
		i -= len(m.Depositor)
		copy(dAtA[i:], m.Depositor)
		i = encodeVarintStablecoin(dAtA, i, uint64(len(m.Depositor)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintStablecoin(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RedemptionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedemptionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RedemptionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.OutputAmount.Size()
		i -= size
		if _, err := m.OutputAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	n7, err7 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ExecutedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExecutedAt):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintStablecoin(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x42
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintStablecoin(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x3a
	}
	n8, err8 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ExecutableAfter, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExecutableAfter):])
	if err8 != nil {
		return 0, err8
	}
	i -= n8
	i = encodeVarintStablecoin(dAtA, i, uint64(n8))
	i--
	dAtA[i] = 0x32
	n9, err9 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.RequestedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.RequestedAt):])
	if err9 != nil {
		return 0, err9
	}
	i -= n9
	i = encodeVarintStablecoin(dAtA, i, uint64(n9))
	i--
	dAtA[i] = 0x2a
	if len(m.OutputDenom) > 0 {
		i -= len(m.OutputDenom)
		copy(dAtA[i:], m.OutputDenom)
		i = encodeVarintStablecoin(dAtA, i, uint64(len(m.OutputDenom)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.SsusdAmount.Size()
		i -= size
		if _, err := m.SsusdAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Requester) > 0 {
		i -= len(m.Requester)
		copy(dAtA[i:], m.Requester)
		i = encodeVarintStablecoin(dAtA, i, uint64(len(m.Requester)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintStablecoin(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DailyMintStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DailyMintStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DailyMintStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TotalRedeemed.Size()
		i -= size
		if _, err := m.TotalRedeemed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalMinted.Size()
		i -= size
		if _, err := m.TotalMinted.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Date) > 0 {
		i -= len(m.Date)
		copy(dAtA[i:], m.Date)
		i = encodeVarintStablecoin(dAtA, i, uint64(len(m.Date)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OffChainReserveAttestation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OffChainReserveAttestation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OffChainReserveAttestation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n10, err10 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp):])
	if err10 != nil {
		return 0, err10
	}
	i -= n10
	i = encodeVarintStablecoin(dAtA, i, uint64(n10))
	i--
	dAtA[i] = 0x72
	if len(m.AttestationHash) > 0 {
		i -= len(m.AttestationHash)
		copy(dAtA[i:], m.AttestationHash)
		i = encodeVarintStablecoin(dAtA, i, uint64(len(m.AttestationHash)))
		i--
		dAtA[i] = 0x6a
	}
	n11, err11 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ReportDate, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ReportDate):])
	if err11 != nil {
		return 0, err11
	}
	i -= n11
	i = encodeVarintStablecoin(dAtA, i, uint64(n11))
	i--
	dAtA[i] = 0x62
	if len(m.AuditFirm) > 0 {
		i -= len(m.AuditFirm)
		copy(dAtA[i:], m.AuditFirm)
		i = encodeVarintStablecoin(dAtA, i, uint64(len(m.AuditFirm)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.CustodianName) > 0 {
		i -= len(m.CustodianName)
		copy(dAtA[i:], m.CustodianName)
		i = encodeVarintStablecoin(dAtA, i, uint64(len(m.CustodianName)))
		i--
		dAtA[i] = 0x52
	}
	{
		size := m.TotalValue.Size()
		i -= size
		if _, err := m.TotalValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size := m.TotalMmf.Size()
		i -= size
		if _, err := m.TotalMmf.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.TotalRepos.Size()
		i -= size
		if _, err := m.TotalRepos.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.TotalTbonds.Size()
		i -= size
		if _, err := m.TotalTbonds.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.TotalTnotes.Size()
		i -= size
		if _, err := m.TotalTnotes.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.TotalTbills.Size()
		i -= size
		if _, err := m.TotalTbills.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.TotalCash.Size()
		i -= size
		if _, err := m.TotalCash.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Attester) > 0 {
		i -= len(m.Attester)
		copy(dAtA[i:], m.Attester)
		i = encodeVarintStablecoin(dAtA, i, uint64(len(m.Attester)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintStablecoin(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TotalReserves) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TotalReserves) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TotalReserves) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n12, err12 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastOffChainUpdate, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastOffChainUpdate):])
	if err12 != nil {
		return 0, err12
	}
	i -= n12
	i = encodeVarintStablecoin(dAtA, i, uint64(n12))
	i--
	dAtA[i] = 0x3a
	n13, err13 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastOnChainUpdate, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastOnChainUpdate):])
	if err13 != nil {
		return 0, err13
	}
	i -= n13
	i = encodeVarintStablecoin(dAtA, i, uint64(n13))
	i--
	dAtA[i] = 0x32
	if m.ReserveRatioBps != 0 {
		i = encodeVarintStablecoin(dAtA, i, uint64(m.ReserveRatioBps))
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.TotalSupply.Size()
		i -= size
		if _, err := m.TotalSupply.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.TotalValue.Size()
		i -= size
		if _, err := m.TotalValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.OffChainValue.Size()
		i -= size
		if _, err := m.OffChainValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.OnChainValue.Size()
		i -= size
		if _, err := m.OnChainValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStablecoin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintStablecoin(dAtA []byte, offset int, v uint64) int {
	offset -= sovStablecoin(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CollateralParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovStablecoin(uint64(l))
	}
	l = m.LiquidationRatio.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	l = m.StabilityFee.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	l = m.DebtLimit.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	if m.Active {
		n += 2
	}
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CollateralParams) > 0 {
		for _, e := range m.CollateralParams {
			l = e.Size()
			n += 1 + l + sovStablecoin(uint64(l))
		}
	}
	if m.VaultMintingEnabled {
		n += 2
	}
	return n
}

func (m *Vault) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStablecoin(uint64(m.Id))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovStablecoin(uint64(l))
	}
	l = m.Collateral.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	l = len(m.CollateralDenom)
	if l > 0 {
		n += 1 + l + sovStablecoin(uint64(l))
	}
	l = m.Debt.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	if m.LastAccrued != 0 {
		n += 1 + sovStablecoin(uint64(m.LastAccrued))
	}
	return n
}

func (m *TokenizedTreasuryConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovStablecoin(uint64(l))
	}
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovStablecoin(uint64(l))
	}
	l = len(m.UnderlyingType)
	if l > 0 {
		n += 1 + l + sovStablecoin(uint64(l))
	}
	if m.Active {
		n += 2
	}
	if m.HaircutBps != 0 {
		n += 1 + sovStablecoin(uint64(m.HaircutBps))
	}
	if m.MaxAllocationBps != 0 {
		n += 1 + sovStablecoin(uint64(m.MaxAllocationBps))
	}
	l = len(m.OracleDenom)
	if l > 0 {
		n += 1 + l + sovStablecoin(uint64(l))
	}
	return n
}

func (m *ReserveParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinReserveRatioBps != 0 {
		n += 1 + sovStablecoin(uint64(m.MinReserveRatioBps))
	}
	if m.TargetReserveRatioBps != 0 {
		n += 1 + sovStablecoin(uint64(m.TargetReserveRatioBps))
	}
	if m.MintFeeBps != 0 {
		n += 1 + sovStablecoin(uint64(m.MintFeeBps))
	}
	if m.RedeemFeeBps != 0 {
		n += 1 + sovStablecoin(uint64(m.RedeemFeeBps))
	}
	l = m.MinMintAmount.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	l = m.MinRedeemAmount.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.RedemptionDelay)
	n += 1 + l + sovStablecoin(uint64(l))
	l = m.MaxDailyMint.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	l = m.MaxDailyRedeem.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	if len(m.TokenizedTreasuries) > 0 {
		for _, e := range m.TokenizedTreasuries {
			l = e.Size()
			n += 1 + l + sovStablecoin(uint64(l))
		}
	}
	if m.RequireKyc {
		n += 2
	}
	if m.MintPaused {
		n += 2
	}
	if m.RedeemPaused {
		n += 2
	}
	return n
}

func (m *Reserve) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TotalDeposited) > 0 {
		for _, e := range m.TotalDeposited {
			l = e.Size()
			n += 1 + l + sovStablecoin(uint64(l))
		}
	}
	l = m.TotalValue.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	l = m.TotalMinted.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	if m.LastUpdatedHeight != 0 {
		n += 1 + sovStablecoin(uint64(m.LastUpdatedHeight))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastUpdatedTime)
	n += 1 + l + sovStablecoin(uint64(l))
	return n
}

func (m *ReserveDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStablecoin(uint64(m.Id))
	}
	l = len(m.Depositor)
	if l > 0 {
		n += 1 + l + sovStablecoin(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	l = m.UsdValue.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	l = m.SsusdMinted.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.DepositedAt)
	n += 1 + l + sovStablecoin(uint64(l))
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovStablecoin(uint64(l))
	}
	return n
}

func (m *RedemptionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStablecoin(uint64(m.Id))
	}
	l = len(m.Requester)
	if l > 0 {
		n += 1 + l + sovStablecoin(uint64(l))
	}
	l = m.SsusdAmount.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	l = len(m.OutputDenom)
	if l > 0 {
		n += 1 + l + sovStablecoin(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.RequestedAt)
	n += 1 + l + sovStablecoin(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExecutableAfter)
	n += 1 + l + sovStablecoin(uint64(l))
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovStablecoin(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExecutedAt)
	n += 1 + l + sovStablecoin(uint64(l))
	l = m.OutputAmount.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	return n
}

func (m *DailyMintStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovStablecoin(uint64(l))
	}
	l = m.TotalMinted.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	l = m.TotalRedeemed.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	return n
}

func (m *OffChainReserveAttestation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStablecoin(uint64(m.Id))
	}
	l = len(m.Attester)
	if l > 0 {
		n += 1 + l + sovStablecoin(uint64(l))
	}
	l = m.TotalCash.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	l = m.TotalTbills.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	l = m.TotalTnotes.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	l = m.TotalTbonds.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	l = m.TotalRepos.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	l = m.TotalMmf.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	l = m.TotalValue.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	l = len(m.CustodianName)
	if l > 0 {
		n += 1 + l + sovStablecoin(uint64(l))
	}
	l = len(m.AuditFirm)
	if l > 0 {
		n += 1 + l + sovStablecoin(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ReportDate)
	n += 1 + l + sovStablecoin(uint64(l))
	l = len(m.AttestationHash)
	if l > 0 {
		n += 1 + l + sovStablecoin(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovStablecoin(uint64(l))
	return n
}

func (m *TotalReserves) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OnChainValue.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	l = m.OffChainValue.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	l = m.TotalValue.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	l = m.TotalSupply.Size()
	n += 1 + l + sovStablecoin(uint64(l))
	if m.ReserveRatioBps != 0 {
		n += 1 + sovStablecoin(uint64(m.ReserveRatioBps))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastOnChainUpdate)
	n += 1 + l + sovStablecoin(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastOffChainUpdate)
	n += 1 + l + sovStablecoin(uint64(l))
	return n
}

func sovStablecoin(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStablecoin(x uint64) (n int) {
	return sovStablecoin(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CollateralParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStablecoin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollateralParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollateralParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidationRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LiquidationRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StabilityFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StabilityFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebtLimit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DebtLimit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStablecoin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStablecoin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStablecoin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollateralParams = append(m.CollateralParams, CollateralParam{})
			if err := m.CollateralParams[len(m.CollateralParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultMintingEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VaultMintingEnabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStablecoin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStablecoin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vault) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStablecoin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vault: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vault: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collateral", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collateral.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollateralDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Debt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastAccrued", wireType)
			}
			m.LastAccrued = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastAccrued |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStablecoin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStablecoin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenizedTreasuryConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStablecoin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenizedTreasuryConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenizedTreasuryConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnderlyingType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnderlyingType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HaircutBps", wireType)
			}
			m.HaircutBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HaircutBps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAllocationBps", wireType)
			}
			m.MaxAllocationBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAllocationBps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStablecoin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStablecoin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReserveParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStablecoin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReserveParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReserveParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinReserveRatioBps", wireType)
			}
			m.MinReserveRatioBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinReserveRatioBps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetReserveRatioBps", wireType)
			}
			m.TargetReserveRatioBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetReserveRatioBps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintFeeBps", wireType)
			}
			m.MintFeeBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MintFeeBps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedeemFeeBps", wireType)
			}
			m.RedeemFeeBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RedeemFeeBps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinMintAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinMintAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinRedeemAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinRedeemAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedemptionDelay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(&m.RedemptionDelay, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDailyMint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxDailyMint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDailyRedeem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxDailyRedeem.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenizedTreasuries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenizedTreasuries = append(m.TokenizedTreasuries, TokenizedTreasuryConfig{})
			if err := m.TokenizedTreasuries[len(m.TokenizedTreasuries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireKyc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireKyc = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintPaused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MintPaused = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedeemPaused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RedeemPaused = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStablecoin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStablecoin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reserve) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStablecoin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reserve: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reserve: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDeposited", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalDeposited = append(m.TotalDeposited, types.Coin{})
			if err := m.TotalDeposited[len(m.TotalDeposited)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMinted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalMinted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdatedHeight", wireType)
			}
			m.LastUpdatedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdatedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdatedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastUpdatedTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStablecoin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStablecoin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReserveDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStablecoin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReserveDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReserveDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depositor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Depositor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsdValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UsdValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SsusdMinted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SsusdMinted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.DepositedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStablecoin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStablecoin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedemptionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStablecoin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedemptionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedemptionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SsusdAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SsusdAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.RequestedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutableAfter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ExecutableAfter, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ExecutedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OutputAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStablecoin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStablecoin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DailyMintStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStablecoin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DailyMintStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DailyMintStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMinted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalMinted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRedeemed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalRedeemed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStablecoin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStablecoin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OffChainReserveAttestation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStablecoin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OffChainReserveAttestation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OffChainReserveAttestation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalCash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalTbills", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalTbills.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalTnotes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalTnotes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalTbonds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalTbonds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRepos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalRepos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMmf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalMmf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustodianName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustodianName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuditFirm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuditFirm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ReportDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStablecoin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStablecoin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TotalReserves) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStablecoin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TotalReserves: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TotalReserves: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnChainValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OnChainValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffChainValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OffChainValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSupply", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalSupply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReserveRatioBps", wireType)
			}
			m.ReserveRatioBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReserveRatioBps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastOnChainUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastOnChainUpdate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastOffChainUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStablecoin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStablecoin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastOffChainUpdate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStablecoin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStablecoin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStablecoin(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStablecoin
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStablecoin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStablecoin
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStablecoin
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStablecoin
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStablecoin        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStablecoin          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStablecoin = fmt.Errorf("proto: unexpected end of group")
)
